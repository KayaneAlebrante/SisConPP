
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Candidato
 * 
 */
export type Candidato = $Result.DefaultSelection<Prisma.$CandidatoPayload>
/**
 * Model Usuario
 * 
 */
export type Usuario = $Result.DefaultSelection<Prisma.$UsuarioPayload>
/**
 * Model CTG
 * 
 */
export type CTG = $Result.DefaultSelection<Prisma.$CTGPayload>
/**
 * Model RT
 * 
 */
export type RT = $Result.DefaultSelection<Prisma.$RTPayload>
/**
 * Model PreferenciaSorteioDanca
 * 
 */
export type PreferenciaSorteioDanca = $Result.DefaultSelection<Prisma.$PreferenciaSorteioDancaPayload>
/**
 * Model Concurso
 * 
 */
export type Concurso = $Result.DefaultSelection<Prisma.$ConcursoPayload>
/**
 * Model Comissao
 * 
 */
export type Comissao = $Result.DefaultSelection<Prisma.$ComissaoPayload>
/**
 * Model ComissaoUsuario
 * 
 */
export type ComissaoUsuario = $Result.DefaultSelection<Prisma.$ComissaoUsuarioPayload>
/**
 * Model Categoria
 * 
 */
export type Categoria = $Result.DefaultSelection<Prisma.$CategoriaPayload>
/**
 * Model Avaliacao
 * 
 */
export type Avaliacao = $Result.DefaultSelection<Prisma.$AvaliacaoPayload>
/**
 * Model Prova
 * 
 */
export type Prova = $Result.DefaultSelection<Prisma.$ProvaPayload>
/**
 * Model ProvaTeorica
 * 
 */
export type ProvaTeorica = $Result.DefaultSelection<Prisma.$ProvaTeoricaPayload>
/**
 * Model ProvaPratica
 * 
 */
export type ProvaPratica = $Result.DefaultSelection<Prisma.$ProvaPraticaPayload>
/**
 * Model BlocoProva
 * 
 */
export type BlocoProva = $Result.DefaultSelection<Prisma.$BlocoProvaPayload>
/**
 * Model Quesitos
 * 
 */
export type Quesitos = $Result.DefaultSelection<Prisma.$QuesitosPayload>
/**
 * Model SubQuesitos
 * 
 */
export type SubQuesitos = $Result.DefaultSelection<Prisma.$SubQuesitosPayload>
/**
 * Model Recurso
 * 
 */
export type Recurso = $Result.DefaultSelection<Prisma.$RecursoPayload>
/**
 * Model SorteioDanca
 * 
 */
export type SorteioDanca = $Result.DefaultSelection<Prisma.$SorteioDancaPayload>
/**
 * Model FichaCandidato
 * 
 */
export type FichaCandidato = $Result.DefaultSelection<Prisma.$FichaCandidatoPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ProvaCampeiraEsportiva: {
  CAMPEIRA: 'CAMPEIRA',
  ESPORTIVA: 'ESPORTIVA',
  AMBAS: 'AMBAS',
  NENHUMA: 'NENHUMA'
};

export type ProvaCampeiraEsportiva = (typeof ProvaCampeiraEsportiva)[keyof typeof ProvaCampeiraEsportiva]


export const Funcao: {
  SECRETARIO: 'SECRETARIO',
  AVALIADOR: 'AVALIADOR',
  AUXILIAR: 'AUXILIAR'
};

export type Funcao = (typeof Funcao)[keyof typeof Funcao]


export const Credenciamento: {
  CREDENCIADO: 'CREDENCIADO',
  NAO_CREDENCIADO: 'NAO_CREDENCIADO'
};

export type Credenciamento = (typeof Credenciamento)[keyof typeof Credenciamento]


export const DancaSalaoTradicional: {
  DANCA_DE_SALAO: 'DANCA_DE_SALAO',
  DANCA_TRADICIONAL: 'DANCA_TRADICIONAL',
  NENHUMA: 'NENHUMA'
};

export type DancaSalaoTradicional = (typeof DancaSalaoTradicional)[keyof typeof DancaSalaoTradicional]

}

export type ProvaCampeiraEsportiva = $Enums.ProvaCampeiraEsportiva

export const ProvaCampeiraEsportiva: typeof $Enums.ProvaCampeiraEsportiva

export type Funcao = $Enums.Funcao

export const Funcao: typeof $Enums.Funcao

export type Credenciamento = $Enums.Credenciamento

export const Credenciamento: typeof $Enums.Credenciamento

export type DancaSalaoTradicional = $Enums.DancaSalaoTradicional

export const DancaSalaoTradicional: typeof $Enums.DancaSalaoTradicional

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Candidatoes
 * const candidatoes = await prisma.candidato.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Candidatoes
   * const candidatoes = await prisma.candidato.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.candidato`: Exposes CRUD operations for the **Candidato** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Candidatoes
    * const candidatoes = await prisma.candidato.findMany()
    * ```
    */
  get candidato(): Prisma.CandidatoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cTG`: Exposes CRUD operations for the **CTG** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CTGS
    * const cTGS = await prisma.cTG.findMany()
    * ```
    */
  get cTG(): Prisma.CTGDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rT`: Exposes CRUD operations for the **RT** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RTS
    * const rTS = await prisma.rT.findMany()
    * ```
    */
  get rT(): Prisma.RTDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.preferenciaSorteioDanca`: Exposes CRUD operations for the **PreferenciaSorteioDanca** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PreferenciaSorteioDancas
    * const preferenciaSorteioDancas = await prisma.preferenciaSorteioDanca.findMany()
    * ```
    */
  get preferenciaSorteioDanca(): Prisma.PreferenciaSorteioDancaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.concurso`: Exposes CRUD operations for the **Concurso** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Concursos
    * const concursos = await prisma.concurso.findMany()
    * ```
    */
  get concurso(): Prisma.ConcursoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comissao`: Exposes CRUD operations for the **Comissao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comissaos
    * const comissaos = await prisma.comissao.findMany()
    * ```
    */
  get comissao(): Prisma.ComissaoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comissaoUsuario`: Exposes CRUD operations for the **ComissaoUsuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ComissaoUsuarios
    * const comissaoUsuarios = await prisma.comissaoUsuario.findMany()
    * ```
    */
  get comissaoUsuario(): Prisma.ComissaoUsuarioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.categoria`: Exposes CRUD operations for the **Categoria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categorias
    * const categorias = await prisma.categoria.findMany()
    * ```
    */
  get categoria(): Prisma.CategoriaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.avaliacao`: Exposes CRUD operations for the **Avaliacao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Avaliacaos
    * const avaliacaos = await prisma.avaliacao.findMany()
    * ```
    */
  get avaliacao(): Prisma.AvaliacaoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.prova`: Exposes CRUD operations for the **Prova** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prova
    * const prova = await prisma.prova.findMany()
    * ```
    */
  get prova(): Prisma.ProvaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.provaTeorica`: Exposes CRUD operations for the **ProvaTeorica** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProvaTeoricas
    * const provaTeoricas = await prisma.provaTeorica.findMany()
    * ```
    */
  get provaTeorica(): Prisma.ProvaTeoricaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.provaPratica`: Exposes CRUD operations for the **ProvaPratica** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProvaPraticas
    * const provaPraticas = await prisma.provaPratica.findMany()
    * ```
    */
  get provaPratica(): Prisma.ProvaPraticaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blocoProva`: Exposes CRUD operations for the **BlocoProva** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlocoProva
    * const blocoProva = await prisma.blocoProva.findMany()
    * ```
    */
  get blocoProva(): Prisma.BlocoProvaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quesitos`: Exposes CRUD operations for the **Quesitos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quesitos
    * const quesitos = await prisma.quesitos.findMany()
    * ```
    */
  get quesitos(): Prisma.QuesitosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subQuesitos`: Exposes CRUD operations for the **SubQuesitos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubQuesitos
    * const subQuesitos = await prisma.subQuesitos.findMany()
    * ```
    */
  get subQuesitos(): Prisma.SubQuesitosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recurso`: Exposes CRUD operations for the **Recurso** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recursos
    * const recursos = await prisma.recurso.findMany()
    * ```
    */
  get recurso(): Prisma.RecursoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sorteioDanca`: Exposes CRUD operations for the **SorteioDanca** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SorteioDancas
    * const sorteioDancas = await prisma.sorteioDanca.findMany()
    * ```
    */
  get sorteioDanca(): Prisma.SorteioDancaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fichaCandidato`: Exposes CRUD operations for the **FichaCandidato** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FichaCandidatoes
    * const fichaCandidatoes = await prisma.fichaCandidato.findMany()
    * ```
    */
  get fichaCandidato(): Prisma.FichaCandidatoDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Candidato: 'Candidato',
    Usuario: 'Usuario',
    CTG: 'CTG',
    RT: 'RT',
    PreferenciaSorteioDanca: 'PreferenciaSorteioDanca',
    Concurso: 'Concurso',
    Comissao: 'Comissao',
    ComissaoUsuario: 'ComissaoUsuario',
    Categoria: 'Categoria',
    Avaliacao: 'Avaliacao',
    Prova: 'Prova',
    ProvaTeorica: 'ProvaTeorica',
    ProvaPratica: 'ProvaPratica',
    BlocoProva: 'BlocoProva',
    Quesitos: 'Quesitos',
    SubQuesitos: 'SubQuesitos',
    Recurso: 'Recurso',
    SorteioDanca: 'SorteioDanca',
    FichaCandidato: 'FichaCandidato'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "candidato" | "usuario" | "cTG" | "rT" | "preferenciaSorteioDanca" | "concurso" | "comissao" | "comissaoUsuario" | "categoria" | "avaliacao" | "prova" | "provaTeorica" | "provaPratica" | "blocoProva" | "quesitos" | "subQuesitos" | "recurso" | "sorteioDanca" | "fichaCandidato"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Candidato: {
        payload: Prisma.$CandidatoPayload<ExtArgs>
        fields: Prisma.CandidatoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CandidatoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidatoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CandidatoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidatoPayload>
          }
          findFirst: {
            args: Prisma.CandidatoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidatoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CandidatoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidatoPayload>
          }
          findMany: {
            args: Prisma.CandidatoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidatoPayload>[]
          }
          create: {
            args: Prisma.CandidatoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidatoPayload>
          }
          createMany: {
            args: Prisma.CandidatoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CandidatoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidatoPayload>[]
          }
          delete: {
            args: Prisma.CandidatoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidatoPayload>
          }
          update: {
            args: Prisma.CandidatoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidatoPayload>
          }
          deleteMany: {
            args: Prisma.CandidatoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CandidatoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CandidatoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidatoPayload>[]
          }
          upsert: {
            args: Prisma.CandidatoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CandidatoPayload>
          }
          aggregate: {
            args: Prisma.CandidatoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCandidato>
          }
          groupBy: {
            args: Prisma.CandidatoGroupByArgs<ExtArgs>
            result: $Utils.Optional<CandidatoGroupByOutputType>[]
          }
          count: {
            args: Prisma.CandidatoCountArgs<ExtArgs>
            result: $Utils.Optional<CandidatoCountAggregateOutputType> | number
          }
        }
      }
      Usuario: {
        payload: Prisma.$UsuarioPayload<ExtArgs>
        fields: Prisma.UsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findFirst: {
            args: Prisma.UsuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findMany: {
            args: Prisma.UsuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          create: {
            args: Prisma.UsuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          createMany: {
            args: Prisma.UsuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsuarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          delete: {
            args: Prisma.UsuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          update: {
            args: Prisma.UsuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UsuarioUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          upsert: {
            args: Prisma.UsuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.UsuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuarioCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
      CTG: {
        payload: Prisma.$CTGPayload<ExtArgs>
        fields: Prisma.CTGFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CTGFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CTGPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CTGFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CTGPayload>
          }
          findFirst: {
            args: Prisma.CTGFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CTGPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CTGFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CTGPayload>
          }
          findMany: {
            args: Prisma.CTGFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CTGPayload>[]
          }
          create: {
            args: Prisma.CTGCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CTGPayload>
          }
          createMany: {
            args: Prisma.CTGCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CTGCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CTGPayload>[]
          }
          delete: {
            args: Prisma.CTGDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CTGPayload>
          }
          update: {
            args: Prisma.CTGUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CTGPayload>
          }
          deleteMany: {
            args: Prisma.CTGDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CTGUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CTGUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CTGPayload>[]
          }
          upsert: {
            args: Prisma.CTGUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CTGPayload>
          }
          aggregate: {
            args: Prisma.CTGAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCTG>
          }
          groupBy: {
            args: Prisma.CTGGroupByArgs<ExtArgs>
            result: $Utils.Optional<CTGGroupByOutputType>[]
          }
          count: {
            args: Prisma.CTGCountArgs<ExtArgs>
            result: $Utils.Optional<CTGCountAggregateOutputType> | number
          }
        }
      }
      RT: {
        payload: Prisma.$RTPayload<ExtArgs>
        fields: Prisma.RTFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RTFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RTPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RTFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RTPayload>
          }
          findFirst: {
            args: Prisma.RTFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RTPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RTFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RTPayload>
          }
          findMany: {
            args: Prisma.RTFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RTPayload>[]
          }
          create: {
            args: Prisma.RTCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RTPayload>
          }
          createMany: {
            args: Prisma.RTCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RTCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RTPayload>[]
          }
          delete: {
            args: Prisma.RTDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RTPayload>
          }
          update: {
            args: Prisma.RTUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RTPayload>
          }
          deleteMany: {
            args: Prisma.RTDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RTUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RTUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RTPayload>[]
          }
          upsert: {
            args: Prisma.RTUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RTPayload>
          }
          aggregate: {
            args: Prisma.RTAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRT>
          }
          groupBy: {
            args: Prisma.RTGroupByArgs<ExtArgs>
            result: $Utils.Optional<RTGroupByOutputType>[]
          }
          count: {
            args: Prisma.RTCountArgs<ExtArgs>
            result: $Utils.Optional<RTCountAggregateOutputType> | number
          }
        }
      }
      PreferenciaSorteioDanca: {
        payload: Prisma.$PreferenciaSorteioDancaPayload<ExtArgs>
        fields: Prisma.PreferenciaSorteioDancaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PreferenciaSorteioDancaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreferenciaSorteioDancaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PreferenciaSorteioDancaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreferenciaSorteioDancaPayload>
          }
          findFirst: {
            args: Prisma.PreferenciaSorteioDancaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreferenciaSorteioDancaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PreferenciaSorteioDancaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreferenciaSorteioDancaPayload>
          }
          findMany: {
            args: Prisma.PreferenciaSorteioDancaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreferenciaSorteioDancaPayload>[]
          }
          create: {
            args: Prisma.PreferenciaSorteioDancaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreferenciaSorteioDancaPayload>
          }
          createMany: {
            args: Prisma.PreferenciaSorteioDancaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PreferenciaSorteioDancaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreferenciaSorteioDancaPayload>[]
          }
          delete: {
            args: Prisma.PreferenciaSorteioDancaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreferenciaSorteioDancaPayload>
          }
          update: {
            args: Prisma.PreferenciaSorteioDancaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreferenciaSorteioDancaPayload>
          }
          deleteMany: {
            args: Prisma.PreferenciaSorteioDancaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PreferenciaSorteioDancaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PreferenciaSorteioDancaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreferenciaSorteioDancaPayload>[]
          }
          upsert: {
            args: Prisma.PreferenciaSorteioDancaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreferenciaSorteioDancaPayload>
          }
          aggregate: {
            args: Prisma.PreferenciaSorteioDancaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePreferenciaSorteioDanca>
          }
          groupBy: {
            args: Prisma.PreferenciaSorteioDancaGroupByArgs<ExtArgs>
            result: $Utils.Optional<PreferenciaSorteioDancaGroupByOutputType>[]
          }
          count: {
            args: Prisma.PreferenciaSorteioDancaCountArgs<ExtArgs>
            result: $Utils.Optional<PreferenciaSorteioDancaCountAggregateOutputType> | number
          }
        }
      }
      Concurso: {
        payload: Prisma.$ConcursoPayload<ExtArgs>
        fields: Prisma.ConcursoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConcursoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConcursoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConcursoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConcursoPayload>
          }
          findFirst: {
            args: Prisma.ConcursoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConcursoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConcursoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConcursoPayload>
          }
          findMany: {
            args: Prisma.ConcursoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConcursoPayload>[]
          }
          create: {
            args: Prisma.ConcursoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConcursoPayload>
          }
          createMany: {
            args: Prisma.ConcursoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConcursoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConcursoPayload>[]
          }
          delete: {
            args: Prisma.ConcursoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConcursoPayload>
          }
          update: {
            args: Prisma.ConcursoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConcursoPayload>
          }
          deleteMany: {
            args: Prisma.ConcursoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConcursoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConcursoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConcursoPayload>[]
          }
          upsert: {
            args: Prisma.ConcursoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConcursoPayload>
          }
          aggregate: {
            args: Prisma.ConcursoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConcurso>
          }
          groupBy: {
            args: Prisma.ConcursoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConcursoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConcursoCountArgs<ExtArgs>
            result: $Utils.Optional<ConcursoCountAggregateOutputType> | number
          }
        }
      }
      Comissao: {
        payload: Prisma.$ComissaoPayload<ExtArgs>
        fields: Prisma.ComissaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComissaoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComissaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComissaoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComissaoPayload>
          }
          findFirst: {
            args: Prisma.ComissaoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComissaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComissaoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComissaoPayload>
          }
          findMany: {
            args: Prisma.ComissaoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComissaoPayload>[]
          }
          create: {
            args: Prisma.ComissaoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComissaoPayload>
          }
          createMany: {
            args: Prisma.ComissaoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComissaoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComissaoPayload>[]
          }
          delete: {
            args: Prisma.ComissaoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComissaoPayload>
          }
          update: {
            args: Prisma.ComissaoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComissaoPayload>
          }
          deleteMany: {
            args: Prisma.ComissaoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComissaoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ComissaoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComissaoPayload>[]
          }
          upsert: {
            args: Prisma.ComissaoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComissaoPayload>
          }
          aggregate: {
            args: Prisma.ComissaoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComissao>
          }
          groupBy: {
            args: Prisma.ComissaoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComissaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComissaoCountArgs<ExtArgs>
            result: $Utils.Optional<ComissaoCountAggregateOutputType> | number
          }
        }
      }
      ComissaoUsuario: {
        payload: Prisma.$ComissaoUsuarioPayload<ExtArgs>
        fields: Prisma.ComissaoUsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComissaoUsuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComissaoUsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComissaoUsuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComissaoUsuarioPayload>
          }
          findFirst: {
            args: Prisma.ComissaoUsuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComissaoUsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComissaoUsuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComissaoUsuarioPayload>
          }
          findMany: {
            args: Prisma.ComissaoUsuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComissaoUsuarioPayload>[]
          }
          create: {
            args: Prisma.ComissaoUsuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComissaoUsuarioPayload>
          }
          createMany: {
            args: Prisma.ComissaoUsuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComissaoUsuarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComissaoUsuarioPayload>[]
          }
          delete: {
            args: Prisma.ComissaoUsuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComissaoUsuarioPayload>
          }
          update: {
            args: Prisma.ComissaoUsuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComissaoUsuarioPayload>
          }
          deleteMany: {
            args: Prisma.ComissaoUsuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComissaoUsuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ComissaoUsuarioUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComissaoUsuarioPayload>[]
          }
          upsert: {
            args: Prisma.ComissaoUsuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComissaoUsuarioPayload>
          }
          aggregate: {
            args: Prisma.ComissaoUsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComissaoUsuario>
          }
          groupBy: {
            args: Prisma.ComissaoUsuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComissaoUsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComissaoUsuarioCountArgs<ExtArgs>
            result: $Utils.Optional<ComissaoUsuarioCountAggregateOutputType> | number
          }
        }
      }
      Categoria: {
        payload: Prisma.$CategoriaPayload<ExtArgs>
        fields: Prisma.CategoriaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoriaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoriaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>
          }
          findFirst: {
            args: Prisma.CategoriaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoriaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>
          }
          findMany: {
            args: Prisma.CategoriaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>[]
          }
          create: {
            args: Prisma.CategoriaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>
          }
          createMany: {
            args: Prisma.CategoriaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoriaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>[]
          }
          delete: {
            args: Prisma.CategoriaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>
          }
          update: {
            args: Prisma.CategoriaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>
          }
          deleteMany: {
            args: Prisma.CategoriaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoriaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoriaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>[]
          }
          upsert: {
            args: Prisma.CategoriaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>
          }
          aggregate: {
            args: Prisma.CategoriaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategoria>
          }
          groupBy: {
            args: Prisma.CategoriaGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoriaGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoriaCountArgs<ExtArgs>
            result: $Utils.Optional<CategoriaCountAggregateOutputType> | number
          }
        }
      }
      Avaliacao: {
        payload: Prisma.$AvaliacaoPayload<ExtArgs>
        fields: Prisma.AvaliacaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AvaliacaoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvaliacaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AvaliacaoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvaliacaoPayload>
          }
          findFirst: {
            args: Prisma.AvaliacaoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvaliacaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AvaliacaoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvaliacaoPayload>
          }
          findMany: {
            args: Prisma.AvaliacaoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvaliacaoPayload>[]
          }
          create: {
            args: Prisma.AvaliacaoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvaliacaoPayload>
          }
          createMany: {
            args: Prisma.AvaliacaoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AvaliacaoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvaliacaoPayload>[]
          }
          delete: {
            args: Prisma.AvaliacaoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvaliacaoPayload>
          }
          update: {
            args: Prisma.AvaliacaoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvaliacaoPayload>
          }
          deleteMany: {
            args: Prisma.AvaliacaoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AvaliacaoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AvaliacaoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvaliacaoPayload>[]
          }
          upsert: {
            args: Prisma.AvaliacaoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvaliacaoPayload>
          }
          aggregate: {
            args: Prisma.AvaliacaoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAvaliacao>
          }
          groupBy: {
            args: Prisma.AvaliacaoGroupByArgs<ExtArgs>
            result: $Utils.Optional<AvaliacaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.AvaliacaoCountArgs<ExtArgs>
            result: $Utils.Optional<AvaliacaoCountAggregateOutputType> | number
          }
        }
      }
      Prova: {
        payload: Prisma.$ProvaPayload<ExtArgs>
        fields: Prisma.ProvaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProvaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProvaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvaPayload>
          }
          findFirst: {
            args: Prisma.ProvaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProvaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvaPayload>
          }
          findMany: {
            args: Prisma.ProvaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvaPayload>[]
          }
          create: {
            args: Prisma.ProvaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvaPayload>
          }
          createMany: {
            args: Prisma.ProvaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProvaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvaPayload>[]
          }
          delete: {
            args: Prisma.ProvaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvaPayload>
          }
          update: {
            args: Prisma.ProvaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvaPayload>
          }
          deleteMany: {
            args: Prisma.ProvaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProvaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProvaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvaPayload>[]
          }
          upsert: {
            args: Prisma.ProvaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvaPayload>
          }
          aggregate: {
            args: Prisma.ProvaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProva>
          }
          groupBy: {
            args: Prisma.ProvaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProvaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProvaCountArgs<ExtArgs>
            result: $Utils.Optional<ProvaCountAggregateOutputType> | number
          }
        }
      }
      ProvaTeorica: {
        payload: Prisma.$ProvaTeoricaPayload<ExtArgs>
        fields: Prisma.ProvaTeoricaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProvaTeoricaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvaTeoricaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProvaTeoricaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvaTeoricaPayload>
          }
          findFirst: {
            args: Prisma.ProvaTeoricaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvaTeoricaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProvaTeoricaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvaTeoricaPayload>
          }
          findMany: {
            args: Prisma.ProvaTeoricaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvaTeoricaPayload>[]
          }
          create: {
            args: Prisma.ProvaTeoricaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvaTeoricaPayload>
          }
          createMany: {
            args: Prisma.ProvaTeoricaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProvaTeoricaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvaTeoricaPayload>[]
          }
          delete: {
            args: Prisma.ProvaTeoricaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvaTeoricaPayload>
          }
          update: {
            args: Prisma.ProvaTeoricaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvaTeoricaPayload>
          }
          deleteMany: {
            args: Prisma.ProvaTeoricaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProvaTeoricaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProvaTeoricaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvaTeoricaPayload>[]
          }
          upsert: {
            args: Prisma.ProvaTeoricaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvaTeoricaPayload>
          }
          aggregate: {
            args: Prisma.ProvaTeoricaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProvaTeorica>
          }
          groupBy: {
            args: Prisma.ProvaTeoricaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProvaTeoricaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProvaTeoricaCountArgs<ExtArgs>
            result: $Utils.Optional<ProvaTeoricaCountAggregateOutputType> | number
          }
        }
      }
      ProvaPratica: {
        payload: Prisma.$ProvaPraticaPayload<ExtArgs>
        fields: Prisma.ProvaPraticaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProvaPraticaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvaPraticaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProvaPraticaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvaPraticaPayload>
          }
          findFirst: {
            args: Prisma.ProvaPraticaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvaPraticaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProvaPraticaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvaPraticaPayload>
          }
          findMany: {
            args: Prisma.ProvaPraticaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvaPraticaPayload>[]
          }
          create: {
            args: Prisma.ProvaPraticaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvaPraticaPayload>
          }
          createMany: {
            args: Prisma.ProvaPraticaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProvaPraticaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvaPraticaPayload>[]
          }
          delete: {
            args: Prisma.ProvaPraticaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvaPraticaPayload>
          }
          update: {
            args: Prisma.ProvaPraticaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvaPraticaPayload>
          }
          deleteMany: {
            args: Prisma.ProvaPraticaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProvaPraticaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProvaPraticaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvaPraticaPayload>[]
          }
          upsert: {
            args: Prisma.ProvaPraticaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvaPraticaPayload>
          }
          aggregate: {
            args: Prisma.ProvaPraticaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProvaPratica>
          }
          groupBy: {
            args: Prisma.ProvaPraticaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProvaPraticaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProvaPraticaCountArgs<ExtArgs>
            result: $Utils.Optional<ProvaPraticaCountAggregateOutputType> | number
          }
        }
      }
      BlocoProva: {
        payload: Prisma.$BlocoProvaPayload<ExtArgs>
        fields: Prisma.BlocoProvaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlocoProvaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlocoProvaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlocoProvaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlocoProvaPayload>
          }
          findFirst: {
            args: Prisma.BlocoProvaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlocoProvaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlocoProvaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlocoProvaPayload>
          }
          findMany: {
            args: Prisma.BlocoProvaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlocoProvaPayload>[]
          }
          create: {
            args: Prisma.BlocoProvaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlocoProvaPayload>
          }
          createMany: {
            args: Prisma.BlocoProvaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlocoProvaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlocoProvaPayload>[]
          }
          delete: {
            args: Prisma.BlocoProvaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlocoProvaPayload>
          }
          update: {
            args: Prisma.BlocoProvaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlocoProvaPayload>
          }
          deleteMany: {
            args: Prisma.BlocoProvaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlocoProvaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlocoProvaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlocoProvaPayload>[]
          }
          upsert: {
            args: Prisma.BlocoProvaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlocoProvaPayload>
          }
          aggregate: {
            args: Prisma.BlocoProvaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlocoProva>
          }
          groupBy: {
            args: Prisma.BlocoProvaGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlocoProvaGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlocoProvaCountArgs<ExtArgs>
            result: $Utils.Optional<BlocoProvaCountAggregateOutputType> | number
          }
        }
      }
      Quesitos: {
        payload: Prisma.$QuesitosPayload<ExtArgs>
        fields: Prisma.QuesitosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuesitosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuesitosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuesitosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuesitosPayload>
          }
          findFirst: {
            args: Prisma.QuesitosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuesitosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuesitosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuesitosPayload>
          }
          findMany: {
            args: Prisma.QuesitosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuesitosPayload>[]
          }
          create: {
            args: Prisma.QuesitosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuesitosPayload>
          }
          createMany: {
            args: Prisma.QuesitosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuesitosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuesitosPayload>[]
          }
          delete: {
            args: Prisma.QuesitosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuesitosPayload>
          }
          update: {
            args: Prisma.QuesitosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuesitosPayload>
          }
          deleteMany: {
            args: Prisma.QuesitosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuesitosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuesitosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuesitosPayload>[]
          }
          upsert: {
            args: Prisma.QuesitosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuesitosPayload>
          }
          aggregate: {
            args: Prisma.QuesitosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuesitos>
          }
          groupBy: {
            args: Prisma.QuesitosGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuesitosGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuesitosCountArgs<ExtArgs>
            result: $Utils.Optional<QuesitosCountAggregateOutputType> | number
          }
        }
      }
      SubQuesitos: {
        payload: Prisma.$SubQuesitosPayload<ExtArgs>
        fields: Prisma.SubQuesitosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubQuesitosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubQuesitosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubQuesitosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubQuesitosPayload>
          }
          findFirst: {
            args: Prisma.SubQuesitosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubQuesitosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubQuesitosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubQuesitosPayload>
          }
          findMany: {
            args: Prisma.SubQuesitosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubQuesitosPayload>[]
          }
          create: {
            args: Prisma.SubQuesitosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubQuesitosPayload>
          }
          createMany: {
            args: Prisma.SubQuesitosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubQuesitosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubQuesitosPayload>[]
          }
          delete: {
            args: Prisma.SubQuesitosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubQuesitosPayload>
          }
          update: {
            args: Prisma.SubQuesitosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubQuesitosPayload>
          }
          deleteMany: {
            args: Prisma.SubQuesitosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubQuesitosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubQuesitosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubQuesitosPayload>[]
          }
          upsert: {
            args: Prisma.SubQuesitosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubQuesitosPayload>
          }
          aggregate: {
            args: Prisma.SubQuesitosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubQuesitos>
          }
          groupBy: {
            args: Prisma.SubQuesitosGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubQuesitosGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubQuesitosCountArgs<ExtArgs>
            result: $Utils.Optional<SubQuesitosCountAggregateOutputType> | number
          }
        }
      }
      Recurso: {
        payload: Prisma.$RecursoPayload<ExtArgs>
        fields: Prisma.RecursoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecursoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecursoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecursoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecursoPayload>
          }
          findFirst: {
            args: Prisma.RecursoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecursoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecursoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecursoPayload>
          }
          findMany: {
            args: Prisma.RecursoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecursoPayload>[]
          }
          create: {
            args: Prisma.RecursoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecursoPayload>
          }
          createMany: {
            args: Prisma.RecursoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecursoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecursoPayload>[]
          }
          delete: {
            args: Prisma.RecursoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecursoPayload>
          }
          update: {
            args: Prisma.RecursoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecursoPayload>
          }
          deleteMany: {
            args: Prisma.RecursoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecursoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RecursoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecursoPayload>[]
          }
          upsert: {
            args: Prisma.RecursoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecursoPayload>
          }
          aggregate: {
            args: Prisma.RecursoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecurso>
          }
          groupBy: {
            args: Prisma.RecursoGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecursoGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecursoCountArgs<ExtArgs>
            result: $Utils.Optional<RecursoCountAggregateOutputType> | number
          }
        }
      }
      SorteioDanca: {
        payload: Prisma.$SorteioDancaPayload<ExtArgs>
        fields: Prisma.SorteioDancaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SorteioDancaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SorteioDancaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SorteioDancaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SorteioDancaPayload>
          }
          findFirst: {
            args: Prisma.SorteioDancaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SorteioDancaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SorteioDancaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SorteioDancaPayload>
          }
          findMany: {
            args: Prisma.SorteioDancaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SorteioDancaPayload>[]
          }
          create: {
            args: Prisma.SorteioDancaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SorteioDancaPayload>
          }
          createMany: {
            args: Prisma.SorteioDancaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SorteioDancaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SorteioDancaPayload>[]
          }
          delete: {
            args: Prisma.SorteioDancaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SorteioDancaPayload>
          }
          update: {
            args: Prisma.SorteioDancaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SorteioDancaPayload>
          }
          deleteMany: {
            args: Prisma.SorteioDancaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SorteioDancaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SorteioDancaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SorteioDancaPayload>[]
          }
          upsert: {
            args: Prisma.SorteioDancaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SorteioDancaPayload>
          }
          aggregate: {
            args: Prisma.SorteioDancaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSorteioDanca>
          }
          groupBy: {
            args: Prisma.SorteioDancaGroupByArgs<ExtArgs>
            result: $Utils.Optional<SorteioDancaGroupByOutputType>[]
          }
          count: {
            args: Prisma.SorteioDancaCountArgs<ExtArgs>
            result: $Utils.Optional<SorteioDancaCountAggregateOutputType> | number
          }
        }
      }
      FichaCandidato: {
        payload: Prisma.$FichaCandidatoPayload<ExtArgs>
        fields: Prisma.FichaCandidatoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FichaCandidatoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FichaCandidatoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FichaCandidatoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FichaCandidatoPayload>
          }
          findFirst: {
            args: Prisma.FichaCandidatoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FichaCandidatoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FichaCandidatoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FichaCandidatoPayload>
          }
          findMany: {
            args: Prisma.FichaCandidatoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FichaCandidatoPayload>[]
          }
          create: {
            args: Prisma.FichaCandidatoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FichaCandidatoPayload>
          }
          createMany: {
            args: Prisma.FichaCandidatoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FichaCandidatoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FichaCandidatoPayload>[]
          }
          delete: {
            args: Prisma.FichaCandidatoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FichaCandidatoPayload>
          }
          update: {
            args: Prisma.FichaCandidatoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FichaCandidatoPayload>
          }
          deleteMany: {
            args: Prisma.FichaCandidatoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FichaCandidatoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FichaCandidatoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FichaCandidatoPayload>[]
          }
          upsert: {
            args: Prisma.FichaCandidatoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FichaCandidatoPayload>
          }
          aggregate: {
            args: Prisma.FichaCandidatoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFichaCandidato>
          }
          groupBy: {
            args: Prisma.FichaCandidatoGroupByArgs<ExtArgs>
            result: $Utils.Optional<FichaCandidatoGroupByOutputType>[]
          }
          count: {
            args: Prisma.FichaCandidatoCountArgs<ExtArgs>
            result: $Utils.Optional<FichaCandidatoCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    candidato?: CandidatoOmit
    usuario?: UsuarioOmit
    cTG?: CTGOmit
    rT?: RTOmit
    preferenciaSorteioDanca?: PreferenciaSorteioDancaOmit
    concurso?: ConcursoOmit
    comissao?: ComissaoOmit
    comissaoUsuario?: ComissaoUsuarioOmit
    categoria?: CategoriaOmit
    avaliacao?: AvaliacaoOmit
    prova?: ProvaOmit
    provaTeorica?: ProvaTeoricaOmit
    provaPratica?: ProvaPraticaOmit
    blocoProva?: BlocoProvaOmit
    quesitos?: QuesitosOmit
    subQuesitos?: SubQuesitosOmit
    recurso?: RecursoOmit
    sorteioDanca?: SorteioDancaOmit
    fichaCandidato?: FichaCandidatoOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CandidatoCountOutputType
   */

  export type CandidatoCountOutputType = {
    PreferenciaSorteioDanca: number
    avalicoes: number
    sorteioDanca: number
    Recurso: number
  }

  export type CandidatoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PreferenciaSorteioDanca?: boolean | CandidatoCountOutputTypeCountPreferenciaSorteioDancaArgs
    avalicoes?: boolean | CandidatoCountOutputTypeCountAvalicoesArgs
    sorteioDanca?: boolean | CandidatoCountOutputTypeCountSorteioDancaArgs
    Recurso?: boolean | CandidatoCountOutputTypeCountRecursoArgs
  }

  // Custom InputTypes
  /**
   * CandidatoCountOutputType without action
   */
  export type CandidatoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CandidatoCountOutputType
     */
    select?: CandidatoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CandidatoCountOutputType without action
   */
  export type CandidatoCountOutputTypeCountPreferenciaSorteioDancaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PreferenciaSorteioDancaWhereInput
  }

  /**
   * CandidatoCountOutputType without action
   */
  export type CandidatoCountOutputTypeCountAvalicoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvaliacaoWhereInput
  }

  /**
   * CandidatoCountOutputType without action
   */
  export type CandidatoCountOutputTypeCountSorteioDancaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SorteioDancaWhereInput
  }

  /**
   * CandidatoCountOutputType without action
   */
  export type CandidatoCountOutputTypeCountRecursoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecursoWhereInput
  }


  /**
   * Count Type UsuarioCountOutputType
   */

  export type UsuarioCountOutputType = {
    avalicoes: number
    recursos: number
    sorteioDanca: number
  }

  export type UsuarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    avalicoes?: boolean | UsuarioCountOutputTypeCountAvalicoesArgs
    recursos?: boolean | UsuarioCountOutputTypeCountRecursosArgs
    sorteioDanca?: boolean | UsuarioCountOutputTypeCountSorteioDancaArgs
  }

  // Custom InputTypes
  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     */
    select?: UsuarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountAvalicoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvaliacaoWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountRecursosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecursoWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountSorteioDancaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SorteioDancaWhereInput
  }


  /**
   * Count Type CTGCountOutputType
   */

  export type CTGCountOutputType = {
    Usuario: number
    Candidato: number
  }

  export type CTGCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuario?: boolean | CTGCountOutputTypeCountUsuarioArgs
    Candidato?: boolean | CTGCountOutputTypeCountCandidatoArgs
  }

  // Custom InputTypes
  /**
   * CTGCountOutputType without action
   */
  export type CTGCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CTGCountOutputType
     */
    select?: CTGCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CTGCountOutputType without action
   */
  export type CTGCountOutputTypeCountUsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
  }

  /**
   * CTGCountOutputType without action
   */
  export type CTGCountOutputTypeCountCandidatoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CandidatoWhereInput
  }


  /**
   * Count Type RTCountOutputType
   */

  export type RTCountOutputType = {
    CTGs: number
  }

  export type RTCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CTGs?: boolean | RTCountOutputTypeCountCTGsArgs
  }

  // Custom InputTypes
  /**
   * RTCountOutputType without action
   */
  export type RTCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RTCountOutputType
     */
    select?: RTCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RTCountOutputType without action
   */
  export type RTCountOutputTypeCountCTGsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CTGWhereInput
  }


  /**
   * Count Type PreferenciaSorteioDancaCountOutputType
   */

  export type PreferenciaSorteioDancaCountOutputType = {
    quesitos: number
  }

  export type PreferenciaSorteioDancaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quesitos?: boolean | PreferenciaSorteioDancaCountOutputTypeCountQuesitosArgs
  }

  // Custom InputTypes
  /**
   * PreferenciaSorteioDancaCountOutputType without action
   */
  export type PreferenciaSorteioDancaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferenciaSorteioDancaCountOutputType
     */
    select?: PreferenciaSorteioDancaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PreferenciaSorteioDancaCountOutputType without action
   */
  export type PreferenciaSorteioDancaCountOutputTypeCountQuesitosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuesitosWhereInput
  }


  /**
   * Count Type ConcursoCountOutputType
   */

  export type ConcursoCountOutputType = {
    candidatos: number
    comissoes: number
  }

  export type ConcursoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    candidatos?: boolean | ConcursoCountOutputTypeCountCandidatosArgs
    comissoes?: boolean | ConcursoCountOutputTypeCountComissoesArgs
  }

  // Custom InputTypes
  /**
   * ConcursoCountOutputType without action
   */
  export type ConcursoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConcursoCountOutputType
     */
    select?: ConcursoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConcursoCountOutputType without action
   */
  export type ConcursoCountOutputTypeCountCandidatosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CandidatoWhereInput
  }

  /**
   * ConcursoCountOutputType without action
   */
  export type ConcursoCountOutputTypeCountComissoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComissaoWhereInput
  }


  /**
   * Count Type ComissaoCountOutputType
   */

  export type ComissaoCountOutputType = {
    avalicao: number
    usuarios: number
  }

  export type ComissaoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    avalicao?: boolean | ComissaoCountOutputTypeCountAvalicaoArgs
    usuarios?: boolean | ComissaoCountOutputTypeCountUsuariosArgs
  }

  // Custom InputTypes
  /**
   * ComissaoCountOutputType without action
   */
  export type ComissaoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComissaoCountOutputType
     */
    select?: ComissaoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ComissaoCountOutputType without action
   */
  export type ComissaoCountOutputTypeCountAvalicaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvaliacaoWhereInput
  }

  /**
   * ComissaoCountOutputType without action
   */
  export type ComissaoCountOutputTypeCountUsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComissaoUsuarioWhereInput
  }


  /**
   * Count Type CategoriaCountOutputType
   */

  export type CategoriaCountOutputType = {
    candidatos: number
  }

  export type CategoriaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    candidatos?: boolean | CategoriaCountOutputTypeCountCandidatosArgs
  }

  // Custom InputTypes
  /**
   * CategoriaCountOutputType without action
   */
  export type CategoriaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriaCountOutputType
     */
    select?: CategoriaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoriaCountOutputType without action
   */
  export type CategoriaCountOutputTypeCountCandidatosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CandidatoWhereInput
  }


  /**
   * Count Type AvaliacaoCountOutputType
   */

  export type AvaliacaoCountOutputType = {
    quesitos: number
  }

  export type AvaliacaoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quesitos?: boolean | AvaliacaoCountOutputTypeCountQuesitosArgs
  }

  // Custom InputTypes
  /**
   * AvaliacaoCountOutputType without action
   */
  export type AvaliacaoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvaliacaoCountOutputType
     */
    select?: AvaliacaoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AvaliacaoCountOutputType without action
   */
  export type AvaliacaoCountOutputTypeCountQuesitosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuesitosWhereInput
  }


  /**
   * Count Type ProvaCountOutputType
   */

  export type ProvaCountOutputType = {
    categorias: number
    ProvaTeorica: number
    ProvaPratica: number
    recursos: number
    Avaliacao: number
  }

  export type ProvaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categorias?: boolean | ProvaCountOutputTypeCountCategoriasArgs
    ProvaTeorica?: boolean | ProvaCountOutputTypeCountProvaTeoricaArgs
    ProvaPratica?: boolean | ProvaCountOutputTypeCountProvaPraticaArgs
    recursos?: boolean | ProvaCountOutputTypeCountRecursosArgs
    Avaliacao?: boolean | ProvaCountOutputTypeCountAvaliacaoArgs
  }

  // Custom InputTypes
  /**
   * ProvaCountOutputType without action
   */
  export type ProvaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvaCountOutputType
     */
    select?: ProvaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProvaCountOutputType without action
   */
  export type ProvaCountOutputTypeCountCategoriasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoriaWhereInput
  }

  /**
   * ProvaCountOutputType without action
   */
  export type ProvaCountOutputTypeCountProvaTeoricaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProvaTeoricaWhereInput
  }

  /**
   * ProvaCountOutputType without action
   */
  export type ProvaCountOutputTypeCountProvaPraticaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProvaPraticaWhereInput
  }

  /**
   * ProvaCountOutputType without action
   */
  export type ProvaCountOutputTypeCountRecursosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecursoWhereInput
  }

  /**
   * ProvaCountOutputType without action
   */
  export type ProvaCountOutputTypeCountAvaliacaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvaliacaoWhereInput
  }


  /**
   * Count Type ProvaTeoricaCountOutputType
   */

  export type ProvaTeoricaCountOutputType = {
    quesitos: number
    Categoria: number
    Recurso: number
  }

  export type ProvaTeoricaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quesitos?: boolean | ProvaTeoricaCountOutputTypeCountQuesitosArgs
    Categoria?: boolean | ProvaTeoricaCountOutputTypeCountCategoriaArgs
    Recurso?: boolean | ProvaTeoricaCountOutputTypeCountRecursoArgs
  }

  // Custom InputTypes
  /**
   * ProvaTeoricaCountOutputType without action
   */
  export type ProvaTeoricaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvaTeoricaCountOutputType
     */
    select?: ProvaTeoricaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProvaTeoricaCountOutputType without action
   */
  export type ProvaTeoricaCountOutputTypeCountQuesitosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuesitosWhereInput
  }

  /**
   * ProvaTeoricaCountOutputType without action
   */
  export type ProvaTeoricaCountOutputTypeCountCategoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoriaWhereInput
  }

  /**
   * ProvaTeoricaCountOutputType without action
   */
  export type ProvaTeoricaCountOutputTypeCountRecursoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecursoWhereInput
  }


  /**
   * Count Type ProvaPraticaCountOutputType
   */

  export type ProvaPraticaCountOutputType = {
    blocosProvas: number
    Categoria: number
    Recurso: number
  }

  export type ProvaPraticaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blocosProvas?: boolean | ProvaPraticaCountOutputTypeCountBlocosProvasArgs
    Categoria?: boolean | ProvaPraticaCountOutputTypeCountCategoriaArgs
    Recurso?: boolean | ProvaPraticaCountOutputTypeCountRecursoArgs
  }

  // Custom InputTypes
  /**
   * ProvaPraticaCountOutputType without action
   */
  export type ProvaPraticaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvaPraticaCountOutputType
     */
    select?: ProvaPraticaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProvaPraticaCountOutputType without action
   */
  export type ProvaPraticaCountOutputTypeCountBlocosProvasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlocoProvaWhereInput
  }

  /**
   * ProvaPraticaCountOutputType without action
   */
  export type ProvaPraticaCountOutputTypeCountCategoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoriaWhereInput
  }

  /**
   * ProvaPraticaCountOutputType without action
   */
  export type ProvaPraticaCountOutputTypeCountRecursoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecursoWhereInput
  }


  /**
   * Count Type BlocoProvaCountOutputType
   */

  export type BlocoProvaCountOutputType = {
    quesitos: number
    Avaliacao: number
  }

  export type BlocoProvaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quesitos?: boolean | BlocoProvaCountOutputTypeCountQuesitosArgs
    Avaliacao?: boolean | BlocoProvaCountOutputTypeCountAvaliacaoArgs
  }

  // Custom InputTypes
  /**
   * BlocoProvaCountOutputType without action
   */
  export type BlocoProvaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlocoProvaCountOutputType
     */
    select?: BlocoProvaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BlocoProvaCountOutputType without action
   */
  export type BlocoProvaCountOutputTypeCountQuesitosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuesitosWhereInput
  }

  /**
   * BlocoProvaCountOutputType without action
   */
  export type BlocoProvaCountOutputTypeCountAvaliacaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvaliacaoWhereInput
  }


  /**
   * Count Type QuesitosCountOutputType
   */

  export type QuesitosCountOutputType = {
    subeQuesitos: number
    recursos: number
  }

  export type QuesitosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subeQuesitos?: boolean | QuesitosCountOutputTypeCountSubeQuesitosArgs
    recursos?: boolean | QuesitosCountOutputTypeCountRecursosArgs
  }

  // Custom InputTypes
  /**
   * QuesitosCountOutputType without action
   */
  export type QuesitosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuesitosCountOutputType
     */
    select?: QuesitosCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuesitosCountOutputType without action
   */
  export type QuesitosCountOutputTypeCountSubeQuesitosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubQuesitosWhereInput
  }

  /**
   * QuesitosCountOutputType without action
   */
  export type QuesitosCountOutputTypeCountRecursosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecursoWhereInput
  }


  /**
   * Count Type SubQuesitosCountOutputType
   */

  export type SubQuesitosCountOutputType = {
    subequesitosFilhos: number
    subequesitosPai: number
  }

  export type SubQuesitosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subequesitosFilhos?: boolean | SubQuesitosCountOutputTypeCountSubequesitosFilhosArgs
    subequesitosPai?: boolean | SubQuesitosCountOutputTypeCountSubequesitosPaiArgs
  }

  // Custom InputTypes
  /**
   * SubQuesitosCountOutputType without action
   */
  export type SubQuesitosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubQuesitosCountOutputType
     */
    select?: SubQuesitosCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubQuesitosCountOutputType without action
   */
  export type SubQuesitosCountOutputTypeCountSubequesitosFilhosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubQuesitosWhereInput
  }

  /**
   * SubQuesitosCountOutputType without action
   */
  export type SubQuesitosCountOutputTypeCountSubequesitosPaiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubQuesitosWhereInput
  }


  /**
   * Count Type SorteioDancaCountOutputType
   */

  export type SorteioDancaCountOutputType = {
    preferenciaSorteioDancaIds: number
  }

  export type SorteioDancaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    preferenciaSorteioDancaIds?: boolean | SorteioDancaCountOutputTypeCountPreferenciaSorteioDancaIdsArgs
  }

  // Custom InputTypes
  /**
   * SorteioDancaCountOutputType without action
   */
  export type SorteioDancaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SorteioDancaCountOutputType
     */
    select?: SorteioDancaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SorteioDancaCountOutputType without action
   */
  export type SorteioDancaCountOutputTypeCountPreferenciaSorteioDancaIdsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PreferenciaSorteioDancaWhereInput
  }


  /**
   * Count Type FichaCandidatoCountOutputType
   */

  export type FichaCandidatoCountOutputType = {
    avaliacoes: number
  }

  export type FichaCandidatoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    avaliacoes?: boolean | FichaCandidatoCountOutputTypeCountAvaliacoesArgs
  }

  // Custom InputTypes
  /**
   * FichaCandidatoCountOutputType without action
   */
  export type FichaCandidatoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FichaCandidatoCountOutputType
     */
    select?: FichaCandidatoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FichaCandidatoCountOutputType without action
   */
  export type FichaCandidatoCountOutputTypeCountAvaliacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvaliacaoWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Candidato
   */

  export type AggregateCandidato = {
    _count: CandidatoCountAggregateOutputType | null
    _avg: CandidatoAvgAggregateOutputType | null
    _sum: CandidatoSumAggregateOutputType | null
    _min: CandidatoMinAggregateOutputType | null
    _max: CandidatoMaxAggregateOutputType | null
  }

  export type CandidatoAvgAggregateOutputType = {
    idCandidato: number | null
    CTGId: number | null
    numEndereco: number | null
    categoriaId: number | null
    concursoIdConcurso: number | null
  }

  export type CandidatoSumAggregateOutputType = {
    idCandidato: number | null
    CTGId: number | null
    numEndereco: number | null
    categoriaId: number | null
    concursoIdConcurso: number | null
  }

  export type CandidatoMinAggregateOutputType = {
    idCandidato: number | null
    nomeCompleto: string | null
    cidade: string | null
    estado: string | null
    CTGId: number | null
    numCarteirinha: string | null
    CPF: string | null
    RG: string | null
    endereco: string | null
    numEndereco: number | null
    bairro: string | null
    escolaridade: string | null
    filiacao: string | null
    ProvaCampeiraEsportiva: $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento: Bytes | null
    anexoCarteirinha: Bytes | null
    anexoEscolaridade: Bytes | null
    anexoResidencia: Bytes | null
    anexoAtaConcurso: Bytes | null
    fichaInscricao: Bytes | null
    anexoTermoCandidato: Bytes | null
    anexoRelatorioVivencia: Bytes | null
    anexoResponsavel: Bytes | null
    anexoProvaEsportivaCampeira: Bytes | null
    categoriaId: number | null
    concursoIdConcurso: number | null
  }

  export type CandidatoMaxAggregateOutputType = {
    idCandidato: number | null
    nomeCompleto: string | null
    cidade: string | null
    estado: string | null
    CTGId: number | null
    numCarteirinha: string | null
    CPF: string | null
    RG: string | null
    endereco: string | null
    numEndereco: number | null
    bairro: string | null
    escolaridade: string | null
    filiacao: string | null
    ProvaCampeiraEsportiva: $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento: Bytes | null
    anexoCarteirinha: Bytes | null
    anexoEscolaridade: Bytes | null
    anexoResidencia: Bytes | null
    anexoAtaConcurso: Bytes | null
    fichaInscricao: Bytes | null
    anexoTermoCandidato: Bytes | null
    anexoRelatorioVivencia: Bytes | null
    anexoResponsavel: Bytes | null
    anexoProvaEsportivaCampeira: Bytes | null
    categoriaId: number | null
    concursoIdConcurso: number | null
  }

  export type CandidatoCountAggregateOutputType = {
    idCandidato: number
    nomeCompleto: number
    cidade: number
    estado: number
    CTGId: number
    numCarteirinha: number
    CPF: number
    RG: number
    endereco: number
    numEndereco: number
    bairro: number
    escolaridade: number
    filiacao: number
    ProvaCampeiraEsportiva: number
    anexoDocumento: number
    anexoCarteirinha: number
    anexoEscolaridade: number
    anexoResidencia: number
    anexoAtaConcurso: number
    fichaInscricao: number
    anexoTermoCandidato: number
    anexoRelatorioVivencia: number
    anexoResponsavel: number
    anexoProvaEsportivaCampeira: number
    categoriaId: number
    concursoIdConcurso: number
    _all: number
  }


  export type CandidatoAvgAggregateInputType = {
    idCandidato?: true
    CTGId?: true
    numEndereco?: true
    categoriaId?: true
    concursoIdConcurso?: true
  }

  export type CandidatoSumAggregateInputType = {
    idCandidato?: true
    CTGId?: true
    numEndereco?: true
    categoriaId?: true
    concursoIdConcurso?: true
  }

  export type CandidatoMinAggregateInputType = {
    idCandidato?: true
    nomeCompleto?: true
    cidade?: true
    estado?: true
    CTGId?: true
    numCarteirinha?: true
    CPF?: true
    RG?: true
    endereco?: true
    numEndereco?: true
    bairro?: true
    escolaridade?: true
    filiacao?: true
    ProvaCampeiraEsportiva?: true
    anexoDocumento?: true
    anexoCarteirinha?: true
    anexoEscolaridade?: true
    anexoResidencia?: true
    anexoAtaConcurso?: true
    fichaInscricao?: true
    anexoTermoCandidato?: true
    anexoRelatorioVivencia?: true
    anexoResponsavel?: true
    anexoProvaEsportivaCampeira?: true
    categoriaId?: true
    concursoIdConcurso?: true
  }

  export type CandidatoMaxAggregateInputType = {
    idCandidato?: true
    nomeCompleto?: true
    cidade?: true
    estado?: true
    CTGId?: true
    numCarteirinha?: true
    CPF?: true
    RG?: true
    endereco?: true
    numEndereco?: true
    bairro?: true
    escolaridade?: true
    filiacao?: true
    ProvaCampeiraEsportiva?: true
    anexoDocumento?: true
    anexoCarteirinha?: true
    anexoEscolaridade?: true
    anexoResidencia?: true
    anexoAtaConcurso?: true
    fichaInscricao?: true
    anexoTermoCandidato?: true
    anexoRelatorioVivencia?: true
    anexoResponsavel?: true
    anexoProvaEsportivaCampeira?: true
    categoriaId?: true
    concursoIdConcurso?: true
  }

  export type CandidatoCountAggregateInputType = {
    idCandidato?: true
    nomeCompleto?: true
    cidade?: true
    estado?: true
    CTGId?: true
    numCarteirinha?: true
    CPF?: true
    RG?: true
    endereco?: true
    numEndereco?: true
    bairro?: true
    escolaridade?: true
    filiacao?: true
    ProvaCampeiraEsportiva?: true
    anexoDocumento?: true
    anexoCarteirinha?: true
    anexoEscolaridade?: true
    anexoResidencia?: true
    anexoAtaConcurso?: true
    fichaInscricao?: true
    anexoTermoCandidato?: true
    anexoRelatorioVivencia?: true
    anexoResponsavel?: true
    anexoProvaEsportivaCampeira?: true
    categoriaId?: true
    concursoIdConcurso?: true
    _all?: true
  }

  export type CandidatoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Candidato to aggregate.
     */
    where?: CandidatoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Candidatoes to fetch.
     */
    orderBy?: CandidatoOrderByWithRelationInput | CandidatoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CandidatoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Candidatoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Candidatoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Candidatoes
    **/
    _count?: true | CandidatoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CandidatoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CandidatoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CandidatoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CandidatoMaxAggregateInputType
  }

  export type GetCandidatoAggregateType<T extends CandidatoAggregateArgs> = {
        [P in keyof T & keyof AggregateCandidato]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCandidato[P]>
      : GetScalarType<T[P], AggregateCandidato[P]>
  }




  export type CandidatoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CandidatoWhereInput
    orderBy?: CandidatoOrderByWithAggregationInput | CandidatoOrderByWithAggregationInput[]
    by: CandidatoScalarFieldEnum[] | CandidatoScalarFieldEnum
    having?: CandidatoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CandidatoCountAggregateInputType | true
    _avg?: CandidatoAvgAggregateInputType
    _sum?: CandidatoSumAggregateInputType
    _min?: CandidatoMinAggregateInputType
    _max?: CandidatoMaxAggregateInputType
  }

  export type CandidatoGroupByOutputType = {
    idCandidato: number
    nomeCompleto: string
    cidade: string
    estado: string
    CTGId: number
    numCarteirinha: string
    CPF: string
    RG: string
    endereco: string
    numEndereco: number
    bairro: string
    escolaridade: string
    filiacao: string
    ProvaCampeiraEsportiva: $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento: Bytes | null
    anexoCarteirinha: Bytes | null
    anexoEscolaridade: Bytes | null
    anexoResidencia: Bytes | null
    anexoAtaConcurso: Bytes | null
    fichaInscricao: Bytes | null
    anexoTermoCandidato: Bytes | null
    anexoRelatorioVivencia: Bytes | null
    anexoResponsavel: Bytes | null
    anexoProvaEsportivaCampeira: Bytes | null
    categoriaId: number
    concursoIdConcurso: number | null
    _count: CandidatoCountAggregateOutputType | null
    _avg: CandidatoAvgAggregateOutputType | null
    _sum: CandidatoSumAggregateOutputType | null
    _min: CandidatoMinAggregateOutputType | null
    _max: CandidatoMaxAggregateOutputType | null
  }

  type GetCandidatoGroupByPayload<T extends CandidatoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CandidatoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CandidatoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CandidatoGroupByOutputType[P]>
            : GetScalarType<T[P], CandidatoGroupByOutputType[P]>
        }
      >
    >


  export type CandidatoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idCandidato?: boolean
    nomeCompleto?: boolean
    cidade?: boolean
    estado?: boolean
    CTGId?: boolean
    numCarteirinha?: boolean
    CPF?: boolean
    RG?: boolean
    endereco?: boolean
    numEndereco?: boolean
    bairro?: boolean
    escolaridade?: boolean
    filiacao?: boolean
    ProvaCampeiraEsportiva?: boolean
    anexoDocumento?: boolean
    anexoCarteirinha?: boolean
    anexoEscolaridade?: boolean
    anexoResidencia?: boolean
    anexoAtaConcurso?: boolean
    fichaInscricao?: boolean
    anexoTermoCandidato?: boolean
    anexoRelatorioVivencia?: boolean
    anexoResponsavel?: boolean
    anexoProvaEsportivaCampeira?: boolean
    categoriaId?: boolean
    concursoIdConcurso?: boolean
    CTG?: boolean | CTGDefaultArgs<ExtArgs>
    PreferenciaSorteioDanca?: boolean | Candidato$PreferenciaSorteioDancaArgs<ExtArgs>
    Categoria?: boolean | CategoriaDefaultArgs<ExtArgs>
    avalicoes?: boolean | Candidato$avalicoesArgs<ExtArgs>
    sorteioDanca?: boolean | Candidato$sorteioDancaArgs<ExtArgs>
    Recurso?: boolean | Candidato$RecursoArgs<ExtArgs>
    Concurso?: boolean | Candidato$ConcursoArgs<ExtArgs>
    _count?: boolean | CandidatoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["candidato"]>

  export type CandidatoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idCandidato?: boolean
    nomeCompleto?: boolean
    cidade?: boolean
    estado?: boolean
    CTGId?: boolean
    numCarteirinha?: boolean
    CPF?: boolean
    RG?: boolean
    endereco?: boolean
    numEndereco?: boolean
    bairro?: boolean
    escolaridade?: boolean
    filiacao?: boolean
    ProvaCampeiraEsportiva?: boolean
    anexoDocumento?: boolean
    anexoCarteirinha?: boolean
    anexoEscolaridade?: boolean
    anexoResidencia?: boolean
    anexoAtaConcurso?: boolean
    fichaInscricao?: boolean
    anexoTermoCandidato?: boolean
    anexoRelatorioVivencia?: boolean
    anexoResponsavel?: boolean
    anexoProvaEsportivaCampeira?: boolean
    categoriaId?: boolean
    concursoIdConcurso?: boolean
    CTG?: boolean | CTGDefaultArgs<ExtArgs>
    Categoria?: boolean | CategoriaDefaultArgs<ExtArgs>
    Concurso?: boolean | Candidato$ConcursoArgs<ExtArgs>
  }, ExtArgs["result"]["candidato"]>

  export type CandidatoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idCandidato?: boolean
    nomeCompleto?: boolean
    cidade?: boolean
    estado?: boolean
    CTGId?: boolean
    numCarteirinha?: boolean
    CPF?: boolean
    RG?: boolean
    endereco?: boolean
    numEndereco?: boolean
    bairro?: boolean
    escolaridade?: boolean
    filiacao?: boolean
    ProvaCampeiraEsportiva?: boolean
    anexoDocumento?: boolean
    anexoCarteirinha?: boolean
    anexoEscolaridade?: boolean
    anexoResidencia?: boolean
    anexoAtaConcurso?: boolean
    fichaInscricao?: boolean
    anexoTermoCandidato?: boolean
    anexoRelatorioVivencia?: boolean
    anexoResponsavel?: boolean
    anexoProvaEsportivaCampeira?: boolean
    categoriaId?: boolean
    concursoIdConcurso?: boolean
    CTG?: boolean | CTGDefaultArgs<ExtArgs>
    Categoria?: boolean | CategoriaDefaultArgs<ExtArgs>
    Concurso?: boolean | Candidato$ConcursoArgs<ExtArgs>
  }, ExtArgs["result"]["candidato"]>

  export type CandidatoSelectScalar = {
    idCandidato?: boolean
    nomeCompleto?: boolean
    cidade?: boolean
    estado?: boolean
    CTGId?: boolean
    numCarteirinha?: boolean
    CPF?: boolean
    RG?: boolean
    endereco?: boolean
    numEndereco?: boolean
    bairro?: boolean
    escolaridade?: boolean
    filiacao?: boolean
    ProvaCampeiraEsportiva?: boolean
    anexoDocumento?: boolean
    anexoCarteirinha?: boolean
    anexoEscolaridade?: boolean
    anexoResidencia?: boolean
    anexoAtaConcurso?: boolean
    fichaInscricao?: boolean
    anexoTermoCandidato?: boolean
    anexoRelatorioVivencia?: boolean
    anexoResponsavel?: boolean
    anexoProvaEsportivaCampeira?: boolean
    categoriaId?: boolean
    concursoIdConcurso?: boolean
  }

  export type CandidatoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idCandidato" | "nomeCompleto" | "cidade" | "estado" | "CTGId" | "numCarteirinha" | "CPF" | "RG" | "endereco" | "numEndereco" | "bairro" | "escolaridade" | "filiacao" | "ProvaCampeiraEsportiva" | "anexoDocumento" | "anexoCarteirinha" | "anexoEscolaridade" | "anexoResidencia" | "anexoAtaConcurso" | "fichaInscricao" | "anexoTermoCandidato" | "anexoRelatorioVivencia" | "anexoResponsavel" | "anexoProvaEsportivaCampeira" | "categoriaId" | "concursoIdConcurso", ExtArgs["result"]["candidato"]>
  export type CandidatoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CTG?: boolean | CTGDefaultArgs<ExtArgs>
    PreferenciaSorteioDanca?: boolean | Candidato$PreferenciaSorteioDancaArgs<ExtArgs>
    Categoria?: boolean | CategoriaDefaultArgs<ExtArgs>
    avalicoes?: boolean | Candidato$avalicoesArgs<ExtArgs>
    sorteioDanca?: boolean | Candidato$sorteioDancaArgs<ExtArgs>
    Recurso?: boolean | Candidato$RecursoArgs<ExtArgs>
    Concurso?: boolean | Candidato$ConcursoArgs<ExtArgs>
    _count?: boolean | CandidatoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CandidatoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CTG?: boolean | CTGDefaultArgs<ExtArgs>
    Categoria?: boolean | CategoriaDefaultArgs<ExtArgs>
    Concurso?: boolean | Candidato$ConcursoArgs<ExtArgs>
  }
  export type CandidatoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CTG?: boolean | CTGDefaultArgs<ExtArgs>
    Categoria?: boolean | CategoriaDefaultArgs<ExtArgs>
    Concurso?: boolean | Candidato$ConcursoArgs<ExtArgs>
  }

  export type $CandidatoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Candidato"
    objects: {
      CTG: Prisma.$CTGPayload<ExtArgs>
      PreferenciaSorteioDanca: Prisma.$PreferenciaSorteioDancaPayload<ExtArgs>[]
      Categoria: Prisma.$CategoriaPayload<ExtArgs>
      avalicoes: Prisma.$AvaliacaoPayload<ExtArgs>[]
      sorteioDanca: Prisma.$SorteioDancaPayload<ExtArgs>[]
      Recurso: Prisma.$RecursoPayload<ExtArgs>[]
      Concurso: Prisma.$ConcursoPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      idCandidato: number
      nomeCompleto: string
      cidade: string
      estado: string
      CTGId: number
      numCarteirinha: string
      CPF: string
      RG: string
      endereco: string
      numEndereco: number
      bairro: string
      escolaridade: string
      filiacao: string
      ProvaCampeiraEsportiva: $Enums.ProvaCampeiraEsportiva | null
      anexoDocumento: Prisma.Bytes | null
      anexoCarteirinha: Prisma.Bytes | null
      anexoEscolaridade: Prisma.Bytes | null
      anexoResidencia: Prisma.Bytes | null
      anexoAtaConcurso: Prisma.Bytes | null
      fichaInscricao: Prisma.Bytes | null
      anexoTermoCandidato: Prisma.Bytes | null
      anexoRelatorioVivencia: Prisma.Bytes | null
      anexoResponsavel: Prisma.Bytes | null
      anexoProvaEsportivaCampeira: Prisma.Bytes | null
      categoriaId: number
      concursoIdConcurso: number | null
    }, ExtArgs["result"]["candidato"]>
    composites: {}
  }

  type CandidatoGetPayload<S extends boolean | null | undefined | CandidatoDefaultArgs> = $Result.GetResult<Prisma.$CandidatoPayload, S>

  type CandidatoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CandidatoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CandidatoCountAggregateInputType | true
    }

  export interface CandidatoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Candidato'], meta: { name: 'Candidato' } }
    /**
     * Find zero or one Candidato that matches the filter.
     * @param {CandidatoFindUniqueArgs} args - Arguments to find a Candidato
     * @example
     * // Get one Candidato
     * const candidato = await prisma.candidato.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CandidatoFindUniqueArgs>(args: SelectSubset<T, CandidatoFindUniqueArgs<ExtArgs>>): Prisma__CandidatoClient<$Result.GetResult<Prisma.$CandidatoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Candidato that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CandidatoFindUniqueOrThrowArgs} args - Arguments to find a Candidato
     * @example
     * // Get one Candidato
     * const candidato = await prisma.candidato.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CandidatoFindUniqueOrThrowArgs>(args: SelectSubset<T, CandidatoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CandidatoClient<$Result.GetResult<Prisma.$CandidatoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Candidato that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidatoFindFirstArgs} args - Arguments to find a Candidato
     * @example
     * // Get one Candidato
     * const candidato = await prisma.candidato.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CandidatoFindFirstArgs>(args?: SelectSubset<T, CandidatoFindFirstArgs<ExtArgs>>): Prisma__CandidatoClient<$Result.GetResult<Prisma.$CandidatoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Candidato that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidatoFindFirstOrThrowArgs} args - Arguments to find a Candidato
     * @example
     * // Get one Candidato
     * const candidato = await prisma.candidato.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CandidatoFindFirstOrThrowArgs>(args?: SelectSubset<T, CandidatoFindFirstOrThrowArgs<ExtArgs>>): Prisma__CandidatoClient<$Result.GetResult<Prisma.$CandidatoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Candidatoes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidatoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Candidatoes
     * const candidatoes = await prisma.candidato.findMany()
     * 
     * // Get first 10 Candidatoes
     * const candidatoes = await prisma.candidato.findMany({ take: 10 })
     * 
     * // Only select the `idCandidato`
     * const candidatoWithIdCandidatoOnly = await prisma.candidato.findMany({ select: { idCandidato: true } })
     * 
     */
    findMany<T extends CandidatoFindManyArgs>(args?: SelectSubset<T, CandidatoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CandidatoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Candidato.
     * @param {CandidatoCreateArgs} args - Arguments to create a Candidato.
     * @example
     * // Create one Candidato
     * const Candidato = await prisma.candidato.create({
     *   data: {
     *     // ... data to create a Candidato
     *   }
     * })
     * 
     */
    create<T extends CandidatoCreateArgs>(args: SelectSubset<T, CandidatoCreateArgs<ExtArgs>>): Prisma__CandidatoClient<$Result.GetResult<Prisma.$CandidatoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Candidatoes.
     * @param {CandidatoCreateManyArgs} args - Arguments to create many Candidatoes.
     * @example
     * // Create many Candidatoes
     * const candidato = await prisma.candidato.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CandidatoCreateManyArgs>(args?: SelectSubset<T, CandidatoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Candidatoes and returns the data saved in the database.
     * @param {CandidatoCreateManyAndReturnArgs} args - Arguments to create many Candidatoes.
     * @example
     * // Create many Candidatoes
     * const candidato = await prisma.candidato.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Candidatoes and only return the `idCandidato`
     * const candidatoWithIdCandidatoOnly = await prisma.candidato.createManyAndReturn({
     *   select: { idCandidato: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CandidatoCreateManyAndReturnArgs>(args?: SelectSubset<T, CandidatoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CandidatoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Candidato.
     * @param {CandidatoDeleteArgs} args - Arguments to delete one Candidato.
     * @example
     * // Delete one Candidato
     * const Candidato = await prisma.candidato.delete({
     *   where: {
     *     // ... filter to delete one Candidato
     *   }
     * })
     * 
     */
    delete<T extends CandidatoDeleteArgs>(args: SelectSubset<T, CandidatoDeleteArgs<ExtArgs>>): Prisma__CandidatoClient<$Result.GetResult<Prisma.$CandidatoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Candidato.
     * @param {CandidatoUpdateArgs} args - Arguments to update one Candidato.
     * @example
     * // Update one Candidato
     * const candidato = await prisma.candidato.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CandidatoUpdateArgs>(args: SelectSubset<T, CandidatoUpdateArgs<ExtArgs>>): Prisma__CandidatoClient<$Result.GetResult<Prisma.$CandidatoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Candidatoes.
     * @param {CandidatoDeleteManyArgs} args - Arguments to filter Candidatoes to delete.
     * @example
     * // Delete a few Candidatoes
     * const { count } = await prisma.candidato.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CandidatoDeleteManyArgs>(args?: SelectSubset<T, CandidatoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Candidatoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidatoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Candidatoes
     * const candidato = await prisma.candidato.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CandidatoUpdateManyArgs>(args: SelectSubset<T, CandidatoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Candidatoes and returns the data updated in the database.
     * @param {CandidatoUpdateManyAndReturnArgs} args - Arguments to update many Candidatoes.
     * @example
     * // Update many Candidatoes
     * const candidato = await prisma.candidato.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Candidatoes and only return the `idCandidato`
     * const candidatoWithIdCandidatoOnly = await prisma.candidato.updateManyAndReturn({
     *   select: { idCandidato: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CandidatoUpdateManyAndReturnArgs>(args: SelectSubset<T, CandidatoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CandidatoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Candidato.
     * @param {CandidatoUpsertArgs} args - Arguments to update or create a Candidato.
     * @example
     * // Update or create a Candidato
     * const candidato = await prisma.candidato.upsert({
     *   create: {
     *     // ... data to create a Candidato
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Candidato we want to update
     *   }
     * })
     */
    upsert<T extends CandidatoUpsertArgs>(args: SelectSubset<T, CandidatoUpsertArgs<ExtArgs>>): Prisma__CandidatoClient<$Result.GetResult<Prisma.$CandidatoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Candidatoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidatoCountArgs} args - Arguments to filter Candidatoes to count.
     * @example
     * // Count the number of Candidatoes
     * const count = await prisma.candidato.count({
     *   where: {
     *     // ... the filter for the Candidatoes we want to count
     *   }
     * })
    **/
    count<T extends CandidatoCountArgs>(
      args?: Subset<T, CandidatoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CandidatoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Candidato.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidatoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CandidatoAggregateArgs>(args: Subset<T, CandidatoAggregateArgs>): Prisma.PrismaPromise<GetCandidatoAggregateType<T>>

    /**
     * Group by Candidato.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CandidatoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CandidatoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CandidatoGroupByArgs['orderBy'] }
        : { orderBy?: CandidatoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CandidatoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCandidatoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Candidato model
   */
  readonly fields: CandidatoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Candidato.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CandidatoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CTG<T extends CTGDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CTGDefaultArgs<ExtArgs>>): Prisma__CTGClient<$Result.GetResult<Prisma.$CTGPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    PreferenciaSorteioDanca<T extends Candidato$PreferenciaSorteioDancaArgs<ExtArgs> = {}>(args?: Subset<T, Candidato$PreferenciaSorteioDancaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreferenciaSorteioDancaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Categoria<T extends CategoriaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoriaDefaultArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    avalicoes<T extends Candidato$avalicoesArgs<ExtArgs> = {}>(args?: Subset<T, Candidato$avalicoesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sorteioDanca<T extends Candidato$sorteioDancaArgs<ExtArgs> = {}>(args?: Subset<T, Candidato$sorteioDancaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SorteioDancaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Recurso<T extends Candidato$RecursoArgs<ExtArgs> = {}>(args?: Subset<T, Candidato$RecursoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecursoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Concurso<T extends Candidato$ConcursoArgs<ExtArgs> = {}>(args?: Subset<T, Candidato$ConcursoArgs<ExtArgs>>): Prisma__ConcursoClient<$Result.GetResult<Prisma.$ConcursoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Candidato model
   */
  interface CandidatoFieldRefs {
    readonly idCandidato: FieldRef<"Candidato", 'Int'>
    readonly nomeCompleto: FieldRef<"Candidato", 'String'>
    readonly cidade: FieldRef<"Candidato", 'String'>
    readonly estado: FieldRef<"Candidato", 'String'>
    readonly CTGId: FieldRef<"Candidato", 'Int'>
    readonly numCarteirinha: FieldRef<"Candidato", 'String'>
    readonly CPF: FieldRef<"Candidato", 'String'>
    readonly RG: FieldRef<"Candidato", 'String'>
    readonly endereco: FieldRef<"Candidato", 'String'>
    readonly numEndereco: FieldRef<"Candidato", 'Int'>
    readonly bairro: FieldRef<"Candidato", 'String'>
    readonly escolaridade: FieldRef<"Candidato", 'String'>
    readonly filiacao: FieldRef<"Candidato", 'String'>
    readonly ProvaCampeiraEsportiva: FieldRef<"Candidato", 'ProvaCampeiraEsportiva'>
    readonly anexoDocumento: FieldRef<"Candidato", 'Bytes'>
    readonly anexoCarteirinha: FieldRef<"Candidato", 'Bytes'>
    readonly anexoEscolaridade: FieldRef<"Candidato", 'Bytes'>
    readonly anexoResidencia: FieldRef<"Candidato", 'Bytes'>
    readonly anexoAtaConcurso: FieldRef<"Candidato", 'Bytes'>
    readonly fichaInscricao: FieldRef<"Candidato", 'Bytes'>
    readonly anexoTermoCandidato: FieldRef<"Candidato", 'Bytes'>
    readonly anexoRelatorioVivencia: FieldRef<"Candidato", 'Bytes'>
    readonly anexoResponsavel: FieldRef<"Candidato", 'Bytes'>
    readonly anexoProvaEsportivaCampeira: FieldRef<"Candidato", 'Bytes'>
    readonly categoriaId: FieldRef<"Candidato", 'Int'>
    readonly concursoIdConcurso: FieldRef<"Candidato", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Candidato findUnique
   */
  export type CandidatoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidato
     */
    select?: CandidatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Candidato
     */
    omit?: CandidatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidatoInclude<ExtArgs> | null
    /**
     * Filter, which Candidato to fetch.
     */
    where: CandidatoWhereUniqueInput
  }

  /**
   * Candidato findUniqueOrThrow
   */
  export type CandidatoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidato
     */
    select?: CandidatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Candidato
     */
    omit?: CandidatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidatoInclude<ExtArgs> | null
    /**
     * Filter, which Candidato to fetch.
     */
    where: CandidatoWhereUniqueInput
  }

  /**
   * Candidato findFirst
   */
  export type CandidatoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidato
     */
    select?: CandidatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Candidato
     */
    omit?: CandidatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidatoInclude<ExtArgs> | null
    /**
     * Filter, which Candidato to fetch.
     */
    where?: CandidatoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Candidatoes to fetch.
     */
    orderBy?: CandidatoOrderByWithRelationInput | CandidatoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Candidatoes.
     */
    cursor?: CandidatoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Candidatoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Candidatoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Candidatoes.
     */
    distinct?: CandidatoScalarFieldEnum | CandidatoScalarFieldEnum[]
  }

  /**
   * Candidato findFirstOrThrow
   */
  export type CandidatoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidato
     */
    select?: CandidatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Candidato
     */
    omit?: CandidatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidatoInclude<ExtArgs> | null
    /**
     * Filter, which Candidato to fetch.
     */
    where?: CandidatoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Candidatoes to fetch.
     */
    orderBy?: CandidatoOrderByWithRelationInput | CandidatoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Candidatoes.
     */
    cursor?: CandidatoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Candidatoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Candidatoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Candidatoes.
     */
    distinct?: CandidatoScalarFieldEnum | CandidatoScalarFieldEnum[]
  }

  /**
   * Candidato findMany
   */
  export type CandidatoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidato
     */
    select?: CandidatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Candidato
     */
    omit?: CandidatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidatoInclude<ExtArgs> | null
    /**
     * Filter, which Candidatoes to fetch.
     */
    where?: CandidatoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Candidatoes to fetch.
     */
    orderBy?: CandidatoOrderByWithRelationInput | CandidatoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Candidatoes.
     */
    cursor?: CandidatoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Candidatoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Candidatoes.
     */
    skip?: number
    distinct?: CandidatoScalarFieldEnum | CandidatoScalarFieldEnum[]
  }

  /**
   * Candidato create
   */
  export type CandidatoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidato
     */
    select?: CandidatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Candidato
     */
    omit?: CandidatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidatoInclude<ExtArgs> | null
    /**
     * The data needed to create a Candidato.
     */
    data: XOR<CandidatoCreateInput, CandidatoUncheckedCreateInput>
  }

  /**
   * Candidato createMany
   */
  export type CandidatoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Candidatoes.
     */
    data: CandidatoCreateManyInput | CandidatoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Candidato createManyAndReturn
   */
  export type CandidatoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidato
     */
    select?: CandidatoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Candidato
     */
    omit?: CandidatoOmit<ExtArgs> | null
    /**
     * The data used to create many Candidatoes.
     */
    data: CandidatoCreateManyInput | CandidatoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidatoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Candidato update
   */
  export type CandidatoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidato
     */
    select?: CandidatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Candidato
     */
    omit?: CandidatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidatoInclude<ExtArgs> | null
    /**
     * The data needed to update a Candidato.
     */
    data: XOR<CandidatoUpdateInput, CandidatoUncheckedUpdateInput>
    /**
     * Choose, which Candidato to update.
     */
    where: CandidatoWhereUniqueInput
  }

  /**
   * Candidato updateMany
   */
  export type CandidatoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Candidatoes.
     */
    data: XOR<CandidatoUpdateManyMutationInput, CandidatoUncheckedUpdateManyInput>
    /**
     * Filter which Candidatoes to update
     */
    where?: CandidatoWhereInput
    /**
     * Limit how many Candidatoes to update.
     */
    limit?: number
  }

  /**
   * Candidato updateManyAndReturn
   */
  export type CandidatoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidato
     */
    select?: CandidatoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Candidato
     */
    omit?: CandidatoOmit<ExtArgs> | null
    /**
     * The data used to update Candidatoes.
     */
    data: XOR<CandidatoUpdateManyMutationInput, CandidatoUncheckedUpdateManyInput>
    /**
     * Filter which Candidatoes to update
     */
    where?: CandidatoWhereInput
    /**
     * Limit how many Candidatoes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidatoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Candidato upsert
   */
  export type CandidatoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidato
     */
    select?: CandidatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Candidato
     */
    omit?: CandidatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidatoInclude<ExtArgs> | null
    /**
     * The filter to search for the Candidato to update in case it exists.
     */
    where: CandidatoWhereUniqueInput
    /**
     * In case the Candidato found by the `where` argument doesn't exist, create a new Candidato with this data.
     */
    create: XOR<CandidatoCreateInput, CandidatoUncheckedCreateInput>
    /**
     * In case the Candidato was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CandidatoUpdateInput, CandidatoUncheckedUpdateInput>
  }

  /**
   * Candidato delete
   */
  export type CandidatoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidato
     */
    select?: CandidatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Candidato
     */
    omit?: CandidatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidatoInclude<ExtArgs> | null
    /**
     * Filter which Candidato to delete.
     */
    where: CandidatoWhereUniqueInput
  }

  /**
   * Candidato deleteMany
   */
  export type CandidatoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Candidatoes to delete
     */
    where?: CandidatoWhereInput
    /**
     * Limit how many Candidatoes to delete.
     */
    limit?: number
  }

  /**
   * Candidato.PreferenciaSorteioDanca
   */
  export type Candidato$PreferenciaSorteioDancaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferenciaSorteioDanca
     */
    select?: PreferenciaSorteioDancaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreferenciaSorteioDanca
     */
    omit?: PreferenciaSorteioDancaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferenciaSorteioDancaInclude<ExtArgs> | null
    where?: PreferenciaSorteioDancaWhereInput
    orderBy?: PreferenciaSorteioDancaOrderByWithRelationInput | PreferenciaSorteioDancaOrderByWithRelationInput[]
    cursor?: PreferenciaSorteioDancaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PreferenciaSorteioDancaScalarFieldEnum | PreferenciaSorteioDancaScalarFieldEnum[]
  }

  /**
   * Candidato.avalicoes
   */
  export type Candidato$avalicoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avaliacao
     */
    omit?: AvaliacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    where?: AvaliacaoWhereInput
    orderBy?: AvaliacaoOrderByWithRelationInput | AvaliacaoOrderByWithRelationInput[]
    cursor?: AvaliacaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AvaliacaoScalarFieldEnum | AvaliacaoScalarFieldEnum[]
  }

  /**
   * Candidato.sorteioDanca
   */
  export type Candidato$sorteioDancaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SorteioDanca
     */
    select?: SorteioDancaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SorteioDanca
     */
    omit?: SorteioDancaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SorteioDancaInclude<ExtArgs> | null
    where?: SorteioDancaWhereInput
    orderBy?: SorteioDancaOrderByWithRelationInput | SorteioDancaOrderByWithRelationInput[]
    cursor?: SorteioDancaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SorteioDancaScalarFieldEnum | SorteioDancaScalarFieldEnum[]
  }

  /**
   * Candidato.Recurso
   */
  export type Candidato$RecursoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recurso
     */
    select?: RecursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recurso
     */
    omit?: RecursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecursoInclude<ExtArgs> | null
    where?: RecursoWhereInput
    orderBy?: RecursoOrderByWithRelationInput | RecursoOrderByWithRelationInput[]
    cursor?: RecursoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecursoScalarFieldEnum | RecursoScalarFieldEnum[]
  }

  /**
   * Candidato.Concurso
   */
  export type Candidato$ConcursoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concurso
     */
    select?: ConcursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Concurso
     */
    omit?: ConcursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConcursoInclude<ExtArgs> | null
    where?: ConcursoWhereInput
  }

  /**
   * Candidato without action
   */
  export type CandidatoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidato
     */
    select?: CandidatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Candidato
     */
    omit?: CandidatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidatoInclude<ExtArgs> | null
  }


  /**
   * Model Usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    idUsuario: number | null
    CTGId: number | null
    numCredenciamento: number | null
    comissaoUsuarioId: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    idUsuario: number | null
    CTGId: number | null
    numCredenciamento: number | null
    comissaoUsuarioId: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    idUsuario: number | null
    nomeCompleto: string | null
    cidade: string | null
    estado: string | null
    CTGId: number | null
    numCarteirinha: string | null
    login: string | null
    senha: string | null
    funcao: $Enums.Funcao | null
    credenciamento: $Enums.Credenciamento | null
    numCredenciamento: number | null
    comissaoUsuarioId: number | null
  }

  export type UsuarioMaxAggregateOutputType = {
    idUsuario: number | null
    nomeCompleto: string | null
    cidade: string | null
    estado: string | null
    CTGId: number | null
    numCarteirinha: string | null
    login: string | null
    senha: string | null
    funcao: $Enums.Funcao | null
    credenciamento: $Enums.Credenciamento | null
    numCredenciamento: number | null
    comissaoUsuarioId: number | null
  }

  export type UsuarioCountAggregateOutputType = {
    idUsuario: number
    nomeCompleto: number
    cidade: number
    estado: number
    CTGId: number
    numCarteirinha: number
    login: number
    senha: number
    funcao: number
    credenciamento: number
    numCredenciamento: number
    comissaoUsuarioId: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    idUsuario?: true
    CTGId?: true
    numCredenciamento?: true
    comissaoUsuarioId?: true
  }

  export type UsuarioSumAggregateInputType = {
    idUsuario?: true
    CTGId?: true
    numCredenciamento?: true
    comissaoUsuarioId?: true
  }

  export type UsuarioMinAggregateInputType = {
    idUsuario?: true
    nomeCompleto?: true
    cidade?: true
    estado?: true
    CTGId?: true
    numCarteirinha?: true
    login?: true
    senha?: true
    funcao?: true
    credenciamento?: true
    numCredenciamento?: true
    comissaoUsuarioId?: true
  }

  export type UsuarioMaxAggregateInputType = {
    idUsuario?: true
    nomeCompleto?: true
    cidade?: true
    estado?: true
    CTGId?: true
    numCarteirinha?: true
    login?: true
    senha?: true
    funcao?: true
    credenciamento?: true
    numCredenciamento?: true
    comissaoUsuarioId?: true
  }

  export type UsuarioCountAggregateInputType = {
    idUsuario?: true
    nomeCompleto?: true
    cidade?: true
    estado?: true
    CTGId?: true
    numCarteirinha?: true
    login?: true
    senha?: true
    funcao?: true
    credenciamento?: true
    numCredenciamento?: true
    comissaoUsuarioId?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuario to aggregate.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithAggregationInput | UsuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: UsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    idUsuario: number
    nomeCompleto: string
    cidade: string
    estado: string
    CTGId: number
    numCarteirinha: string
    login: string
    senha: string
    funcao: $Enums.Funcao
    credenciamento: $Enums.Credenciamento
    numCredenciamento: number | null
    comissaoUsuarioId: number | null
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idUsuario?: boolean
    nomeCompleto?: boolean
    cidade?: boolean
    estado?: boolean
    CTGId?: boolean
    numCarteirinha?: boolean
    login?: boolean
    senha?: boolean
    funcao?: boolean
    credenciamento?: boolean
    numCredenciamento?: boolean
    comissaoUsuarioId?: boolean
    CTG?: boolean | CTGDefaultArgs<ExtArgs>
    ComissaoUsuario?: boolean | Usuario$ComissaoUsuarioArgs<ExtArgs>
    avalicoes?: boolean | Usuario$avalicoesArgs<ExtArgs>
    recursos?: boolean | Usuario$recursosArgs<ExtArgs>
    sorteioDanca?: boolean | Usuario$sorteioDancaArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idUsuario?: boolean
    nomeCompleto?: boolean
    cidade?: boolean
    estado?: boolean
    CTGId?: boolean
    numCarteirinha?: boolean
    login?: boolean
    senha?: boolean
    funcao?: boolean
    credenciamento?: boolean
    numCredenciamento?: boolean
    comissaoUsuarioId?: boolean
    CTG?: boolean | CTGDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idUsuario?: boolean
    nomeCompleto?: boolean
    cidade?: boolean
    estado?: boolean
    CTGId?: boolean
    numCarteirinha?: boolean
    login?: boolean
    senha?: boolean
    funcao?: boolean
    credenciamento?: boolean
    numCredenciamento?: boolean
    comissaoUsuarioId?: boolean
    CTG?: boolean | CTGDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectScalar = {
    idUsuario?: boolean
    nomeCompleto?: boolean
    cidade?: boolean
    estado?: boolean
    CTGId?: boolean
    numCarteirinha?: boolean
    login?: boolean
    senha?: boolean
    funcao?: boolean
    credenciamento?: boolean
    numCredenciamento?: boolean
    comissaoUsuarioId?: boolean
  }

  export type UsuarioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idUsuario" | "nomeCompleto" | "cidade" | "estado" | "CTGId" | "numCarteirinha" | "login" | "senha" | "funcao" | "credenciamento" | "numCredenciamento" | "comissaoUsuarioId", ExtArgs["result"]["usuario"]>
  export type UsuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CTG?: boolean | CTGDefaultArgs<ExtArgs>
    ComissaoUsuario?: boolean | Usuario$ComissaoUsuarioArgs<ExtArgs>
    avalicoes?: boolean | Usuario$avalicoesArgs<ExtArgs>
    recursos?: boolean | Usuario$recursosArgs<ExtArgs>
    sorteioDanca?: boolean | Usuario$sorteioDancaArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UsuarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CTG?: boolean | CTGDefaultArgs<ExtArgs>
  }
  export type UsuarioIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CTG?: boolean | CTGDefaultArgs<ExtArgs>
  }

  export type $UsuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usuario"
    objects: {
      CTG: Prisma.$CTGPayload<ExtArgs>
      ComissaoUsuario: Prisma.$ComissaoUsuarioPayload<ExtArgs> | null
      avalicoes: Prisma.$AvaliacaoPayload<ExtArgs>[]
      recursos: Prisma.$RecursoPayload<ExtArgs>[]
      sorteioDanca: Prisma.$SorteioDancaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idUsuario: number
      nomeCompleto: string
      cidade: string
      estado: string
      CTGId: number
      numCarteirinha: string
      login: string
      senha: string
      funcao: $Enums.Funcao
      credenciamento: $Enums.Credenciamento
      numCredenciamento: number | null
      comissaoUsuarioId: number | null
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }

  type UsuarioGetPayload<S extends boolean | null | undefined | UsuarioDefaultArgs> = $Result.GetResult<Prisma.$UsuarioPayload, S>

  type UsuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsuarioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface UsuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuario'], meta: { name: 'Usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuarioFindUniqueArgs>(args: SelectSubset<T, UsuarioFindUniqueArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Usuario that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, UsuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuarioFindFirstArgs>(args?: SelectSubset<T, UsuarioFindFirstArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, UsuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `idUsuario`
     * const usuarioWithIdUsuarioOnly = await prisma.usuario.findMany({ select: { idUsuario: true } })
     * 
     */
    findMany<T extends UsuarioFindManyArgs>(args?: SelectSubset<T, UsuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
     */
    create<T extends UsuarioCreateArgs>(args: SelectSubset<T, UsuarioCreateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Usuarios.
     * @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsuarioCreateManyArgs>(args?: SelectSubset<T, UsuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Usuarios and returns the data saved in the database.
     * @param {UsuarioCreateManyAndReturnArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Usuarios and only return the `idUsuario`
     * const usuarioWithIdUsuarioOnly = await prisma.usuario.createManyAndReturn({
     *   select: { idUsuario: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsuarioCreateManyAndReturnArgs>(args?: SelectSubset<T, UsuarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
     */
    delete<T extends UsuarioDeleteArgs>(args: SelectSubset<T, UsuarioDeleteArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsuarioUpdateArgs>(args: SelectSubset<T, UsuarioUpdateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsuarioDeleteManyArgs>(args?: SelectSubset<T, UsuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsuarioUpdateManyArgs>(args: SelectSubset<T, UsuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios and returns the data updated in the database.
     * @param {UsuarioUpdateManyAndReturnArgs} args - Arguments to update many Usuarios.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Usuarios and only return the `idUsuario`
     * const usuarioWithIdUsuarioOnly = await prisma.usuario.updateManyAndReturn({
     *   select: { idUsuario: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UsuarioUpdateManyAndReturnArgs>(args: SelectSubset<T, UsuarioUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
     */
    upsert<T extends UsuarioUpsertArgs>(args: SelectSubset<T, UsuarioUpsertArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usuario model
   */
  readonly fields: UsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CTG<T extends CTGDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CTGDefaultArgs<ExtArgs>>): Prisma__CTGClient<$Result.GetResult<Prisma.$CTGPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ComissaoUsuario<T extends Usuario$ComissaoUsuarioArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$ComissaoUsuarioArgs<ExtArgs>>): Prisma__ComissaoUsuarioClient<$Result.GetResult<Prisma.$ComissaoUsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    avalicoes<T extends Usuario$avalicoesArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$avalicoesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recursos<T extends Usuario$recursosArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$recursosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecursoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sorteioDanca<T extends Usuario$sorteioDancaArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$sorteioDancaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SorteioDancaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Usuario model
   */
  interface UsuarioFieldRefs {
    readonly idUsuario: FieldRef<"Usuario", 'Int'>
    readonly nomeCompleto: FieldRef<"Usuario", 'String'>
    readonly cidade: FieldRef<"Usuario", 'String'>
    readonly estado: FieldRef<"Usuario", 'String'>
    readonly CTGId: FieldRef<"Usuario", 'Int'>
    readonly numCarteirinha: FieldRef<"Usuario", 'String'>
    readonly login: FieldRef<"Usuario", 'String'>
    readonly senha: FieldRef<"Usuario", 'String'>
    readonly funcao: FieldRef<"Usuario", 'Funcao'>
    readonly credenciamento: FieldRef<"Usuario", 'Credenciamento'>
    readonly numCredenciamento: FieldRef<"Usuario", 'Int'>
    readonly comissaoUsuarioId: FieldRef<"Usuario", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Usuario findUnique
   */
  export type UsuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findUniqueOrThrow
   */
  export type UsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findFirst
   */
  export type UsuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findFirstOrThrow
   */
  export type UsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario create
   */
  export type UsuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Usuario.
     */
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
  }

  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuario createManyAndReturn
   */
  export type UsuarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Usuario.
     */
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
    /**
     * Choose, which Usuario to update.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
    /**
     * Limit how many Usuarios to update.
     */
    limit?: number
  }

  /**
   * Usuario updateManyAndReturn
   */
  export type UsuarioUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
    /**
     * Limit how many Usuarios to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Usuario to update in case it exists.
     */
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     */
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
  }

  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter which Usuario to delete.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuarioWhereInput
    /**
     * Limit how many Usuarios to delete.
     */
    limit?: number
  }

  /**
   * Usuario.ComissaoUsuario
   */
  export type Usuario$ComissaoUsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComissaoUsuario
     */
    select?: ComissaoUsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComissaoUsuario
     */
    omit?: ComissaoUsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComissaoUsuarioInclude<ExtArgs> | null
    where?: ComissaoUsuarioWhereInput
  }

  /**
   * Usuario.avalicoes
   */
  export type Usuario$avalicoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avaliacao
     */
    omit?: AvaliacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    where?: AvaliacaoWhereInput
    orderBy?: AvaliacaoOrderByWithRelationInput | AvaliacaoOrderByWithRelationInput[]
    cursor?: AvaliacaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AvaliacaoScalarFieldEnum | AvaliacaoScalarFieldEnum[]
  }

  /**
   * Usuario.recursos
   */
  export type Usuario$recursosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recurso
     */
    select?: RecursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recurso
     */
    omit?: RecursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecursoInclude<ExtArgs> | null
    where?: RecursoWhereInput
    orderBy?: RecursoOrderByWithRelationInput | RecursoOrderByWithRelationInput[]
    cursor?: RecursoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecursoScalarFieldEnum | RecursoScalarFieldEnum[]
  }

  /**
   * Usuario.sorteioDanca
   */
  export type Usuario$sorteioDancaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SorteioDanca
     */
    select?: SorteioDancaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SorteioDanca
     */
    omit?: SorteioDancaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SorteioDancaInclude<ExtArgs> | null
    where?: SorteioDancaWhereInput
    orderBy?: SorteioDancaOrderByWithRelationInput | SorteioDancaOrderByWithRelationInput[]
    cursor?: SorteioDancaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SorteioDancaScalarFieldEnum | SorteioDancaScalarFieldEnum[]
  }

  /**
   * Usuario without action
   */
  export type UsuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
  }


  /**
   * Model CTG
   */

  export type AggregateCTG = {
    _count: CTGCountAggregateOutputType | null
    _avg: CTGAvgAggregateOutputType | null
    _sum: CTGSumAggregateOutputType | null
    _min: CTGMinAggregateOutputType | null
    _max: CTGMaxAggregateOutputType | null
  }

  export type CTGAvgAggregateOutputType = {
    idCTG: number | null
    RTid: number | null
  }

  export type CTGSumAggregateOutputType = {
    idCTG: number | null
    RTid: number | null
  }

  export type CTGMinAggregateOutputType = {
    idCTG: number | null
    nomeCTG: string | null
    RTid: number | null
  }

  export type CTGMaxAggregateOutputType = {
    idCTG: number | null
    nomeCTG: string | null
    RTid: number | null
  }

  export type CTGCountAggregateOutputType = {
    idCTG: number
    nomeCTG: number
    RTid: number
    _all: number
  }


  export type CTGAvgAggregateInputType = {
    idCTG?: true
    RTid?: true
  }

  export type CTGSumAggregateInputType = {
    idCTG?: true
    RTid?: true
  }

  export type CTGMinAggregateInputType = {
    idCTG?: true
    nomeCTG?: true
    RTid?: true
  }

  export type CTGMaxAggregateInputType = {
    idCTG?: true
    nomeCTG?: true
    RTid?: true
  }

  export type CTGCountAggregateInputType = {
    idCTG?: true
    nomeCTG?: true
    RTid?: true
    _all?: true
  }

  export type CTGAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CTG to aggregate.
     */
    where?: CTGWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CTGS to fetch.
     */
    orderBy?: CTGOrderByWithRelationInput | CTGOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CTGWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CTGS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CTGS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CTGS
    **/
    _count?: true | CTGCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CTGAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CTGSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CTGMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CTGMaxAggregateInputType
  }

  export type GetCTGAggregateType<T extends CTGAggregateArgs> = {
        [P in keyof T & keyof AggregateCTG]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCTG[P]>
      : GetScalarType<T[P], AggregateCTG[P]>
  }




  export type CTGGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CTGWhereInput
    orderBy?: CTGOrderByWithAggregationInput | CTGOrderByWithAggregationInput[]
    by: CTGScalarFieldEnum[] | CTGScalarFieldEnum
    having?: CTGScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CTGCountAggregateInputType | true
    _avg?: CTGAvgAggregateInputType
    _sum?: CTGSumAggregateInputType
    _min?: CTGMinAggregateInputType
    _max?: CTGMaxAggregateInputType
  }

  export type CTGGroupByOutputType = {
    idCTG: number
    nomeCTG: string
    RTid: number
    _count: CTGCountAggregateOutputType | null
    _avg: CTGAvgAggregateOutputType | null
    _sum: CTGSumAggregateOutputType | null
    _min: CTGMinAggregateOutputType | null
    _max: CTGMaxAggregateOutputType | null
  }

  type GetCTGGroupByPayload<T extends CTGGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CTGGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CTGGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CTGGroupByOutputType[P]>
            : GetScalarType<T[P], CTGGroupByOutputType[P]>
        }
      >
    >


  export type CTGSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idCTG?: boolean
    nomeCTG?: boolean
    RTid?: boolean
    RT?: boolean | RTDefaultArgs<ExtArgs>
    Usuario?: boolean | CTG$UsuarioArgs<ExtArgs>
    Candidato?: boolean | CTG$CandidatoArgs<ExtArgs>
    _count?: boolean | CTGCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cTG"]>

  export type CTGSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idCTG?: boolean
    nomeCTG?: boolean
    RTid?: boolean
    RT?: boolean | RTDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cTG"]>

  export type CTGSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idCTG?: boolean
    nomeCTG?: boolean
    RTid?: boolean
    RT?: boolean | RTDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cTG"]>

  export type CTGSelectScalar = {
    idCTG?: boolean
    nomeCTG?: boolean
    RTid?: boolean
  }

  export type CTGOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idCTG" | "nomeCTG" | "RTid", ExtArgs["result"]["cTG"]>
  export type CTGInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RT?: boolean | RTDefaultArgs<ExtArgs>
    Usuario?: boolean | CTG$UsuarioArgs<ExtArgs>
    Candidato?: boolean | CTG$CandidatoArgs<ExtArgs>
    _count?: boolean | CTGCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CTGIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RT?: boolean | RTDefaultArgs<ExtArgs>
  }
  export type CTGIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RT?: boolean | RTDefaultArgs<ExtArgs>
  }

  export type $CTGPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CTG"
    objects: {
      RT: Prisma.$RTPayload<ExtArgs>
      Usuario: Prisma.$UsuarioPayload<ExtArgs>[]
      Candidato: Prisma.$CandidatoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idCTG: number
      nomeCTG: string
      RTid: number
    }, ExtArgs["result"]["cTG"]>
    composites: {}
  }

  type CTGGetPayload<S extends boolean | null | undefined | CTGDefaultArgs> = $Result.GetResult<Prisma.$CTGPayload, S>

  type CTGCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CTGFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CTGCountAggregateInputType | true
    }

  export interface CTGDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CTG'], meta: { name: 'CTG' } }
    /**
     * Find zero or one CTG that matches the filter.
     * @param {CTGFindUniqueArgs} args - Arguments to find a CTG
     * @example
     * // Get one CTG
     * const cTG = await prisma.cTG.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CTGFindUniqueArgs>(args: SelectSubset<T, CTGFindUniqueArgs<ExtArgs>>): Prisma__CTGClient<$Result.GetResult<Prisma.$CTGPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CTG that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CTGFindUniqueOrThrowArgs} args - Arguments to find a CTG
     * @example
     * // Get one CTG
     * const cTG = await prisma.cTG.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CTGFindUniqueOrThrowArgs>(args: SelectSubset<T, CTGFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CTGClient<$Result.GetResult<Prisma.$CTGPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CTG that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CTGFindFirstArgs} args - Arguments to find a CTG
     * @example
     * // Get one CTG
     * const cTG = await prisma.cTG.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CTGFindFirstArgs>(args?: SelectSubset<T, CTGFindFirstArgs<ExtArgs>>): Prisma__CTGClient<$Result.GetResult<Prisma.$CTGPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CTG that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CTGFindFirstOrThrowArgs} args - Arguments to find a CTG
     * @example
     * // Get one CTG
     * const cTG = await prisma.cTG.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CTGFindFirstOrThrowArgs>(args?: SelectSubset<T, CTGFindFirstOrThrowArgs<ExtArgs>>): Prisma__CTGClient<$Result.GetResult<Prisma.$CTGPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CTGS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CTGFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CTGS
     * const cTGS = await prisma.cTG.findMany()
     * 
     * // Get first 10 CTGS
     * const cTGS = await prisma.cTG.findMany({ take: 10 })
     * 
     * // Only select the `idCTG`
     * const cTGWithIdCTGOnly = await prisma.cTG.findMany({ select: { idCTG: true } })
     * 
     */
    findMany<T extends CTGFindManyArgs>(args?: SelectSubset<T, CTGFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CTGPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CTG.
     * @param {CTGCreateArgs} args - Arguments to create a CTG.
     * @example
     * // Create one CTG
     * const CTG = await prisma.cTG.create({
     *   data: {
     *     // ... data to create a CTG
     *   }
     * })
     * 
     */
    create<T extends CTGCreateArgs>(args: SelectSubset<T, CTGCreateArgs<ExtArgs>>): Prisma__CTGClient<$Result.GetResult<Prisma.$CTGPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CTGS.
     * @param {CTGCreateManyArgs} args - Arguments to create many CTGS.
     * @example
     * // Create many CTGS
     * const cTG = await prisma.cTG.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CTGCreateManyArgs>(args?: SelectSubset<T, CTGCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CTGS and returns the data saved in the database.
     * @param {CTGCreateManyAndReturnArgs} args - Arguments to create many CTGS.
     * @example
     * // Create many CTGS
     * const cTG = await prisma.cTG.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CTGS and only return the `idCTG`
     * const cTGWithIdCTGOnly = await prisma.cTG.createManyAndReturn({
     *   select: { idCTG: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CTGCreateManyAndReturnArgs>(args?: SelectSubset<T, CTGCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CTGPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CTG.
     * @param {CTGDeleteArgs} args - Arguments to delete one CTG.
     * @example
     * // Delete one CTG
     * const CTG = await prisma.cTG.delete({
     *   where: {
     *     // ... filter to delete one CTG
     *   }
     * })
     * 
     */
    delete<T extends CTGDeleteArgs>(args: SelectSubset<T, CTGDeleteArgs<ExtArgs>>): Prisma__CTGClient<$Result.GetResult<Prisma.$CTGPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CTG.
     * @param {CTGUpdateArgs} args - Arguments to update one CTG.
     * @example
     * // Update one CTG
     * const cTG = await prisma.cTG.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CTGUpdateArgs>(args: SelectSubset<T, CTGUpdateArgs<ExtArgs>>): Prisma__CTGClient<$Result.GetResult<Prisma.$CTGPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CTGS.
     * @param {CTGDeleteManyArgs} args - Arguments to filter CTGS to delete.
     * @example
     * // Delete a few CTGS
     * const { count } = await prisma.cTG.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CTGDeleteManyArgs>(args?: SelectSubset<T, CTGDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CTGS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CTGUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CTGS
     * const cTG = await prisma.cTG.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CTGUpdateManyArgs>(args: SelectSubset<T, CTGUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CTGS and returns the data updated in the database.
     * @param {CTGUpdateManyAndReturnArgs} args - Arguments to update many CTGS.
     * @example
     * // Update many CTGS
     * const cTG = await prisma.cTG.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CTGS and only return the `idCTG`
     * const cTGWithIdCTGOnly = await prisma.cTG.updateManyAndReturn({
     *   select: { idCTG: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CTGUpdateManyAndReturnArgs>(args: SelectSubset<T, CTGUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CTGPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CTG.
     * @param {CTGUpsertArgs} args - Arguments to update or create a CTG.
     * @example
     * // Update or create a CTG
     * const cTG = await prisma.cTG.upsert({
     *   create: {
     *     // ... data to create a CTG
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CTG we want to update
     *   }
     * })
     */
    upsert<T extends CTGUpsertArgs>(args: SelectSubset<T, CTGUpsertArgs<ExtArgs>>): Prisma__CTGClient<$Result.GetResult<Prisma.$CTGPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CTGS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CTGCountArgs} args - Arguments to filter CTGS to count.
     * @example
     * // Count the number of CTGS
     * const count = await prisma.cTG.count({
     *   where: {
     *     // ... the filter for the CTGS we want to count
     *   }
     * })
    **/
    count<T extends CTGCountArgs>(
      args?: Subset<T, CTGCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CTGCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CTG.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CTGAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CTGAggregateArgs>(args: Subset<T, CTGAggregateArgs>): Prisma.PrismaPromise<GetCTGAggregateType<T>>

    /**
     * Group by CTG.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CTGGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CTGGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CTGGroupByArgs['orderBy'] }
        : { orderBy?: CTGGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CTGGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCTGGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CTG model
   */
  readonly fields: CTGFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CTG.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CTGClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    RT<T extends RTDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RTDefaultArgs<ExtArgs>>): Prisma__RTClient<$Result.GetResult<Prisma.$RTPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Usuario<T extends CTG$UsuarioArgs<ExtArgs> = {}>(args?: Subset<T, CTG$UsuarioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Candidato<T extends CTG$CandidatoArgs<ExtArgs> = {}>(args?: Subset<T, CTG$CandidatoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CandidatoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CTG model
   */
  interface CTGFieldRefs {
    readonly idCTG: FieldRef<"CTG", 'Int'>
    readonly nomeCTG: FieldRef<"CTG", 'String'>
    readonly RTid: FieldRef<"CTG", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CTG findUnique
   */
  export type CTGFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CTG
     */
    select?: CTGSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CTG
     */
    omit?: CTGOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CTGInclude<ExtArgs> | null
    /**
     * Filter, which CTG to fetch.
     */
    where: CTGWhereUniqueInput
  }

  /**
   * CTG findUniqueOrThrow
   */
  export type CTGFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CTG
     */
    select?: CTGSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CTG
     */
    omit?: CTGOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CTGInclude<ExtArgs> | null
    /**
     * Filter, which CTG to fetch.
     */
    where: CTGWhereUniqueInput
  }

  /**
   * CTG findFirst
   */
  export type CTGFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CTG
     */
    select?: CTGSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CTG
     */
    omit?: CTGOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CTGInclude<ExtArgs> | null
    /**
     * Filter, which CTG to fetch.
     */
    where?: CTGWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CTGS to fetch.
     */
    orderBy?: CTGOrderByWithRelationInput | CTGOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CTGS.
     */
    cursor?: CTGWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CTGS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CTGS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CTGS.
     */
    distinct?: CTGScalarFieldEnum | CTGScalarFieldEnum[]
  }

  /**
   * CTG findFirstOrThrow
   */
  export type CTGFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CTG
     */
    select?: CTGSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CTG
     */
    omit?: CTGOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CTGInclude<ExtArgs> | null
    /**
     * Filter, which CTG to fetch.
     */
    where?: CTGWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CTGS to fetch.
     */
    orderBy?: CTGOrderByWithRelationInput | CTGOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CTGS.
     */
    cursor?: CTGWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CTGS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CTGS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CTGS.
     */
    distinct?: CTGScalarFieldEnum | CTGScalarFieldEnum[]
  }

  /**
   * CTG findMany
   */
  export type CTGFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CTG
     */
    select?: CTGSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CTG
     */
    omit?: CTGOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CTGInclude<ExtArgs> | null
    /**
     * Filter, which CTGS to fetch.
     */
    where?: CTGWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CTGS to fetch.
     */
    orderBy?: CTGOrderByWithRelationInput | CTGOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CTGS.
     */
    cursor?: CTGWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CTGS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CTGS.
     */
    skip?: number
    distinct?: CTGScalarFieldEnum | CTGScalarFieldEnum[]
  }

  /**
   * CTG create
   */
  export type CTGCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CTG
     */
    select?: CTGSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CTG
     */
    omit?: CTGOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CTGInclude<ExtArgs> | null
    /**
     * The data needed to create a CTG.
     */
    data: XOR<CTGCreateInput, CTGUncheckedCreateInput>
  }

  /**
   * CTG createMany
   */
  export type CTGCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CTGS.
     */
    data: CTGCreateManyInput | CTGCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CTG createManyAndReturn
   */
  export type CTGCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CTG
     */
    select?: CTGSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CTG
     */
    omit?: CTGOmit<ExtArgs> | null
    /**
     * The data used to create many CTGS.
     */
    data: CTGCreateManyInput | CTGCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CTGIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CTG update
   */
  export type CTGUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CTG
     */
    select?: CTGSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CTG
     */
    omit?: CTGOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CTGInclude<ExtArgs> | null
    /**
     * The data needed to update a CTG.
     */
    data: XOR<CTGUpdateInput, CTGUncheckedUpdateInput>
    /**
     * Choose, which CTG to update.
     */
    where: CTGWhereUniqueInput
  }

  /**
   * CTG updateMany
   */
  export type CTGUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CTGS.
     */
    data: XOR<CTGUpdateManyMutationInput, CTGUncheckedUpdateManyInput>
    /**
     * Filter which CTGS to update
     */
    where?: CTGWhereInput
    /**
     * Limit how many CTGS to update.
     */
    limit?: number
  }

  /**
   * CTG updateManyAndReturn
   */
  export type CTGUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CTG
     */
    select?: CTGSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CTG
     */
    omit?: CTGOmit<ExtArgs> | null
    /**
     * The data used to update CTGS.
     */
    data: XOR<CTGUpdateManyMutationInput, CTGUncheckedUpdateManyInput>
    /**
     * Filter which CTGS to update
     */
    where?: CTGWhereInput
    /**
     * Limit how many CTGS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CTGIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CTG upsert
   */
  export type CTGUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CTG
     */
    select?: CTGSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CTG
     */
    omit?: CTGOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CTGInclude<ExtArgs> | null
    /**
     * The filter to search for the CTG to update in case it exists.
     */
    where: CTGWhereUniqueInput
    /**
     * In case the CTG found by the `where` argument doesn't exist, create a new CTG with this data.
     */
    create: XOR<CTGCreateInput, CTGUncheckedCreateInput>
    /**
     * In case the CTG was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CTGUpdateInput, CTGUncheckedUpdateInput>
  }

  /**
   * CTG delete
   */
  export type CTGDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CTG
     */
    select?: CTGSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CTG
     */
    omit?: CTGOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CTGInclude<ExtArgs> | null
    /**
     * Filter which CTG to delete.
     */
    where: CTGWhereUniqueInput
  }

  /**
   * CTG deleteMany
   */
  export type CTGDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CTGS to delete
     */
    where?: CTGWhereInput
    /**
     * Limit how many CTGS to delete.
     */
    limit?: number
  }

  /**
   * CTG.Usuario
   */
  export type CTG$UsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    cursor?: UsuarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * CTG.Candidato
   */
  export type CTG$CandidatoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidato
     */
    select?: CandidatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Candidato
     */
    omit?: CandidatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidatoInclude<ExtArgs> | null
    where?: CandidatoWhereInput
    orderBy?: CandidatoOrderByWithRelationInput | CandidatoOrderByWithRelationInput[]
    cursor?: CandidatoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CandidatoScalarFieldEnum | CandidatoScalarFieldEnum[]
  }

  /**
   * CTG without action
   */
  export type CTGDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CTG
     */
    select?: CTGSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CTG
     */
    omit?: CTGOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CTGInclude<ExtArgs> | null
  }


  /**
   * Model RT
   */

  export type AggregateRT = {
    _count: RTCountAggregateOutputType | null
    _avg: RTAvgAggregateOutputType | null
    _sum: RTSumAggregateOutputType | null
    _min: RTMinAggregateOutputType | null
    _max: RTMaxAggregateOutputType | null
  }

  export type RTAvgAggregateOutputType = {
    idRT: number | null
    numeroRT: number | null
  }

  export type RTSumAggregateOutputType = {
    idRT: number | null
    numeroRT: number | null
  }

  export type RTMinAggregateOutputType = {
    idRT: number | null
    nomeRT: string | null
    numeroRT: number | null
  }

  export type RTMaxAggregateOutputType = {
    idRT: number | null
    nomeRT: string | null
    numeroRT: number | null
  }

  export type RTCountAggregateOutputType = {
    idRT: number
    nomeRT: number
    numeroRT: number
    _all: number
  }


  export type RTAvgAggregateInputType = {
    idRT?: true
    numeroRT?: true
  }

  export type RTSumAggregateInputType = {
    idRT?: true
    numeroRT?: true
  }

  export type RTMinAggregateInputType = {
    idRT?: true
    nomeRT?: true
    numeroRT?: true
  }

  export type RTMaxAggregateInputType = {
    idRT?: true
    nomeRT?: true
    numeroRT?: true
  }

  export type RTCountAggregateInputType = {
    idRT?: true
    nomeRT?: true
    numeroRT?: true
    _all?: true
  }

  export type RTAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RT to aggregate.
     */
    where?: RTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RTS to fetch.
     */
    orderBy?: RTOrderByWithRelationInput | RTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RTS
    **/
    _count?: true | RTCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RTAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RTSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RTMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RTMaxAggregateInputType
  }

  export type GetRTAggregateType<T extends RTAggregateArgs> = {
        [P in keyof T & keyof AggregateRT]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRT[P]>
      : GetScalarType<T[P], AggregateRT[P]>
  }




  export type RTGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RTWhereInput
    orderBy?: RTOrderByWithAggregationInput | RTOrderByWithAggregationInput[]
    by: RTScalarFieldEnum[] | RTScalarFieldEnum
    having?: RTScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RTCountAggregateInputType | true
    _avg?: RTAvgAggregateInputType
    _sum?: RTSumAggregateInputType
    _min?: RTMinAggregateInputType
    _max?: RTMaxAggregateInputType
  }

  export type RTGroupByOutputType = {
    idRT: number
    nomeRT: string
    numeroRT: number | null
    _count: RTCountAggregateOutputType | null
    _avg: RTAvgAggregateOutputType | null
    _sum: RTSumAggregateOutputType | null
    _min: RTMinAggregateOutputType | null
    _max: RTMaxAggregateOutputType | null
  }

  type GetRTGroupByPayload<T extends RTGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RTGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RTGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RTGroupByOutputType[P]>
            : GetScalarType<T[P], RTGroupByOutputType[P]>
        }
      >
    >


  export type RTSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idRT?: boolean
    nomeRT?: boolean
    numeroRT?: boolean
    CTGs?: boolean | RT$CTGsArgs<ExtArgs>
    _count?: boolean | RTCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rT"]>

  export type RTSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idRT?: boolean
    nomeRT?: boolean
    numeroRT?: boolean
  }, ExtArgs["result"]["rT"]>

  export type RTSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idRT?: boolean
    nomeRT?: boolean
    numeroRT?: boolean
  }, ExtArgs["result"]["rT"]>

  export type RTSelectScalar = {
    idRT?: boolean
    nomeRT?: boolean
    numeroRT?: boolean
  }

  export type RTOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idRT" | "nomeRT" | "numeroRT", ExtArgs["result"]["rT"]>
  export type RTInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CTGs?: boolean | RT$CTGsArgs<ExtArgs>
    _count?: boolean | RTCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RTIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RTIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RTPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RT"
    objects: {
      CTGs: Prisma.$CTGPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idRT: number
      nomeRT: string
      numeroRT: number | null
    }, ExtArgs["result"]["rT"]>
    composites: {}
  }

  type RTGetPayload<S extends boolean | null | undefined | RTDefaultArgs> = $Result.GetResult<Prisma.$RTPayload, S>

  type RTCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RTFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RTCountAggregateInputType | true
    }

  export interface RTDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RT'], meta: { name: 'RT' } }
    /**
     * Find zero or one RT that matches the filter.
     * @param {RTFindUniqueArgs} args - Arguments to find a RT
     * @example
     * // Get one RT
     * const rT = await prisma.rT.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RTFindUniqueArgs>(args: SelectSubset<T, RTFindUniqueArgs<ExtArgs>>): Prisma__RTClient<$Result.GetResult<Prisma.$RTPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RT that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RTFindUniqueOrThrowArgs} args - Arguments to find a RT
     * @example
     * // Get one RT
     * const rT = await prisma.rT.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RTFindUniqueOrThrowArgs>(args: SelectSubset<T, RTFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RTClient<$Result.GetResult<Prisma.$RTPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RT that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RTFindFirstArgs} args - Arguments to find a RT
     * @example
     * // Get one RT
     * const rT = await prisma.rT.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RTFindFirstArgs>(args?: SelectSubset<T, RTFindFirstArgs<ExtArgs>>): Prisma__RTClient<$Result.GetResult<Prisma.$RTPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RT that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RTFindFirstOrThrowArgs} args - Arguments to find a RT
     * @example
     * // Get one RT
     * const rT = await prisma.rT.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RTFindFirstOrThrowArgs>(args?: SelectSubset<T, RTFindFirstOrThrowArgs<ExtArgs>>): Prisma__RTClient<$Result.GetResult<Prisma.$RTPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RTS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RTFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RTS
     * const rTS = await prisma.rT.findMany()
     * 
     * // Get first 10 RTS
     * const rTS = await prisma.rT.findMany({ take: 10 })
     * 
     * // Only select the `idRT`
     * const rTWithIdRTOnly = await prisma.rT.findMany({ select: { idRT: true } })
     * 
     */
    findMany<T extends RTFindManyArgs>(args?: SelectSubset<T, RTFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RTPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RT.
     * @param {RTCreateArgs} args - Arguments to create a RT.
     * @example
     * // Create one RT
     * const RT = await prisma.rT.create({
     *   data: {
     *     // ... data to create a RT
     *   }
     * })
     * 
     */
    create<T extends RTCreateArgs>(args: SelectSubset<T, RTCreateArgs<ExtArgs>>): Prisma__RTClient<$Result.GetResult<Prisma.$RTPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RTS.
     * @param {RTCreateManyArgs} args - Arguments to create many RTS.
     * @example
     * // Create many RTS
     * const rT = await prisma.rT.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RTCreateManyArgs>(args?: SelectSubset<T, RTCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RTS and returns the data saved in the database.
     * @param {RTCreateManyAndReturnArgs} args - Arguments to create many RTS.
     * @example
     * // Create many RTS
     * const rT = await prisma.rT.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RTS and only return the `idRT`
     * const rTWithIdRTOnly = await prisma.rT.createManyAndReturn({
     *   select: { idRT: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RTCreateManyAndReturnArgs>(args?: SelectSubset<T, RTCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RTPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RT.
     * @param {RTDeleteArgs} args - Arguments to delete one RT.
     * @example
     * // Delete one RT
     * const RT = await prisma.rT.delete({
     *   where: {
     *     // ... filter to delete one RT
     *   }
     * })
     * 
     */
    delete<T extends RTDeleteArgs>(args: SelectSubset<T, RTDeleteArgs<ExtArgs>>): Prisma__RTClient<$Result.GetResult<Prisma.$RTPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RT.
     * @param {RTUpdateArgs} args - Arguments to update one RT.
     * @example
     * // Update one RT
     * const rT = await prisma.rT.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RTUpdateArgs>(args: SelectSubset<T, RTUpdateArgs<ExtArgs>>): Prisma__RTClient<$Result.GetResult<Prisma.$RTPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RTS.
     * @param {RTDeleteManyArgs} args - Arguments to filter RTS to delete.
     * @example
     * // Delete a few RTS
     * const { count } = await prisma.rT.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RTDeleteManyArgs>(args?: SelectSubset<T, RTDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RTUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RTS
     * const rT = await prisma.rT.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RTUpdateManyArgs>(args: SelectSubset<T, RTUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RTS and returns the data updated in the database.
     * @param {RTUpdateManyAndReturnArgs} args - Arguments to update many RTS.
     * @example
     * // Update many RTS
     * const rT = await prisma.rT.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RTS and only return the `idRT`
     * const rTWithIdRTOnly = await prisma.rT.updateManyAndReturn({
     *   select: { idRT: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RTUpdateManyAndReturnArgs>(args: SelectSubset<T, RTUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RTPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RT.
     * @param {RTUpsertArgs} args - Arguments to update or create a RT.
     * @example
     * // Update or create a RT
     * const rT = await prisma.rT.upsert({
     *   create: {
     *     // ... data to create a RT
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RT we want to update
     *   }
     * })
     */
    upsert<T extends RTUpsertArgs>(args: SelectSubset<T, RTUpsertArgs<ExtArgs>>): Prisma__RTClient<$Result.GetResult<Prisma.$RTPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RTCountArgs} args - Arguments to filter RTS to count.
     * @example
     * // Count the number of RTS
     * const count = await prisma.rT.count({
     *   where: {
     *     // ... the filter for the RTS we want to count
     *   }
     * })
    **/
    count<T extends RTCountArgs>(
      args?: Subset<T, RTCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RTCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RTAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RTAggregateArgs>(args: Subset<T, RTAggregateArgs>): Prisma.PrismaPromise<GetRTAggregateType<T>>

    /**
     * Group by RT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RTGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RTGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RTGroupByArgs['orderBy'] }
        : { orderBy?: RTGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RTGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRTGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RT model
   */
  readonly fields: RTFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RT.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RTClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CTGs<T extends RT$CTGsArgs<ExtArgs> = {}>(args?: Subset<T, RT$CTGsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CTGPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RT model
   */
  interface RTFieldRefs {
    readonly idRT: FieldRef<"RT", 'Int'>
    readonly nomeRT: FieldRef<"RT", 'String'>
    readonly numeroRT: FieldRef<"RT", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RT findUnique
   */
  export type RTFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RT
     */
    select?: RTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RT
     */
    omit?: RTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RTInclude<ExtArgs> | null
    /**
     * Filter, which RT to fetch.
     */
    where: RTWhereUniqueInput
  }

  /**
   * RT findUniqueOrThrow
   */
  export type RTFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RT
     */
    select?: RTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RT
     */
    omit?: RTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RTInclude<ExtArgs> | null
    /**
     * Filter, which RT to fetch.
     */
    where: RTWhereUniqueInput
  }

  /**
   * RT findFirst
   */
  export type RTFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RT
     */
    select?: RTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RT
     */
    omit?: RTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RTInclude<ExtArgs> | null
    /**
     * Filter, which RT to fetch.
     */
    where?: RTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RTS to fetch.
     */
    orderBy?: RTOrderByWithRelationInput | RTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RTS.
     */
    cursor?: RTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RTS.
     */
    distinct?: RTScalarFieldEnum | RTScalarFieldEnum[]
  }

  /**
   * RT findFirstOrThrow
   */
  export type RTFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RT
     */
    select?: RTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RT
     */
    omit?: RTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RTInclude<ExtArgs> | null
    /**
     * Filter, which RT to fetch.
     */
    where?: RTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RTS to fetch.
     */
    orderBy?: RTOrderByWithRelationInput | RTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RTS.
     */
    cursor?: RTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RTS.
     */
    distinct?: RTScalarFieldEnum | RTScalarFieldEnum[]
  }

  /**
   * RT findMany
   */
  export type RTFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RT
     */
    select?: RTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RT
     */
    omit?: RTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RTInclude<ExtArgs> | null
    /**
     * Filter, which RTS to fetch.
     */
    where?: RTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RTS to fetch.
     */
    orderBy?: RTOrderByWithRelationInput | RTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RTS.
     */
    cursor?: RTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RTS.
     */
    skip?: number
    distinct?: RTScalarFieldEnum | RTScalarFieldEnum[]
  }

  /**
   * RT create
   */
  export type RTCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RT
     */
    select?: RTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RT
     */
    omit?: RTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RTInclude<ExtArgs> | null
    /**
     * The data needed to create a RT.
     */
    data: XOR<RTCreateInput, RTUncheckedCreateInput>
  }

  /**
   * RT createMany
   */
  export type RTCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RTS.
     */
    data: RTCreateManyInput | RTCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RT createManyAndReturn
   */
  export type RTCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RT
     */
    select?: RTSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RT
     */
    omit?: RTOmit<ExtArgs> | null
    /**
     * The data used to create many RTS.
     */
    data: RTCreateManyInput | RTCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RT update
   */
  export type RTUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RT
     */
    select?: RTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RT
     */
    omit?: RTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RTInclude<ExtArgs> | null
    /**
     * The data needed to update a RT.
     */
    data: XOR<RTUpdateInput, RTUncheckedUpdateInput>
    /**
     * Choose, which RT to update.
     */
    where: RTWhereUniqueInput
  }

  /**
   * RT updateMany
   */
  export type RTUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RTS.
     */
    data: XOR<RTUpdateManyMutationInput, RTUncheckedUpdateManyInput>
    /**
     * Filter which RTS to update
     */
    where?: RTWhereInput
    /**
     * Limit how many RTS to update.
     */
    limit?: number
  }

  /**
   * RT updateManyAndReturn
   */
  export type RTUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RT
     */
    select?: RTSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RT
     */
    omit?: RTOmit<ExtArgs> | null
    /**
     * The data used to update RTS.
     */
    data: XOR<RTUpdateManyMutationInput, RTUncheckedUpdateManyInput>
    /**
     * Filter which RTS to update
     */
    where?: RTWhereInput
    /**
     * Limit how many RTS to update.
     */
    limit?: number
  }

  /**
   * RT upsert
   */
  export type RTUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RT
     */
    select?: RTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RT
     */
    omit?: RTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RTInclude<ExtArgs> | null
    /**
     * The filter to search for the RT to update in case it exists.
     */
    where: RTWhereUniqueInput
    /**
     * In case the RT found by the `where` argument doesn't exist, create a new RT with this data.
     */
    create: XOR<RTCreateInput, RTUncheckedCreateInput>
    /**
     * In case the RT was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RTUpdateInput, RTUncheckedUpdateInput>
  }

  /**
   * RT delete
   */
  export type RTDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RT
     */
    select?: RTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RT
     */
    omit?: RTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RTInclude<ExtArgs> | null
    /**
     * Filter which RT to delete.
     */
    where: RTWhereUniqueInput
  }

  /**
   * RT deleteMany
   */
  export type RTDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RTS to delete
     */
    where?: RTWhereInput
    /**
     * Limit how many RTS to delete.
     */
    limit?: number
  }

  /**
   * RT.CTGs
   */
  export type RT$CTGsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CTG
     */
    select?: CTGSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CTG
     */
    omit?: CTGOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CTGInclude<ExtArgs> | null
    where?: CTGWhereInput
    orderBy?: CTGOrderByWithRelationInput | CTGOrderByWithRelationInput[]
    cursor?: CTGWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CTGScalarFieldEnum | CTGScalarFieldEnum[]
  }

  /**
   * RT without action
   */
  export type RTDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RT
     */
    select?: RTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RT
     */
    omit?: RTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RTInclude<ExtArgs> | null
  }


  /**
   * Model PreferenciaSorteioDanca
   */

  export type AggregatePreferenciaSorteioDanca = {
    _count: PreferenciaSorteioDancaCountAggregateOutputType | null
    _avg: PreferenciaSorteioDancaAvgAggregateOutputType | null
    _sum: PreferenciaSorteioDancaSumAggregateOutputType | null
    _min: PreferenciaSorteioDancaMinAggregateOutputType | null
    _max: PreferenciaSorteioDancaMaxAggregateOutputType | null
  }

  export type PreferenciaSorteioDancaAvgAggregateOutputType = {
    idPreferencia: number | null
    candidatoId: number | null
    sorteioDancaId: number | null
  }

  export type PreferenciaSorteioDancaSumAggregateOutputType = {
    idPreferencia: number | null
    candidatoId: number | null
    sorteioDancaId: number | null
  }

  export type PreferenciaSorteioDancaMinAggregateOutputType = {
    idPreferencia: number | null
    nomeSorteioDanca: $Enums.DancaSalaoTradicional | null
    candidatoId: number | null
    sorteioDancaId: number | null
  }

  export type PreferenciaSorteioDancaMaxAggregateOutputType = {
    idPreferencia: number | null
    nomeSorteioDanca: $Enums.DancaSalaoTradicional | null
    candidatoId: number | null
    sorteioDancaId: number | null
  }

  export type PreferenciaSorteioDancaCountAggregateOutputType = {
    idPreferencia: number
    nomeSorteioDanca: number
    candidatoId: number
    sorteioDancaId: number
    _all: number
  }


  export type PreferenciaSorteioDancaAvgAggregateInputType = {
    idPreferencia?: true
    candidatoId?: true
    sorteioDancaId?: true
  }

  export type PreferenciaSorteioDancaSumAggregateInputType = {
    idPreferencia?: true
    candidatoId?: true
    sorteioDancaId?: true
  }

  export type PreferenciaSorteioDancaMinAggregateInputType = {
    idPreferencia?: true
    nomeSorteioDanca?: true
    candidatoId?: true
    sorteioDancaId?: true
  }

  export type PreferenciaSorteioDancaMaxAggregateInputType = {
    idPreferencia?: true
    nomeSorteioDanca?: true
    candidatoId?: true
    sorteioDancaId?: true
  }

  export type PreferenciaSorteioDancaCountAggregateInputType = {
    idPreferencia?: true
    nomeSorteioDanca?: true
    candidatoId?: true
    sorteioDancaId?: true
    _all?: true
  }

  export type PreferenciaSorteioDancaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PreferenciaSorteioDanca to aggregate.
     */
    where?: PreferenciaSorteioDancaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PreferenciaSorteioDancas to fetch.
     */
    orderBy?: PreferenciaSorteioDancaOrderByWithRelationInput | PreferenciaSorteioDancaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PreferenciaSorteioDancaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PreferenciaSorteioDancas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PreferenciaSorteioDancas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PreferenciaSorteioDancas
    **/
    _count?: true | PreferenciaSorteioDancaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PreferenciaSorteioDancaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PreferenciaSorteioDancaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PreferenciaSorteioDancaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PreferenciaSorteioDancaMaxAggregateInputType
  }

  export type GetPreferenciaSorteioDancaAggregateType<T extends PreferenciaSorteioDancaAggregateArgs> = {
        [P in keyof T & keyof AggregatePreferenciaSorteioDanca]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePreferenciaSorteioDanca[P]>
      : GetScalarType<T[P], AggregatePreferenciaSorteioDanca[P]>
  }




  export type PreferenciaSorteioDancaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PreferenciaSorteioDancaWhereInput
    orderBy?: PreferenciaSorteioDancaOrderByWithAggregationInput | PreferenciaSorteioDancaOrderByWithAggregationInput[]
    by: PreferenciaSorteioDancaScalarFieldEnum[] | PreferenciaSorteioDancaScalarFieldEnum
    having?: PreferenciaSorteioDancaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PreferenciaSorteioDancaCountAggregateInputType | true
    _avg?: PreferenciaSorteioDancaAvgAggregateInputType
    _sum?: PreferenciaSorteioDancaSumAggregateInputType
    _min?: PreferenciaSorteioDancaMinAggregateInputType
    _max?: PreferenciaSorteioDancaMaxAggregateInputType
  }

  export type PreferenciaSorteioDancaGroupByOutputType = {
    idPreferencia: number
    nomeSorteioDanca: $Enums.DancaSalaoTradicional
    candidatoId: number
    sorteioDancaId: number | null
    _count: PreferenciaSorteioDancaCountAggregateOutputType | null
    _avg: PreferenciaSorteioDancaAvgAggregateOutputType | null
    _sum: PreferenciaSorteioDancaSumAggregateOutputType | null
    _min: PreferenciaSorteioDancaMinAggregateOutputType | null
    _max: PreferenciaSorteioDancaMaxAggregateOutputType | null
  }

  type GetPreferenciaSorteioDancaGroupByPayload<T extends PreferenciaSorteioDancaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PreferenciaSorteioDancaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PreferenciaSorteioDancaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PreferenciaSorteioDancaGroupByOutputType[P]>
            : GetScalarType<T[P], PreferenciaSorteioDancaGroupByOutputType[P]>
        }
      >
    >


  export type PreferenciaSorteioDancaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idPreferencia?: boolean
    nomeSorteioDanca?: boolean
    candidatoId?: boolean
    sorteioDancaId?: boolean
    Candidato?: boolean | CandidatoDefaultArgs<ExtArgs>
    SorteioDanca?: boolean | PreferenciaSorteioDanca$SorteioDancaArgs<ExtArgs>
    quesitos?: boolean | PreferenciaSorteioDanca$quesitosArgs<ExtArgs>
    _count?: boolean | PreferenciaSorteioDancaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["preferenciaSorteioDanca"]>

  export type PreferenciaSorteioDancaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idPreferencia?: boolean
    nomeSorteioDanca?: boolean
    candidatoId?: boolean
    sorteioDancaId?: boolean
    Candidato?: boolean | CandidatoDefaultArgs<ExtArgs>
    SorteioDanca?: boolean | PreferenciaSorteioDanca$SorteioDancaArgs<ExtArgs>
  }, ExtArgs["result"]["preferenciaSorteioDanca"]>

  export type PreferenciaSorteioDancaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idPreferencia?: boolean
    nomeSorteioDanca?: boolean
    candidatoId?: boolean
    sorteioDancaId?: boolean
    Candidato?: boolean | CandidatoDefaultArgs<ExtArgs>
    SorteioDanca?: boolean | PreferenciaSorteioDanca$SorteioDancaArgs<ExtArgs>
  }, ExtArgs["result"]["preferenciaSorteioDanca"]>

  export type PreferenciaSorteioDancaSelectScalar = {
    idPreferencia?: boolean
    nomeSorteioDanca?: boolean
    candidatoId?: boolean
    sorteioDancaId?: boolean
  }

  export type PreferenciaSorteioDancaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idPreferencia" | "nomeSorteioDanca" | "candidatoId" | "sorteioDancaId", ExtArgs["result"]["preferenciaSorteioDanca"]>
  export type PreferenciaSorteioDancaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Candidato?: boolean | CandidatoDefaultArgs<ExtArgs>
    SorteioDanca?: boolean | PreferenciaSorteioDanca$SorteioDancaArgs<ExtArgs>
    quesitos?: boolean | PreferenciaSorteioDanca$quesitosArgs<ExtArgs>
    _count?: boolean | PreferenciaSorteioDancaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PreferenciaSorteioDancaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Candidato?: boolean | CandidatoDefaultArgs<ExtArgs>
    SorteioDanca?: boolean | PreferenciaSorteioDanca$SorteioDancaArgs<ExtArgs>
  }
  export type PreferenciaSorteioDancaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Candidato?: boolean | CandidatoDefaultArgs<ExtArgs>
    SorteioDanca?: boolean | PreferenciaSorteioDanca$SorteioDancaArgs<ExtArgs>
  }

  export type $PreferenciaSorteioDancaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PreferenciaSorteioDanca"
    objects: {
      Candidato: Prisma.$CandidatoPayload<ExtArgs>
      SorteioDanca: Prisma.$SorteioDancaPayload<ExtArgs> | null
      quesitos: Prisma.$QuesitosPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idPreferencia: number
      nomeSorteioDanca: $Enums.DancaSalaoTradicional
      candidatoId: number
      sorteioDancaId: number | null
    }, ExtArgs["result"]["preferenciaSorteioDanca"]>
    composites: {}
  }

  type PreferenciaSorteioDancaGetPayload<S extends boolean | null | undefined | PreferenciaSorteioDancaDefaultArgs> = $Result.GetResult<Prisma.$PreferenciaSorteioDancaPayload, S>

  type PreferenciaSorteioDancaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PreferenciaSorteioDancaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PreferenciaSorteioDancaCountAggregateInputType | true
    }

  export interface PreferenciaSorteioDancaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PreferenciaSorteioDanca'], meta: { name: 'PreferenciaSorteioDanca' } }
    /**
     * Find zero or one PreferenciaSorteioDanca that matches the filter.
     * @param {PreferenciaSorteioDancaFindUniqueArgs} args - Arguments to find a PreferenciaSorteioDanca
     * @example
     * // Get one PreferenciaSorteioDanca
     * const preferenciaSorteioDanca = await prisma.preferenciaSorteioDanca.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PreferenciaSorteioDancaFindUniqueArgs>(args: SelectSubset<T, PreferenciaSorteioDancaFindUniqueArgs<ExtArgs>>): Prisma__PreferenciaSorteioDancaClient<$Result.GetResult<Prisma.$PreferenciaSorteioDancaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PreferenciaSorteioDanca that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PreferenciaSorteioDancaFindUniqueOrThrowArgs} args - Arguments to find a PreferenciaSorteioDanca
     * @example
     * // Get one PreferenciaSorteioDanca
     * const preferenciaSorteioDanca = await prisma.preferenciaSorteioDanca.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PreferenciaSorteioDancaFindUniqueOrThrowArgs>(args: SelectSubset<T, PreferenciaSorteioDancaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PreferenciaSorteioDancaClient<$Result.GetResult<Prisma.$PreferenciaSorteioDancaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PreferenciaSorteioDanca that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferenciaSorteioDancaFindFirstArgs} args - Arguments to find a PreferenciaSorteioDanca
     * @example
     * // Get one PreferenciaSorteioDanca
     * const preferenciaSorteioDanca = await prisma.preferenciaSorteioDanca.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PreferenciaSorteioDancaFindFirstArgs>(args?: SelectSubset<T, PreferenciaSorteioDancaFindFirstArgs<ExtArgs>>): Prisma__PreferenciaSorteioDancaClient<$Result.GetResult<Prisma.$PreferenciaSorteioDancaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PreferenciaSorteioDanca that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferenciaSorteioDancaFindFirstOrThrowArgs} args - Arguments to find a PreferenciaSorteioDanca
     * @example
     * // Get one PreferenciaSorteioDanca
     * const preferenciaSorteioDanca = await prisma.preferenciaSorteioDanca.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PreferenciaSorteioDancaFindFirstOrThrowArgs>(args?: SelectSubset<T, PreferenciaSorteioDancaFindFirstOrThrowArgs<ExtArgs>>): Prisma__PreferenciaSorteioDancaClient<$Result.GetResult<Prisma.$PreferenciaSorteioDancaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PreferenciaSorteioDancas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferenciaSorteioDancaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PreferenciaSorteioDancas
     * const preferenciaSorteioDancas = await prisma.preferenciaSorteioDanca.findMany()
     * 
     * // Get first 10 PreferenciaSorteioDancas
     * const preferenciaSorteioDancas = await prisma.preferenciaSorteioDanca.findMany({ take: 10 })
     * 
     * // Only select the `idPreferencia`
     * const preferenciaSorteioDancaWithIdPreferenciaOnly = await prisma.preferenciaSorteioDanca.findMany({ select: { idPreferencia: true } })
     * 
     */
    findMany<T extends PreferenciaSorteioDancaFindManyArgs>(args?: SelectSubset<T, PreferenciaSorteioDancaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreferenciaSorteioDancaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PreferenciaSorteioDanca.
     * @param {PreferenciaSorteioDancaCreateArgs} args - Arguments to create a PreferenciaSorteioDanca.
     * @example
     * // Create one PreferenciaSorteioDanca
     * const PreferenciaSorteioDanca = await prisma.preferenciaSorteioDanca.create({
     *   data: {
     *     // ... data to create a PreferenciaSorteioDanca
     *   }
     * })
     * 
     */
    create<T extends PreferenciaSorteioDancaCreateArgs>(args: SelectSubset<T, PreferenciaSorteioDancaCreateArgs<ExtArgs>>): Prisma__PreferenciaSorteioDancaClient<$Result.GetResult<Prisma.$PreferenciaSorteioDancaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PreferenciaSorteioDancas.
     * @param {PreferenciaSorteioDancaCreateManyArgs} args - Arguments to create many PreferenciaSorteioDancas.
     * @example
     * // Create many PreferenciaSorteioDancas
     * const preferenciaSorteioDanca = await prisma.preferenciaSorteioDanca.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PreferenciaSorteioDancaCreateManyArgs>(args?: SelectSubset<T, PreferenciaSorteioDancaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PreferenciaSorteioDancas and returns the data saved in the database.
     * @param {PreferenciaSorteioDancaCreateManyAndReturnArgs} args - Arguments to create many PreferenciaSorteioDancas.
     * @example
     * // Create many PreferenciaSorteioDancas
     * const preferenciaSorteioDanca = await prisma.preferenciaSorteioDanca.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PreferenciaSorteioDancas and only return the `idPreferencia`
     * const preferenciaSorteioDancaWithIdPreferenciaOnly = await prisma.preferenciaSorteioDanca.createManyAndReturn({
     *   select: { idPreferencia: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PreferenciaSorteioDancaCreateManyAndReturnArgs>(args?: SelectSubset<T, PreferenciaSorteioDancaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreferenciaSorteioDancaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PreferenciaSorteioDanca.
     * @param {PreferenciaSorteioDancaDeleteArgs} args - Arguments to delete one PreferenciaSorteioDanca.
     * @example
     * // Delete one PreferenciaSorteioDanca
     * const PreferenciaSorteioDanca = await prisma.preferenciaSorteioDanca.delete({
     *   where: {
     *     // ... filter to delete one PreferenciaSorteioDanca
     *   }
     * })
     * 
     */
    delete<T extends PreferenciaSorteioDancaDeleteArgs>(args: SelectSubset<T, PreferenciaSorteioDancaDeleteArgs<ExtArgs>>): Prisma__PreferenciaSorteioDancaClient<$Result.GetResult<Prisma.$PreferenciaSorteioDancaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PreferenciaSorteioDanca.
     * @param {PreferenciaSorteioDancaUpdateArgs} args - Arguments to update one PreferenciaSorteioDanca.
     * @example
     * // Update one PreferenciaSorteioDanca
     * const preferenciaSorteioDanca = await prisma.preferenciaSorteioDanca.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PreferenciaSorteioDancaUpdateArgs>(args: SelectSubset<T, PreferenciaSorteioDancaUpdateArgs<ExtArgs>>): Prisma__PreferenciaSorteioDancaClient<$Result.GetResult<Prisma.$PreferenciaSorteioDancaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PreferenciaSorteioDancas.
     * @param {PreferenciaSorteioDancaDeleteManyArgs} args - Arguments to filter PreferenciaSorteioDancas to delete.
     * @example
     * // Delete a few PreferenciaSorteioDancas
     * const { count } = await prisma.preferenciaSorteioDanca.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PreferenciaSorteioDancaDeleteManyArgs>(args?: SelectSubset<T, PreferenciaSorteioDancaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PreferenciaSorteioDancas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferenciaSorteioDancaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PreferenciaSorteioDancas
     * const preferenciaSorteioDanca = await prisma.preferenciaSorteioDanca.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PreferenciaSorteioDancaUpdateManyArgs>(args: SelectSubset<T, PreferenciaSorteioDancaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PreferenciaSorteioDancas and returns the data updated in the database.
     * @param {PreferenciaSorteioDancaUpdateManyAndReturnArgs} args - Arguments to update many PreferenciaSorteioDancas.
     * @example
     * // Update many PreferenciaSorteioDancas
     * const preferenciaSorteioDanca = await prisma.preferenciaSorteioDanca.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PreferenciaSorteioDancas and only return the `idPreferencia`
     * const preferenciaSorteioDancaWithIdPreferenciaOnly = await prisma.preferenciaSorteioDanca.updateManyAndReturn({
     *   select: { idPreferencia: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PreferenciaSorteioDancaUpdateManyAndReturnArgs>(args: SelectSubset<T, PreferenciaSorteioDancaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreferenciaSorteioDancaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PreferenciaSorteioDanca.
     * @param {PreferenciaSorteioDancaUpsertArgs} args - Arguments to update or create a PreferenciaSorteioDanca.
     * @example
     * // Update or create a PreferenciaSorteioDanca
     * const preferenciaSorteioDanca = await prisma.preferenciaSorteioDanca.upsert({
     *   create: {
     *     // ... data to create a PreferenciaSorteioDanca
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PreferenciaSorteioDanca we want to update
     *   }
     * })
     */
    upsert<T extends PreferenciaSorteioDancaUpsertArgs>(args: SelectSubset<T, PreferenciaSorteioDancaUpsertArgs<ExtArgs>>): Prisma__PreferenciaSorteioDancaClient<$Result.GetResult<Prisma.$PreferenciaSorteioDancaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PreferenciaSorteioDancas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferenciaSorteioDancaCountArgs} args - Arguments to filter PreferenciaSorteioDancas to count.
     * @example
     * // Count the number of PreferenciaSorteioDancas
     * const count = await prisma.preferenciaSorteioDanca.count({
     *   where: {
     *     // ... the filter for the PreferenciaSorteioDancas we want to count
     *   }
     * })
    **/
    count<T extends PreferenciaSorteioDancaCountArgs>(
      args?: Subset<T, PreferenciaSorteioDancaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PreferenciaSorteioDancaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PreferenciaSorteioDanca.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferenciaSorteioDancaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PreferenciaSorteioDancaAggregateArgs>(args: Subset<T, PreferenciaSorteioDancaAggregateArgs>): Prisma.PrismaPromise<GetPreferenciaSorteioDancaAggregateType<T>>

    /**
     * Group by PreferenciaSorteioDanca.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreferenciaSorteioDancaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PreferenciaSorteioDancaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PreferenciaSorteioDancaGroupByArgs['orderBy'] }
        : { orderBy?: PreferenciaSorteioDancaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PreferenciaSorteioDancaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPreferenciaSorteioDancaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PreferenciaSorteioDanca model
   */
  readonly fields: PreferenciaSorteioDancaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PreferenciaSorteioDanca.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PreferenciaSorteioDancaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Candidato<T extends CandidatoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CandidatoDefaultArgs<ExtArgs>>): Prisma__CandidatoClient<$Result.GetResult<Prisma.$CandidatoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    SorteioDanca<T extends PreferenciaSorteioDanca$SorteioDancaArgs<ExtArgs> = {}>(args?: Subset<T, PreferenciaSorteioDanca$SorteioDancaArgs<ExtArgs>>): Prisma__SorteioDancaClient<$Result.GetResult<Prisma.$SorteioDancaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    quesitos<T extends PreferenciaSorteioDanca$quesitosArgs<ExtArgs> = {}>(args?: Subset<T, PreferenciaSorteioDanca$quesitosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuesitosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PreferenciaSorteioDanca model
   */
  interface PreferenciaSorteioDancaFieldRefs {
    readonly idPreferencia: FieldRef<"PreferenciaSorteioDanca", 'Int'>
    readonly nomeSorteioDanca: FieldRef<"PreferenciaSorteioDanca", 'DancaSalaoTradicional'>
    readonly candidatoId: FieldRef<"PreferenciaSorteioDanca", 'Int'>
    readonly sorteioDancaId: FieldRef<"PreferenciaSorteioDanca", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PreferenciaSorteioDanca findUnique
   */
  export type PreferenciaSorteioDancaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferenciaSorteioDanca
     */
    select?: PreferenciaSorteioDancaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreferenciaSorteioDanca
     */
    omit?: PreferenciaSorteioDancaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferenciaSorteioDancaInclude<ExtArgs> | null
    /**
     * Filter, which PreferenciaSorteioDanca to fetch.
     */
    where: PreferenciaSorteioDancaWhereUniqueInput
  }

  /**
   * PreferenciaSorteioDanca findUniqueOrThrow
   */
  export type PreferenciaSorteioDancaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferenciaSorteioDanca
     */
    select?: PreferenciaSorteioDancaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreferenciaSorteioDanca
     */
    omit?: PreferenciaSorteioDancaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferenciaSorteioDancaInclude<ExtArgs> | null
    /**
     * Filter, which PreferenciaSorteioDanca to fetch.
     */
    where: PreferenciaSorteioDancaWhereUniqueInput
  }

  /**
   * PreferenciaSorteioDanca findFirst
   */
  export type PreferenciaSorteioDancaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferenciaSorteioDanca
     */
    select?: PreferenciaSorteioDancaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreferenciaSorteioDanca
     */
    omit?: PreferenciaSorteioDancaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferenciaSorteioDancaInclude<ExtArgs> | null
    /**
     * Filter, which PreferenciaSorteioDanca to fetch.
     */
    where?: PreferenciaSorteioDancaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PreferenciaSorteioDancas to fetch.
     */
    orderBy?: PreferenciaSorteioDancaOrderByWithRelationInput | PreferenciaSorteioDancaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PreferenciaSorteioDancas.
     */
    cursor?: PreferenciaSorteioDancaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PreferenciaSorteioDancas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PreferenciaSorteioDancas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PreferenciaSorteioDancas.
     */
    distinct?: PreferenciaSorteioDancaScalarFieldEnum | PreferenciaSorteioDancaScalarFieldEnum[]
  }

  /**
   * PreferenciaSorteioDanca findFirstOrThrow
   */
  export type PreferenciaSorteioDancaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferenciaSorteioDanca
     */
    select?: PreferenciaSorteioDancaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreferenciaSorteioDanca
     */
    omit?: PreferenciaSorteioDancaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferenciaSorteioDancaInclude<ExtArgs> | null
    /**
     * Filter, which PreferenciaSorteioDanca to fetch.
     */
    where?: PreferenciaSorteioDancaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PreferenciaSorteioDancas to fetch.
     */
    orderBy?: PreferenciaSorteioDancaOrderByWithRelationInput | PreferenciaSorteioDancaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PreferenciaSorteioDancas.
     */
    cursor?: PreferenciaSorteioDancaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PreferenciaSorteioDancas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PreferenciaSorteioDancas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PreferenciaSorteioDancas.
     */
    distinct?: PreferenciaSorteioDancaScalarFieldEnum | PreferenciaSorteioDancaScalarFieldEnum[]
  }

  /**
   * PreferenciaSorteioDanca findMany
   */
  export type PreferenciaSorteioDancaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferenciaSorteioDanca
     */
    select?: PreferenciaSorteioDancaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreferenciaSorteioDanca
     */
    omit?: PreferenciaSorteioDancaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferenciaSorteioDancaInclude<ExtArgs> | null
    /**
     * Filter, which PreferenciaSorteioDancas to fetch.
     */
    where?: PreferenciaSorteioDancaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PreferenciaSorteioDancas to fetch.
     */
    orderBy?: PreferenciaSorteioDancaOrderByWithRelationInput | PreferenciaSorteioDancaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PreferenciaSorteioDancas.
     */
    cursor?: PreferenciaSorteioDancaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PreferenciaSorteioDancas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PreferenciaSorteioDancas.
     */
    skip?: number
    distinct?: PreferenciaSorteioDancaScalarFieldEnum | PreferenciaSorteioDancaScalarFieldEnum[]
  }

  /**
   * PreferenciaSorteioDanca create
   */
  export type PreferenciaSorteioDancaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferenciaSorteioDanca
     */
    select?: PreferenciaSorteioDancaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreferenciaSorteioDanca
     */
    omit?: PreferenciaSorteioDancaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferenciaSorteioDancaInclude<ExtArgs> | null
    /**
     * The data needed to create a PreferenciaSorteioDanca.
     */
    data: XOR<PreferenciaSorteioDancaCreateInput, PreferenciaSorteioDancaUncheckedCreateInput>
  }

  /**
   * PreferenciaSorteioDanca createMany
   */
  export type PreferenciaSorteioDancaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PreferenciaSorteioDancas.
     */
    data: PreferenciaSorteioDancaCreateManyInput | PreferenciaSorteioDancaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PreferenciaSorteioDanca createManyAndReturn
   */
  export type PreferenciaSorteioDancaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferenciaSorteioDanca
     */
    select?: PreferenciaSorteioDancaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PreferenciaSorteioDanca
     */
    omit?: PreferenciaSorteioDancaOmit<ExtArgs> | null
    /**
     * The data used to create many PreferenciaSorteioDancas.
     */
    data: PreferenciaSorteioDancaCreateManyInput | PreferenciaSorteioDancaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferenciaSorteioDancaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PreferenciaSorteioDanca update
   */
  export type PreferenciaSorteioDancaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferenciaSorteioDanca
     */
    select?: PreferenciaSorteioDancaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreferenciaSorteioDanca
     */
    omit?: PreferenciaSorteioDancaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferenciaSorteioDancaInclude<ExtArgs> | null
    /**
     * The data needed to update a PreferenciaSorteioDanca.
     */
    data: XOR<PreferenciaSorteioDancaUpdateInput, PreferenciaSorteioDancaUncheckedUpdateInput>
    /**
     * Choose, which PreferenciaSorteioDanca to update.
     */
    where: PreferenciaSorteioDancaWhereUniqueInput
  }

  /**
   * PreferenciaSorteioDanca updateMany
   */
  export type PreferenciaSorteioDancaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PreferenciaSorteioDancas.
     */
    data: XOR<PreferenciaSorteioDancaUpdateManyMutationInput, PreferenciaSorteioDancaUncheckedUpdateManyInput>
    /**
     * Filter which PreferenciaSorteioDancas to update
     */
    where?: PreferenciaSorteioDancaWhereInput
    /**
     * Limit how many PreferenciaSorteioDancas to update.
     */
    limit?: number
  }

  /**
   * PreferenciaSorteioDanca updateManyAndReturn
   */
  export type PreferenciaSorteioDancaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferenciaSorteioDanca
     */
    select?: PreferenciaSorteioDancaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PreferenciaSorteioDanca
     */
    omit?: PreferenciaSorteioDancaOmit<ExtArgs> | null
    /**
     * The data used to update PreferenciaSorteioDancas.
     */
    data: XOR<PreferenciaSorteioDancaUpdateManyMutationInput, PreferenciaSorteioDancaUncheckedUpdateManyInput>
    /**
     * Filter which PreferenciaSorteioDancas to update
     */
    where?: PreferenciaSorteioDancaWhereInput
    /**
     * Limit how many PreferenciaSorteioDancas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferenciaSorteioDancaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PreferenciaSorteioDanca upsert
   */
  export type PreferenciaSorteioDancaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferenciaSorteioDanca
     */
    select?: PreferenciaSorteioDancaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreferenciaSorteioDanca
     */
    omit?: PreferenciaSorteioDancaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferenciaSorteioDancaInclude<ExtArgs> | null
    /**
     * The filter to search for the PreferenciaSorteioDanca to update in case it exists.
     */
    where: PreferenciaSorteioDancaWhereUniqueInput
    /**
     * In case the PreferenciaSorteioDanca found by the `where` argument doesn't exist, create a new PreferenciaSorteioDanca with this data.
     */
    create: XOR<PreferenciaSorteioDancaCreateInput, PreferenciaSorteioDancaUncheckedCreateInput>
    /**
     * In case the PreferenciaSorteioDanca was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PreferenciaSorteioDancaUpdateInput, PreferenciaSorteioDancaUncheckedUpdateInput>
  }

  /**
   * PreferenciaSorteioDanca delete
   */
  export type PreferenciaSorteioDancaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferenciaSorteioDanca
     */
    select?: PreferenciaSorteioDancaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreferenciaSorteioDanca
     */
    omit?: PreferenciaSorteioDancaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferenciaSorteioDancaInclude<ExtArgs> | null
    /**
     * Filter which PreferenciaSorteioDanca to delete.
     */
    where: PreferenciaSorteioDancaWhereUniqueInput
  }

  /**
   * PreferenciaSorteioDanca deleteMany
   */
  export type PreferenciaSorteioDancaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PreferenciaSorteioDancas to delete
     */
    where?: PreferenciaSorteioDancaWhereInput
    /**
     * Limit how many PreferenciaSorteioDancas to delete.
     */
    limit?: number
  }

  /**
   * PreferenciaSorteioDanca.SorteioDanca
   */
  export type PreferenciaSorteioDanca$SorteioDancaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SorteioDanca
     */
    select?: SorteioDancaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SorteioDanca
     */
    omit?: SorteioDancaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SorteioDancaInclude<ExtArgs> | null
    where?: SorteioDancaWhereInput
  }

  /**
   * PreferenciaSorteioDanca.quesitos
   */
  export type PreferenciaSorteioDanca$quesitosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quesitos
     */
    select?: QuesitosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quesitos
     */
    omit?: QuesitosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuesitosInclude<ExtArgs> | null
    where?: QuesitosWhereInput
    orderBy?: QuesitosOrderByWithRelationInput | QuesitosOrderByWithRelationInput[]
    cursor?: QuesitosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuesitosScalarFieldEnum | QuesitosScalarFieldEnum[]
  }

  /**
   * PreferenciaSorteioDanca without action
   */
  export type PreferenciaSorteioDancaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferenciaSorteioDanca
     */
    select?: PreferenciaSorteioDancaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreferenciaSorteioDanca
     */
    omit?: PreferenciaSorteioDancaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferenciaSorteioDancaInclude<ExtArgs> | null
  }


  /**
   * Model Concurso
   */

  export type AggregateConcurso = {
    _count: ConcursoCountAggregateOutputType | null
    _avg: ConcursoAvgAggregateOutputType | null
    _sum: ConcursoSumAggregateOutputType | null
    _min: ConcursoMinAggregateOutputType | null
    _max: ConcursoMaxAggregateOutputType | null
  }

  export type ConcursoAvgAggregateOutputType = {
    idConcurso: number | null
  }

  export type ConcursoSumAggregateOutputType = {
    idConcurso: number | null
  }

  export type ConcursoMinAggregateOutputType = {
    idConcurso: number | null
    nomeConcurso: string | null
    lancamentoEdital: Date | null
    inscricoesInicio: Date | null
    inscricoesFinal: Date | null
    dataProvaEscrita: Date | null
    dataProvasPraticas: Date | null
    dataResultado: Date | null
    local: string | null
    anexoEdital: Bytes | null
  }

  export type ConcursoMaxAggregateOutputType = {
    idConcurso: number | null
    nomeConcurso: string | null
    lancamentoEdital: Date | null
    inscricoesInicio: Date | null
    inscricoesFinal: Date | null
    dataProvaEscrita: Date | null
    dataProvasPraticas: Date | null
    dataResultado: Date | null
    local: string | null
    anexoEdital: Bytes | null
  }

  export type ConcursoCountAggregateOutputType = {
    idConcurso: number
    nomeConcurso: number
    lancamentoEdital: number
    inscricoesInicio: number
    inscricoesFinal: number
    dataProvaEscrita: number
    dataProvasPraticas: number
    dataResultado: number
    local: number
    anexoEdital: number
    _all: number
  }


  export type ConcursoAvgAggregateInputType = {
    idConcurso?: true
  }

  export type ConcursoSumAggregateInputType = {
    idConcurso?: true
  }

  export type ConcursoMinAggregateInputType = {
    idConcurso?: true
    nomeConcurso?: true
    lancamentoEdital?: true
    inscricoesInicio?: true
    inscricoesFinal?: true
    dataProvaEscrita?: true
    dataProvasPraticas?: true
    dataResultado?: true
    local?: true
    anexoEdital?: true
  }

  export type ConcursoMaxAggregateInputType = {
    idConcurso?: true
    nomeConcurso?: true
    lancamentoEdital?: true
    inscricoesInicio?: true
    inscricoesFinal?: true
    dataProvaEscrita?: true
    dataProvasPraticas?: true
    dataResultado?: true
    local?: true
    anexoEdital?: true
  }

  export type ConcursoCountAggregateInputType = {
    idConcurso?: true
    nomeConcurso?: true
    lancamentoEdital?: true
    inscricoesInicio?: true
    inscricoesFinal?: true
    dataProvaEscrita?: true
    dataProvasPraticas?: true
    dataResultado?: true
    local?: true
    anexoEdital?: true
    _all?: true
  }

  export type ConcursoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Concurso to aggregate.
     */
    where?: ConcursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Concursos to fetch.
     */
    orderBy?: ConcursoOrderByWithRelationInput | ConcursoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConcursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Concursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Concursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Concursos
    **/
    _count?: true | ConcursoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConcursoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConcursoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConcursoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConcursoMaxAggregateInputType
  }

  export type GetConcursoAggregateType<T extends ConcursoAggregateArgs> = {
        [P in keyof T & keyof AggregateConcurso]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConcurso[P]>
      : GetScalarType<T[P], AggregateConcurso[P]>
  }




  export type ConcursoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConcursoWhereInput
    orderBy?: ConcursoOrderByWithAggregationInput | ConcursoOrderByWithAggregationInput[]
    by: ConcursoScalarFieldEnum[] | ConcursoScalarFieldEnum
    having?: ConcursoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConcursoCountAggregateInputType | true
    _avg?: ConcursoAvgAggregateInputType
    _sum?: ConcursoSumAggregateInputType
    _min?: ConcursoMinAggregateInputType
    _max?: ConcursoMaxAggregateInputType
  }

  export type ConcursoGroupByOutputType = {
    idConcurso: number
    nomeConcurso: string
    lancamentoEdital: Date
    inscricoesInicio: Date
    inscricoesFinal: Date
    dataProvaEscrita: Date
    dataProvasPraticas: Date
    dataResultado: Date
    local: string
    anexoEdital: Bytes | null
    _count: ConcursoCountAggregateOutputType | null
    _avg: ConcursoAvgAggregateOutputType | null
    _sum: ConcursoSumAggregateOutputType | null
    _min: ConcursoMinAggregateOutputType | null
    _max: ConcursoMaxAggregateOutputType | null
  }

  type GetConcursoGroupByPayload<T extends ConcursoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConcursoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConcursoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConcursoGroupByOutputType[P]>
            : GetScalarType<T[P], ConcursoGroupByOutputType[P]>
        }
      >
    >


  export type ConcursoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idConcurso?: boolean
    nomeConcurso?: boolean
    lancamentoEdital?: boolean
    inscricoesInicio?: boolean
    inscricoesFinal?: boolean
    dataProvaEscrita?: boolean
    dataProvasPraticas?: boolean
    dataResultado?: boolean
    local?: boolean
    anexoEdital?: boolean
    candidatos?: boolean | Concurso$candidatosArgs<ExtArgs>
    comissoes?: boolean | Concurso$comissoesArgs<ExtArgs>
    _count?: boolean | ConcursoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["concurso"]>

  export type ConcursoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idConcurso?: boolean
    nomeConcurso?: boolean
    lancamentoEdital?: boolean
    inscricoesInicio?: boolean
    inscricoesFinal?: boolean
    dataProvaEscrita?: boolean
    dataProvasPraticas?: boolean
    dataResultado?: boolean
    local?: boolean
    anexoEdital?: boolean
  }, ExtArgs["result"]["concurso"]>

  export type ConcursoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idConcurso?: boolean
    nomeConcurso?: boolean
    lancamentoEdital?: boolean
    inscricoesInicio?: boolean
    inscricoesFinal?: boolean
    dataProvaEscrita?: boolean
    dataProvasPraticas?: boolean
    dataResultado?: boolean
    local?: boolean
    anexoEdital?: boolean
  }, ExtArgs["result"]["concurso"]>

  export type ConcursoSelectScalar = {
    idConcurso?: boolean
    nomeConcurso?: boolean
    lancamentoEdital?: boolean
    inscricoesInicio?: boolean
    inscricoesFinal?: boolean
    dataProvaEscrita?: boolean
    dataProvasPraticas?: boolean
    dataResultado?: boolean
    local?: boolean
    anexoEdital?: boolean
  }

  export type ConcursoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idConcurso" | "nomeConcurso" | "lancamentoEdital" | "inscricoesInicio" | "inscricoesFinal" | "dataProvaEscrita" | "dataProvasPraticas" | "dataResultado" | "local" | "anexoEdital", ExtArgs["result"]["concurso"]>
  export type ConcursoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    candidatos?: boolean | Concurso$candidatosArgs<ExtArgs>
    comissoes?: boolean | Concurso$comissoesArgs<ExtArgs>
    _count?: boolean | ConcursoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConcursoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ConcursoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ConcursoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Concurso"
    objects: {
      candidatos: Prisma.$CandidatoPayload<ExtArgs>[]
      comissoes: Prisma.$ComissaoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idConcurso: number
      nomeConcurso: string
      lancamentoEdital: Date
      inscricoesInicio: Date
      inscricoesFinal: Date
      dataProvaEscrita: Date
      dataProvasPraticas: Date
      dataResultado: Date
      local: string
      anexoEdital: Prisma.Bytes | null
    }, ExtArgs["result"]["concurso"]>
    composites: {}
  }

  type ConcursoGetPayload<S extends boolean | null | undefined | ConcursoDefaultArgs> = $Result.GetResult<Prisma.$ConcursoPayload, S>

  type ConcursoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConcursoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConcursoCountAggregateInputType | true
    }

  export interface ConcursoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Concurso'], meta: { name: 'Concurso' } }
    /**
     * Find zero or one Concurso that matches the filter.
     * @param {ConcursoFindUniqueArgs} args - Arguments to find a Concurso
     * @example
     * // Get one Concurso
     * const concurso = await prisma.concurso.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConcursoFindUniqueArgs>(args: SelectSubset<T, ConcursoFindUniqueArgs<ExtArgs>>): Prisma__ConcursoClient<$Result.GetResult<Prisma.$ConcursoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Concurso that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConcursoFindUniqueOrThrowArgs} args - Arguments to find a Concurso
     * @example
     * // Get one Concurso
     * const concurso = await prisma.concurso.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConcursoFindUniqueOrThrowArgs>(args: SelectSubset<T, ConcursoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConcursoClient<$Result.GetResult<Prisma.$ConcursoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Concurso that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConcursoFindFirstArgs} args - Arguments to find a Concurso
     * @example
     * // Get one Concurso
     * const concurso = await prisma.concurso.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConcursoFindFirstArgs>(args?: SelectSubset<T, ConcursoFindFirstArgs<ExtArgs>>): Prisma__ConcursoClient<$Result.GetResult<Prisma.$ConcursoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Concurso that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConcursoFindFirstOrThrowArgs} args - Arguments to find a Concurso
     * @example
     * // Get one Concurso
     * const concurso = await prisma.concurso.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConcursoFindFirstOrThrowArgs>(args?: SelectSubset<T, ConcursoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConcursoClient<$Result.GetResult<Prisma.$ConcursoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Concursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConcursoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Concursos
     * const concursos = await prisma.concurso.findMany()
     * 
     * // Get first 10 Concursos
     * const concursos = await prisma.concurso.findMany({ take: 10 })
     * 
     * // Only select the `idConcurso`
     * const concursoWithIdConcursoOnly = await prisma.concurso.findMany({ select: { idConcurso: true } })
     * 
     */
    findMany<T extends ConcursoFindManyArgs>(args?: SelectSubset<T, ConcursoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConcursoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Concurso.
     * @param {ConcursoCreateArgs} args - Arguments to create a Concurso.
     * @example
     * // Create one Concurso
     * const Concurso = await prisma.concurso.create({
     *   data: {
     *     // ... data to create a Concurso
     *   }
     * })
     * 
     */
    create<T extends ConcursoCreateArgs>(args: SelectSubset<T, ConcursoCreateArgs<ExtArgs>>): Prisma__ConcursoClient<$Result.GetResult<Prisma.$ConcursoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Concursos.
     * @param {ConcursoCreateManyArgs} args - Arguments to create many Concursos.
     * @example
     * // Create many Concursos
     * const concurso = await prisma.concurso.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConcursoCreateManyArgs>(args?: SelectSubset<T, ConcursoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Concursos and returns the data saved in the database.
     * @param {ConcursoCreateManyAndReturnArgs} args - Arguments to create many Concursos.
     * @example
     * // Create many Concursos
     * const concurso = await prisma.concurso.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Concursos and only return the `idConcurso`
     * const concursoWithIdConcursoOnly = await prisma.concurso.createManyAndReturn({
     *   select: { idConcurso: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConcursoCreateManyAndReturnArgs>(args?: SelectSubset<T, ConcursoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConcursoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Concurso.
     * @param {ConcursoDeleteArgs} args - Arguments to delete one Concurso.
     * @example
     * // Delete one Concurso
     * const Concurso = await prisma.concurso.delete({
     *   where: {
     *     // ... filter to delete one Concurso
     *   }
     * })
     * 
     */
    delete<T extends ConcursoDeleteArgs>(args: SelectSubset<T, ConcursoDeleteArgs<ExtArgs>>): Prisma__ConcursoClient<$Result.GetResult<Prisma.$ConcursoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Concurso.
     * @param {ConcursoUpdateArgs} args - Arguments to update one Concurso.
     * @example
     * // Update one Concurso
     * const concurso = await prisma.concurso.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConcursoUpdateArgs>(args: SelectSubset<T, ConcursoUpdateArgs<ExtArgs>>): Prisma__ConcursoClient<$Result.GetResult<Prisma.$ConcursoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Concursos.
     * @param {ConcursoDeleteManyArgs} args - Arguments to filter Concursos to delete.
     * @example
     * // Delete a few Concursos
     * const { count } = await prisma.concurso.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConcursoDeleteManyArgs>(args?: SelectSubset<T, ConcursoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Concursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConcursoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Concursos
     * const concurso = await prisma.concurso.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConcursoUpdateManyArgs>(args: SelectSubset<T, ConcursoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Concursos and returns the data updated in the database.
     * @param {ConcursoUpdateManyAndReturnArgs} args - Arguments to update many Concursos.
     * @example
     * // Update many Concursos
     * const concurso = await prisma.concurso.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Concursos and only return the `idConcurso`
     * const concursoWithIdConcursoOnly = await prisma.concurso.updateManyAndReturn({
     *   select: { idConcurso: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConcursoUpdateManyAndReturnArgs>(args: SelectSubset<T, ConcursoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConcursoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Concurso.
     * @param {ConcursoUpsertArgs} args - Arguments to update or create a Concurso.
     * @example
     * // Update or create a Concurso
     * const concurso = await prisma.concurso.upsert({
     *   create: {
     *     // ... data to create a Concurso
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Concurso we want to update
     *   }
     * })
     */
    upsert<T extends ConcursoUpsertArgs>(args: SelectSubset<T, ConcursoUpsertArgs<ExtArgs>>): Prisma__ConcursoClient<$Result.GetResult<Prisma.$ConcursoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Concursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConcursoCountArgs} args - Arguments to filter Concursos to count.
     * @example
     * // Count the number of Concursos
     * const count = await prisma.concurso.count({
     *   where: {
     *     // ... the filter for the Concursos we want to count
     *   }
     * })
    **/
    count<T extends ConcursoCountArgs>(
      args?: Subset<T, ConcursoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConcursoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Concurso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConcursoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConcursoAggregateArgs>(args: Subset<T, ConcursoAggregateArgs>): Prisma.PrismaPromise<GetConcursoAggregateType<T>>

    /**
     * Group by Concurso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConcursoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConcursoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConcursoGroupByArgs['orderBy'] }
        : { orderBy?: ConcursoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConcursoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConcursoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Concurso model
   */
  readonly fields: ConcursoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Concurso.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConcursoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    candidatos<T extends Concurso$candidatosArgs<ExtArgs> = {}>(args?: Subset<T, Concurso$candidatosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CandidatoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comissoes<T extends Concurso$comissoesArgs<ExtArgs> = {}>(args?: Subset<T, Concurso$comissoesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComissaoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Concurso model
   */
  interface ConcursoFieldRefs {
    readonly idConcurso: FieldRef<"Concurso", 'Int'>
    readonly nomeConcurso: FieldRef<"Concurso", 'String'>
    readonly lancamentoEdital: FieldRef<"Concurso", 'DateTime'>
    readonly inscricoesInicio: FieldRef<"Concurso", 'DateTime'>
    readonly inscricoesFinal: FieldRef<"Concurso", 'DateTime'>
    readonly dataProvaEscrita: FieldRef<"Concurso", 'DateTime'>
    readonly dataProvasPraticas: FieldRef<"Concurso", 'DateTime'>
    readonly dataResultado: FieldRef<"Concurso", 'DateTime'>
    readonly local: FieldRef<"Concurso", 'String'>
    readonly anexoEdital: FieldRef<"Concurso", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * Concurso findUnique
   */
  export type ConcursoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concurso
     */
    select?: ConcursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Concurso
     */
    omit?: ConcursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConcursoInclude<ExtArgs> | null
    /**
     * Filter, which Concurso to fetch.
     */
    where: ConcursoWhereUniqueInput
  }

  /**
   * Concurso findUniqueOrThrow
   */
  export type ConcursoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concurso
     */
    select?: ConcursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Concurso
     */
    omit?: ConcursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConcursoInclude<ExtArgs> | null
    /**
     * Filter, which Concurso to fetch.
     */
    where: ConcursoWhereUniqueInput
  }

  /**
   * Concurso findFirst
   */
  export type ConcursoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concurso
     */
    select?: ConcursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Concurso
     */
    omit?: ConcursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConcursoInclude<ExtArgs> | null
    /**
     * Filter, which Concurso to fetch.
     */
    where?: ConcursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Concursos to fetch.
     */
    orderBy?: ConcursoOrderByWithRelationInput | ConcursoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Concursos.
     */
    cursor?: ConcursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Concursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Concursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Concursos.
     */
    distinct?: ConcursoScalarFieldEnum | ConcursoScalarFieldEnum[]
  }

  /**
   * Concurso findFirstOrThrow
   */
  export type ConcursoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concurso
     */
    select?: ConcursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Concurso
     */
    omit?: ConcursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConcursoInclude<ExtArgs> | null
    /**
     * Filter, which Concurso to fetch.
     */
    where?: ConcursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Concursos to fetch.
     */
    orderBy?: ConcursoOrderByWithRelationInput | ConcursoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Concursos.
     */
    cursor?: ConcursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Concursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Concursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Concursos.
     */
    distinct?: ConcursoScalarFieldEnum | ConcursoScalarFieldEnum[]
  }

  /**
   * Concurso findMany
   */
  export type ConcursoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concurso
     */
    select?: ConcursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Concurso
     */
    omit?: ConcursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConcursoInclude<ExtArgs> | null
    /**
     * Filter, which Concursos to fetch.
     */
    where?: ConcursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Concursos to fetch.
     */
    orderBy?: ConcursoOrderByWithRelationInput | ConcursoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Concursos.
     */
    cursor?: ConcursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Concursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Concursos.
     */
    skip?: number
    distinct?: ConcursoScalarFieldEnum | ConcursoScalarFieldEnum[]
  }

  /**
   * Concurso create
   */
  export type ConcursoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concurso
     */
    select?: ConcursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Concurso
     */
    omit?: ConcursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConcursoInclude<ExtArgs> | null
    /**
     * The data needed to create a Concurso.
     */
    data: XOR<ConcursoCreateInput, ConcursoUncheckedCreateInput>
  }

  /**
   * Concurso createMany
   */
  export type ConcursoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Concursos.
     */
    data: ConcursoCreateManyInput | ConcursoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Concurso createManyAndReturn
   */
  export type ConcursoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concurso
     */
    select?: ConcursoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Concurso
     */
    omit?: ConcursoOmit<ExtArgs> | null
    /**
     * The data used to create many Concursos.
     */
    data: ConcursoCreateManyInput | ConcursoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Concurso update
   */
  export type ConcursoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concurso
     */
    select?: ConcursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Concurso
     */
    omit?: ConcursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConcursoInclude<ExtArgs> | null
    /**
     * The data needed to update a Concurso.
     */
    data: XOR<ConcursoUpdateInput, ConcursoUncheckedUpdateInput>
    /**
     * Choose, which Concurso to update.
     */
    where: ConcursoWhereUniqueInput
  }

  /**
   * Concurso updateMany
   */
  export type ConcursoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Concursos.
     */
    data: XOR<ConcursoUpdateManyMutationInput, ConcursoUncheckedUpdateManyInput>
    /**
     * Filter which Concursos to update
     */
    where?: ConcursoWhereInput
    /**
     * Limit how many Concursos to update.
     */
    limit?: number
  }

  /**
   * Concurso updateManyAndReturn
   */
  export type ConcursoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concurso
     */
    select?: ConcursoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Concurso
     */
    omit?: ConcursoOmit<ExtArgs> | null
    /**
     * The data used to update Concursos.
     */
    data: XOR<ConcursoUpdateManyMutationInput, ConcursoUncheckedUpdateManyInput>
    /**
     * Filter which Concursos to update
     */
    where?: ConcursoWhereInput
    /**
     * Limit how many Concursos to update.
     */
    limit?: number
  }

  /**
   * Concurso upsert
   */
  export type ConcursoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concurso
     */
    select?: ConcursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Concurso
     */
    omit?: ConcursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConcursoInclude<ExtArgs> | null
    /**
     * The filter to search for the Concurso to update in case it exists.
     */
    where: ConcursoWhereUniqueInput
    /**
     * In case the Concurso found by the `where` argument doesn't exist, create a new Concurso with this data.
     */
    create: XOR<ConcursoCreateInput, ConcursoUncheckedCreateInput>
    /**
     * In case the Concurso was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConcursoUpdateInput, ConcursoUncheckedUpdateInput>
  }

  /**
   * Concurso delete
   */
  export type ConcursoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concurso
     */
    select?: ConcursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Concurso
     */
    omit?: ConcursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConcursoInclude<ExtArgs> | null
    /**
     * Filter which Concurso to delete.
     */
    where: ConcursoWhereUniqueInput
  }

  /**
   * Concurso deleteMany
   */
  export type ConcursoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Concursos to delete
     */
    where?: ConcursoWhereInput
    /**
     * Limit how many Concursos to delete.
     */
    limit?: number
  }

  /**
   * Concurso.candidatos
   */
  export type Concurso$candidatosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidato
     */
    select?: CandidatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Candidato
     */
    omit?: CandidatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidatoInclude<ExtArgs> | null
    where?: CandidatoWhereInput
    orderBy?: CandidatoOrderByWithRelationInput | CandidatoOrderByWithRelationInput[]
    cursor?: CandidatoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CandidatoScalarFieldEnum | CandidatoScalarFieldEnum[]
  }

  /**
   * Concurso.comissoes
   */
  export type Concurso$comissoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comissao
     */
    select?: ComissaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comissao
     */
    omit?: ComissaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComissaoInclude<ExtArgs> | null
    where?: ComissaoWhereInput
    orderBy?: ComissaoOrderByWithRelationInput | ComissaoOrderByWithRelationInput[]
    cursor?: ComissaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComissaoScalarFieldEnum | ComissaoScalarFieldEnum[]
  }

  /**
   * Concurso without action
   */
  export type ConcursoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concurso
     */
    select?: ConcursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Concurso
     */
    omit?: ConcursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConcursoInclude<ExtArgs> | null
  }


  /**
   * Model Comissao
   */

  export type AggregateComissao = {
    _count: ComissaoCountAggregateOutputType | null
    _avg: ComissaoAvgAggregateOutputType | null
    _sum: ComissaoSumAggregateOutputType | null
    _min: ComissaoMinAggregateOutputType | null
    _max: ComissaoMaxAggregateOutputType | null
  }

  export type ComissaoAvgAggregateOutputType = {
    idComissao: number | null
    concursoId: number | null
  }

  export type ComissaoSumAggregateOutputType = {
    idComissao: number | null
    concursoId: number | null
  }

  export type ComissaoMinAggregateOutputType = {
    idComissao: number | null
    nomeComissao: string | null
    concursoId: number | null
  }

  export type ComissaoMaxAggregateOutputType = {
    idComissao: number | null
    nomeComissao: string | null
    concursoId: number | null
  }

  export type ComissaoCountAggregateOutputType = {
    idComissao: number
    nomeComissao: number
    concursoId: number
    _all: number
  }


  export type ComissaoAvgAggregateInputType = {
    idComissao?: true
    concursoId?: true
  }

  export type ComissaoSumAggregateInputType = {
    idComissao?: true
    concursoId?: true
  }

  export type ComissaoMinAggregateInputType = {
    idComissao?: true
    nomeComissao?: true
    concursoId?: true
  }

  export type ComissaoMaxAggregateInputType = {
    idComissao?: true
    nomeComissao?: true
    concursoId?: true
  }

  export type ComissaoCountAggregateInputType = {
    idComissao?: true
    nomeComissao?: true
    concursoId?: true
    _all?: true
  }

  export type ComissaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comissao to aggregate.
     */
    where?: ComissaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comissaos to fetch.
     */
    orderBy?: ComissaoOrderByWithRelationInput | ComissaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComissaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comissaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comissaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comissaos
    **/
    _count?: true | ComissaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComissaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComissaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComissaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComissaoMaxAggregateInputType
  }

  export type GetComissaoAggregateType<T extends ComissaoAggregateArgs> = {
        [P in keyof T & keyof AggregateComissao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComissao[P]>
      : GetScalarType<T[P], AggregateComissao[P]>
  }




  export type ComissaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComissaoWhereInput
    orderBy?: ComissaoOrderByWithAggregationInput | ComissaoOrderByWithAggregationInput[]
    by: ComissaoScalarFieldEnum[] | ComissaoScalarFieldEnum
    having?: ComissaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComissaoCountAggregateInputType | true
    _avg?: ComissaoAvgAggregateInputType
    _sum?: ComissaoSumAggregateInputType
    _min?: ComissaoMinAggregateInputType
    _max?: ComissaoMaxAggregateInputType
  }

  export type ComissaoGroupByOutputType = {
    idComissao: number
    nomeComissao: string
    concursoId: number
    _count: ComissaoCountAggregateOutputType | null
    _avg: ComissaoAvgAggregateOutputType | null
    _sum: ComissaoSumAggregateOutputType | null
    _min: ComissaoMinAggregateOutputType | null
    _max: ComissaoMaxAggregateOutputType | null
  }

  type GetComissaoGroupByPayload<T extends ComissaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComissaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComissaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComissaoGroupByOutputType[P]>
            : GetScalarType<T[P], ComissaoGroupByOutputType[P]>
        }
      >
    >


  export type ComissaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idComissao?: boolean
    nomeComissao?: boolean
    concursoId?: boolean
    concurso?: boolean | ConcursoDefaultArgs<ExtArgs>
    avalicao?: boolean | Comissao$avalicaoArgs<ExtArgs>
    usuarios?: boolean | Comissao$usuariosArgs<ExtArgs>
    _count?: boolean | ComissaoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comissao"]>

  export type ComissaoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idComissao?: boolean
    nomeComissao?: boolean
    concursoId?: boolean
    concurso?: boolean | ConcursoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comissao"]>

  export type ComissaoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idComissao?: boolean
    nomeComissao?: boolean
    concursoId?: boolean
    concurso?: boolean | ConcursoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comissao"]>

  export type ComissaoSelectScalar = {
    idComissao?: boolean
    nomeComissao?: boolean
    concursoId?: boolean
  }

  export type ComissaoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idComissao" | "nomeComissao" | "concursoId", ExtArgs["result"]["comissao"]>
  export type ComissaoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    concurso?: boolean | ConcursoDefaultArgs<ExtArgs>
    avalicao?: boolean | Comissao$avalicaoArgs<ExtArgs>
    usuarios?: boolean | Comissao$usuariosArgs<ExtArgs>
    _count?: boolean | ComissaoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ComissaoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    concurso?: boolean | ConcursoDefaultArgs<ExtArgs>
  }
  export type ComissaoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    concurso?: boolean | ConcursoDefaultArgs<ExtArgs>
  }

  export type $ComissaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comissao"
    objects: {
      concurso: Prisma.$ConcursoPayload<ExtArgs>
      avalicao: Prisma.$AvaliacaoPayload<ExtArgs>[]
      usuarios: Prisma.$ComissaoUsuarioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idComissao: number
      nomeComissao: string
      concursoId: number
    }, ExtArgs["result"]["comissao"]>
    composites: {}
  }

  type ComissaoGetPayload<S extends boolean | null | undefined | ComissaoDefaultArgs> = $Result.GetResult<Prisma.$ComissaoPayload, S>

  type ComissaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ComissaoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComissaoCountAggregateInputType | true
    }

  export interface ComissaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comissao'], meta: { name: 'Comissao' } }
    /**
     * Find zero or one Comissao that matches the filter.
     * @param {ComissaoFindUniqueArgs} args - Arguments to find a Comissao
     * @example
     * // Get one Comissao
     * const comissao = await prisma.comissao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComissaoFindUniqueArgs>(args: SelectSubset<T, ComissaoFindUniqueArgs<ExtArgs>>): Prisma__ComissaoClient<$Result.GetResult<Prisma.$ComissaoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comissao that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ComissaoFindUniqueOrThrowArgs} args - Arguments to find a Comissao
     * @example
     * // Get one Comissao
     * const comissao = await prisma.comissao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComissaoFindUniqueOrThrowArgs>(args: SelectSubset<T, ComissaoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComissaoClient<$Result.GetResult<Prisma.$ComissaoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comissao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComissaoFindFirstArgs} args - Arguments to find a Comissao
     * @example
     * // Get one Comissao
     * const comissao = await prisma.comissao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComissaoFindFirstArgs>(args?: SelectSubset<T, ComissaoFindFirstArgs<ExtArgs>>): Prisma__ComissaoClient<$Result.GetResult<Prisma.$ComissaoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comissao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComissaoFindFirstOrThrowArgs} args - Arguments to find a Comissao
     * @example
     * // Get one Comissao
     * const comissao = await prisma.comissao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComissaoFindFirstOrThrowArgs>(args?: SelectSubset<T, ComissaoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComissaoClient<$Result.GetResult<Prisma.$ComissaoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comissaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComissaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comissaos
     * const comissaos = await prisma.comissao.findMany()
     * 
     * // Get first 10 Comissaos
     * const comissaos = await prisma.comissao.findMany({ take: 10 })
     * 
     * // Only select the `idComissao`
     * const comissaoWithIdComissaoOnly = await prisma.comissao.findMany({ select: { idComissao: true } })
     * 
     */
    findMany<T extends ComissaoFindManyArgs>(args?: SelectSubset<T, ComissaoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComissaoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comissao.
     * @param {ComissaoCreateArgs} args - Arguments to create a Comissao.
     * @example
     * // Create one Comissao
     * const Comissao = await prisma.comissao.create({
     *   data: {
     *     // ... data to create a Comissao
     *   }
     * })
     * 
     */
    create<T extends ComissaoCreateArgs>(args: SelectSubset<T, ComissaoCreateArgs<ExtArgs>>): Prisma__ComissaoClient<$Result.GetResult<Prisma.$ComissaoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comissaos.
     * @param {ComissaoCreateManyArgs} args - Arguments to create many Comissaos.
     * @example
     * // Create many Comissaos
     * const comissao = await prisma.comissao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComissaoCreateManyArgs>(args?: SelectSubset<T, ComissaoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comissaos and returns the data saved in the database.
     * @param {ComissaoCreateManyAndReturnArgs} args - Arguments to create many Comissaos.
     * @example
     * // Create many Comissaos
     * const comissao = await prisma.comissao.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comissaos and only return the `idComissao`
     * const comissaoWithIdComissaoOnly = await prisma.comissao.createManyAndReturn({
     *   select: { idComissao: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComissaoCreateManyAndReturnArgs>(args?: SelectSubset<T, ComissaoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComissaoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comissao.
     * @param {ComissaoDeleteArgs} args - Arguments to delete one Comissao.
     * @example
     * // Delete one Comissao
     * const Comissao = await prisma.comissao.delete({
     *   where: {
     *     // ... filter to delete one Comissao
     *   }
     * })
     * 
     */
    delete<T extends ComissaoDeleteArgs>(args: SelectSubset<T, ComissaoDeleteArgs<ExtArgs>>): Prisma__ComissaoClient<$Result.GetResult<Prisma.$ComissaoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comissao.
     * @param {ComissaoUpdateArgs} args - Arguments to update one Comissao.
     * @example
     * // Update one Comissao
     * const comissao = await prisma.comissao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComissaoUpdateArgs>(args: SelectSubset<T, ComissaoUpdateArgs<ExtArgs>>): Prisma__ComissaoClient<$Result.GetResult<Prisma.$ComissaoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comissaos.
     * @param {ComissaoDeleteManyArgs} args - Arguments to filter Comissaos to delete.
     * @example
     * // Delete a few Comissaos
     * const { count } = await prisma.comissao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComissaoDeleteManyArgs>(args?: SelectSubset<T, ComissaoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comissaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComissaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comissaos
     * const comissao = await prisma.comissao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComissaoUpdateManyArgs>(args: SelectSubset<T, ComissaoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comissaos and returns the data updated in the database.
     * @param {ComissaoUpdateManyAndReturnArgs} args - Arguments to update many Comissaos.
     * @example
     * // Update many Comissaos
     * const comissao = await prisma.comissao.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comissaos and only return the `idComissao`
     * const comissaoWithIdComissaoOnly = await prisma.comissao.updateManyAndReturn({
     *   select: { idComissao: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ComissaoUpdateManyAndReturnArgs>(args: SelectSubset<T, ComissaoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComissaoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comissao.
     * @param {ComissaoUpsertArgs} args - Arguments to update or create a Comissao.
     * @example
     * // Update or create a Comissao
     * const comissao = await prisma.comissao.upsert({
     *   create: {
     *     // ... data to create a Comissao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comissao we want to update
     *   }
     * })
     */
    upsert<T extends ComissaoUpsertArgs>(args: SelectSubset<T, ComissaoUpsertArgs<ExtArgs>>): Prisma__ComissaoClient<$Result.GetResult<Prisma.$ComissaoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comissaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComissaoCountArgs} args - Arguments to filter Comissaos to count.
     * @example
     * // Count the number of Comissaos
     * const count = await prisma.comissao.count({
     *   where: {
     *     // ... the filter for the Comissaos we want to count
     *   }
     * })
    **/
    count<T extends ComissaoCountArgs>(
      args?: Subset<T, ComissaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComissaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comissao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComissaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComissaoAggregateArgs>(args: Subset<T, ComissaoAggregateArgs>): Prisma.PrismaPromise<GetComissaoAggregateType<T>>

    /**
     * Group by Comissao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComissaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComissaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComissaoGroupByArgs['orderBy'] }
        : { orderBy?: ComissaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComissaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComissaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comissao model
   */
  readonly fields: ComissaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comissao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComissaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    concurso<T extends ConcursoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConcursoDefaultArgs<ExtArgs>>): Prisma__ConcursoClient<$Result.GetResult<Prisma.$ConcursoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    avalicao<T extends Comissao$avalicaoArgs<ExtArgs> = {}>(args?: Subset<T, Comissao$avalicaoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    usuarios<T extends Comissao$usuariosArgs<ExtArgs> = {}>(args?: Subset<T, Comissao$usuariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComissaoUsuarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comissao model
   */
  interface ComissaoFieldRefs {
    readonly idComissao: FieldRef<"Comissao", 'Int'>
    readonly nomeComissao: FieldRef<"Comissao", 'String'>
    readonly concursoId: FieldRef<"Comissao", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Comissao findUnique
   */
  export type ComissaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comissao
     */
    select?: ComissaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comissao
     */
    omit?: ComissaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComissaoInclude<ExtArgs> | null
    /**
     * Filter, which Comissao to fetch.
     */
    where: ComissaoWhereUniqueInput
  }

  /**
   * Comissao findUniqueOrThrow
   */
  export type ComissaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comissao
     */
    select?: ComissaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comissao
     */
    omit?: ComissaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComissaoInclude<ExtArgs> | null
    /**
     * Filter, which Comissao to fetch.
     */
    where: ComissaoWhereUniqueInput
  }

  /**
   * Comissao findFirst
   */
  export type ComissaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comissao
     */
    select?: ComissaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comissao
     */
    omit?: ComissaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComissaoInclude<ExtArgs> | null
    /**
     * Filter, which Comissao to fetch.
     */
    where?: ComissaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comissaos to fetch.
     */
    orderBy?: ComissaoOrderByWithRelationInput | ComissaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comissaos.
     */
    cursor?: ComissaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comissaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comissaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comissaos.
     */
    distinct?: ComissaoScalarFieldEnum | ComissaoScalarFieldEnum[]
  }

  /**
   * Comissao findFirstOrThrow
   */
  export type ComissaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comissao
     */
    select?: ComissaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comissao
     */
    omit?: ComissaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComissaoInclude<ExtArgs> | null
    /**
     * Filter, which Comissao to fetch.
     */
    where?: ComissaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comissaos to fetch.
     */
    orderBy?: ComissaoOrderByWithRelationInput | ComissaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comissaos.
     */
    cursor?: ComissaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comissaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comissaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comissaos.
     */
    distinct?: ComissaoScalarFieldEnum | ComissaoScalarFieldEnum[]
  }

  /**
   * Comissao findMany
   */
  export type ComissaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comissao
     */
    select?: ComissaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comissao
     */
    omit?: ComissaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComissaoInclude<ExtArgs> | null
    /**
     * Filter, which Comissaos to fetch.
     */
    where?: ComissaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comissaos to fetch.
     */
    orderBy?: ComissaoOrderByWithRelationInput | ComissaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comissaos.
     */
    cursor?: ComissaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comissaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comissaos.
     */
    skip?: number
    distinct?: ComissaoScalarFieldEnum | ComissaoScalarFieldEnum[]
  }

  /**
   * Comissao create
   */
  export type ComissaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comissao
     */
    select?: ComissaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comissao
     */
    omit?: ComissaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComissaoInclude<ExtArgs> | null
    /**
     * The data needed to create a Comissao.
     */
    data: XOR<ComissaoCreateInput, ComissaoUncheckedCreateInput>
  }

  /**
   * Comissao createMany
   */
  export type ComissaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comissaos.
     */
    data: ComissaoCreateManyInput | ComissaoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comissao createManyAndReturn
   */
  export type ComissaoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comissao
     */
    select?: ComissaoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comissao
     */
    omit?: ComissaoOmit<ExtArgs> | null
    /**
     * The data used to create many Comissaos.
     */
    data: ComissaoCreateManyInput | ComissaoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComissaoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comissao update
   */
  export type ComissaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comissao
     */
    select?: ComissaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comissao
     */
    omit?: ComissaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComissaoInclude<ExtArgs> | null
    /**
     * The data needed to update a Comissao.
     */
    data: XOR<ComissaoUpdateInput, ComissaoUncheckedUpdateInput>
    /**
     * Choose, which Comissao to update.
     */
    where: ComissaoWhereUniqueInput
  }

  /**
   * Comissao updateMany
   */
  export type ComissaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comissaos.
     */
    data: XOR<ComissaoUpdateManyMutationInput, ComissaoUncheckedUpdateManyInput>
    /**
     * Filter which Comissaos to update
     */
    where?: ComissaoWhereInput
    /**
     * Limit how many Comissaos to update.
     */
    limit?: number
  }

  /**
   * Comissao updateManyAndReturn
   */
  export type ComissaoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comissao
     */
    select?: ComissaoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comissao
     */
    omit?: ComissaoOmit<ExtArgs> | null
    /**
     * The data used to update Comissaos.
     */
    data: XOR<ComissaoUpdateManyMutationInput, ComissaoUncheckedUpdateManyInput>
    /**
     * Filter which Comissaos to update
     */
    where?: ComissaoWhereInput
    /**
     * Limit how many Comissaos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComissaoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comissao upsert
   */
  export type ComissaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comissao
     */
    select?: ComissaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comissao
     */
    omit?: ComissaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComissaoInclude<ExtArgs> | null
    /**
     * The filter to search for the Comissao to update in case it exists.
     */
    where: ComissaoWhereUniqueInput
    /**
     * In case the Comissao found by the `where` argument doesn't exist, create a new Comissao with this data.
     */
    create: XOR<ComissaoCreateInput, ComissaoUncheckedCreateInput>
    /**
     * In case the Comissao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComissaoUpdateInput, ComissaoUncheckedUpdateInput>
  }

  /**
   * Comissao delete
   */
  export type ComissaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comissao
     */
    select?: ComissaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comissao
     */
    omit?: ComissaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComissaoInclude<ExtArgs> | null
    /**
     * Filter which Comissao to delete.
     */
    where: ComissaoWhereUniqueInput
  }

  /**
   * Comissao deleteMany
   */
  export type ComissaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comissaos to delete
     */
    where?: ComissaoWhereInput
    /**
     * Limit how many Comissaos to delete.
     */
    limit?: number
  }

  /**
   * Comissao.avalicao
   */
  export type Comissao$avalicaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avaliacao
     */
    omit?: AvaliacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    where?: AvaliacaoWhereInput
    orderBy?: AvaliacaoOrderByWithRelationInput | AvaliacaoOrderByWithRelationInput[]
    cursor?: AvaliacaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AvaliacaoScalarFieldEnum | AvaliacaoScalarFieldEnum[]
  }

  /**
   * Comissao.usuarios
   */
  export type Comissao$usuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComissaoUsuario
     */
    select?: ComissaoUsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComissaoUsuario
     */
    omit?: ComissaoUsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComissaoUsuarioInclude<ExtArgs> | null
    where?: ComissaoUsuarioWhereInput
    orderBy?: ComissaoUsuarioOrderByWithRelationInput | ComissaoUsuarioOrderByWithRelationInput[]
    cursor?: ComissaoUsuarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComissaoUsuarioScalarFieldEnum | ComissaoUsuarioScalarFieldEnum[]
  }

  /**
   * Comissao without action
   */
  export type ComissaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comissao
     */
    select?: ComissaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comissao
     */
    omit?: ComissaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComissaoInclude<ExtArgs> | null
  }


  /**
   * Model ComissaoUsuario
   */

  export type AggregateComissaoUsuario = {
    _count: ComissaoUsuarioCountAggregateOutputType | null
    _avg: ComissaoUsuarioAvgAggregateOutputType | null
    _sum: ComissaoUsuarioSumAggregateOutputType | null
    _min: ComissaoUsuarioMinAggregateOutputType | null
    _max: ComissaoUsuarioMaxAggregateOutputType | null
  }

  export type ComissaoUsuarioAvgAggregateOutputType = {
    idComissaoUsuario: number | null
    comissaoId: number | null
    usuarioId: number | null
  }

  export type ComissaoUsuarioSumAggregateOutputType = {
    idComissaoUsuario: number | null
    comissaoId: number | null
    usuarioId: number | null
  }

  export type ComissaoUsuarioMinAggregateOutputType = {
    idComissaoUsuario: number | null
    comissaoId: number | null
    usuarioId: number | null
  }

  export type ComissaoUsuarioMaxAggregateOutputType = {
    idComissaoUsuario: number | null
    comissaoId: number | null
    usuarioId: number | null
  }

  export type ComissaoUsuarioCountAggregateOutputType = {
    idComissaoUsuario: number
    comissaoId: number
    usuarioId: number
    _all: number
  }


  export type ComissaoUsuarioAvgAggregateInputType = {
    idComissaoUsuario?: true
    comissaoId?: true
    usuarioId?: true
  }

  export type ComissaoUsuarioSumAggregateInputType = {
    idComissaoUsuario?: true
    comissaoId?: true
    usuarioId?: true
  }

  export type ComissaoUsuarioMinAggregateInputType = {
    idComissaoUsuario?: true
    comissaoId?: true
    usuarioId?: true
  }

  export type ComissaoUsuarioMaxAggregateInputType = {
    idComissaoUsuario?: true
    comissaoId?: true
    usuarioId?: true
  }

  export type ComissaoUsuarioCountAggregateInputType = {
    idComissaoUsuario?: true
    comissaoId?: true
    usuarioId?: true
    _all?: true
  }

  export type ComissaoUsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComissaoUsuario to aggregate.
     */
    where?: ComissaoUsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComissaoUsuarios to fetch.
     */
    orderBy?: ComissaoUsuarioOrderByWithRelationInput | ComissaoUsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComissaoUsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComissaoUsuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComissaoUsuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ComissaoUsuarios
    **/
    _count?: true | ComissaoUsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComissaoUsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComissaoUsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComissaoUsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComissaoUsuarioMaxAggregateInputType
  }

  export type GetComissaoUsuarioAggregateType<T extends ComissaoUsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateComissaoUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComissaoUsuario[P]>
      : GetScalarType<T[P], AggregateComissaoUsuario[P]>
  }




  export type ComissaoUsuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComissaoUsuarioWhereInput
    orderBy?: ComissaoUsuarioOrderByWithAggregationInput | ComissaoUsuarioOrderByWithAggregationInput[]
    by: ComissaoUsuarioScalarFieldEnum[] | ComissaoUsuarioScalarFieldEnum
    having?: ComissaoUsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComissaoUsuarioCountAggregateInputType | true
    _avg?: ComissaoUsuarioAvgAggregateInputType
    _sum?: ComissaoUsuarioSumAggregateInputType
    _min?: ComissaoUsuarioMinAggregateInputType
    _max?: ComissaoUsuarioMaxAggregateInputType
  }

  export type ComissaoUsuarioGroupByOutputType = {
    idComissaoUsuario: number
    comissaoId: number
    usuarioId: number
    _count: ComissaoUsuarioCountAggregateOutputType | null
    _avg: ComissaoUsuarioAvgAggregateOutputType | null
    _sum: ComissaoUsuarioSumAggregateOutputType | null
    _min: ComissaoUsuarioMinAggregateOutputType | null
    _max: ComissaoUsuarioMaxAggregateOutputType | null
  }

  type GetComissaoUsuarioGroupByPayload<T extends ComissaoUsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComissaoUsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComissaoUsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComissaoUsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], ComissaoUsuarioGroupByOutputType[P]>
        }
      >
    >


  export type ComissaoUsuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idComissaoUsuario?: boolean
    comissaoId?: boolean
    usuarioId?: boolean
    Comissao?: boolean | ComissaoDefaultArgs<ExtArgs>
    Usuarios?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comissaoUsuario"]>

  export type ComissaoUsuarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idComissaoUsuario?: boolean
    comissaoId?: boolean
    usuarioId?: boolean
    Comissao?: boolean | ComissaoDefaultArgs<ExtArgs>
    Usuarios?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comissaoUsuario"]>

  export type ComissaoUsuarioSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idComissaoUsuario?: boolean
    comissaoId?: boolean
    usuarioId?: boolean
    Comissao?: boolean | ComissaoDefaultArgs<ExtArgs>
    Usuarios?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comissaoUsuario"]>

  export type ComissaoUsuarioSelectScalar = {
    idComissaoUsuario?: boolean
    comissaoId?: boolean
    usuarioId?: boolean
  }

  export type ComissaoUsuarioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idComissaoUsuario" | "comissaoId" | "usuarioId", ExtArgs["result"]["comissaoUsuario"]>
  export type ComissaoUsuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Comissao?: boolean | ComissaoDefaultArgs<ExtArgs>
    Usuarios?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type ComissaoUsuarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Comissao?: boolean | ComissaoDefaultArgs<ExtArgs>
    Usuarios?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type ComissaoUsuarioIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Comissao?: boolean | ComissaoDefaultArgs<ExtArgs>
    Usuarios?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $ComissaoUsuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ComissaoUsuario"
    objects: {
      Comissao: Prisma.$ComissaoPayload<ExtArgs>
      Usuarios: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idComissaoUsuario: number
      comissaoId: number
      usuarioId: number
    }, ExtArgs["result"]["comissaoUsuario"]>
    composites: {}
  }

  type ComissaoUsuarioGetPayload<S extends boolean | null | undefined | ComissaoUsuarioDefaultArgs> = $Result.GetResult<Prisma.$ComissaoUsuarioPayload, S>

  type ComissaoUsuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ComissaoUsuarioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComissaoUsuarioCountAggregateInputType | true
    }

  export interface ComissaoUsuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ComissaoUsuario'], meta: { name: 'ComissaoUsuario' } }
    /**
     * Find zero or one ComissaoUsuario that matches the filter.
     * @param {ComissaoUsuarioFindUniqueArgs} args - Arguments to find a ComissaoUsuario
     * @example
     * // Get one ComissaoUsuario
     * const comissaoUsuario = await prisma.comissaoUsuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComissaoUsuarioFindUniqueArgs>(args: SelectSubset<T, ComissaoUsuarioFindUniqueArgs<ExtArgs>>): Prisma__ComissaoUsuarioClient<$Result.GetResult<Prisma.$ComissaoUsuarioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ComissaoUsuario that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ComissaoUsuarioFindUniqueOrThrowArgs} args - Arguments to find a ComissaoUsuario
     * @example
     * // Get one ComissaoUsuario
     * const comissaoUsuario = await prisma.comissaoUsuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComissaoUsuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, ComissaoUsuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComissaoUsuarioClient<$Result.GetResult<Prisma.$ComissaoUsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ComissaoUsuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComissaoUsuarioFindFirstArgs} args - Arguments to find a ComissaoUsuario
     * @example
     * // Get one ComissaoUsuario
     * const comissaoUsuario = await prisma.comissaoUsuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComissaoUsuarioFindFirstArgs>(args?: SelectSubset<T, ComissaoUsuarioFindFirstArgs<ExtArgs>>): Prisma__ComissaoUsuarioClient<$Result.GetResult<Prisma.$ComissaoUsuarioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ComissaoUsuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComissaoUsuarioFindFirstOrThrowArgs} args - Arguments to find a ComissaoUsuario
     * @example
     * // Get one ComissaoUsuario
     * const comissaoUsuario = await prisma.comissaoUsuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComissaoUsuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, ComissaoUsuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComissaoUsuarioClient<$Result.GetResult<Prisma.$ComissaoUsuarioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ComissaoUsuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComissaoUsuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ComissaoUsuarios
     * const comissaoUsuarios = await prisma.comissaoUsuario.findMany()
     * 
     * // Get first 10 ComissaoUsuarios
     * const comissaoUsuarios = await prisma.comissaoUsuario.findMany({ take: 10 })
     * 
     * // Only select the `idComissaoUsuario`
     * const comissaoUsuarioWithIdComissaoUsuarioOnly = await prisma.comissaoUsuario.findMany({ select: { idComissaoUsuario: true } })
     * 
     */
    findMany<T extends ComissaoUsuarioFindManyArgs>(args?: SelectSubset<T, ComissaoUsuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComissaoUsuarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ComissaoUsuario.
     * @param {ComissaoUsuarioCreateArgs} args - Arguments to create a ComissaoUsuario.
     * @example
     * // Create one ComissaoUsuario
     * const ComissaoUsuario = await prisma.comissaoUsuario.create({
     *   data: {
     *     // ... data to create a ComissaoUsuario
     *   }
     * })
     * 
     */
    create<T extends ComissaoUsuarioCreateArgs>(args: SelectSubset<T, ComissaoUsuarioCreateArgs<ExtArgs>>): Prisma__ComissaoUsuarioClient<$Result.GetResult<Prisma.$ComissaoUsuarioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ComissaoUsuarios.
     * @param {ComissaoUsuarioCreateManyArgs} args - Arguments to create many ComissaoUsuarios.
     * @example
     * // Create many ComissaoUsuarios
     * const comissaoUsuario = await prisma.comissaoUsuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComissaoUsuarioCreateManyArgs>(args?: SelectSubset<T, ComissaoUsuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ComissaoUsuarios and returns the data saved in the database.
     * @param {ComissaoUsuarioCreateManyAndReturnArgs} args - Arguments to create many ComissaoUsuarios.
     * @example
     * // Create many ComissaoUsuarios
     * const comissaoUsuario = await prisma.comissaoUsuario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ComissaoUsuarios and only return the `idComissaoUsuario`
     * const comissaoUsuarioWithIdComissaoUsuarioOnly = await prisma.comissaoUsuario.createManyAndReturn({
     *   select: { idComissaoUsuario: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComissaoUsuarioCreateManyAndReturnArgs>(args?: SelectSubset<T, ComissaoUsuarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComissaoUsuarioPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ComissaoUsuario.
     * @param {ComissaoUsuarioDeleteArgs} args - Arguments to delete one ComissaoUsuario.
     * @example
     * // Delete one ComissaoUsuario
     * const ComissaoUsuario = await prisma.comissaoUsuario.delete({
     *   where: {
     *     // ... filter to delete one ComissaoUsuario
     *   }
     * })
     * 
     */
    delete<T extends ComissaoUsuarioDeleteArgs>(args: SelectSubset<T, ComissaoUsuarioDeleteArgs<ExtArgs>>): Prisma__ComissaoUsuarioClient<$Result.GetResult<Prisma.$ComissaoUsuarioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ComissaoUsuario.
     * @param {ComissaoUsuarioUpdateArgs} args - Arguments to update one ComissaoUsuario.
     * @example
     * // Update one ComissaoUsuario
     * const comissaoUsuario = await prisma.comissaoUsuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComissaoUsuarioUpdateArgs>(args: SelectSubset<T, ComissaoUsuarioUpdateArgs<ExtArgs>>): Prisma__ComissaoUsuarioClient<$Result.GetResult<Prisma.$ComissaoUsuarioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ComissaoUsuarios.
     * @param {ComissaoUsuarioDeleteManyArgs} args - Arguments to filter ComissaoUsuarios to delete.
     * @example
     * // Delete a few ComissaoUsuarios
     * const { count } = await prisma.comissaoUsuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComissaoUsuarioDeleteManyArgs>(args?: SelectSubset<T, ComissaoUsuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComissaoUsuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComissaoUsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ComissaoUsuarios
     * const comissaoUsuario = await prisma.comissaoUsuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComissaoUsuarioUpdateManyArgs>(args: SelectSubset<T, ComissaoUsuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComissaoUsuarios and returns the data updated in the database.
     * @param {ComissaoUsuarioUpdateManyAndReturnArgs} args - Arguments to update many ComissaoUsuarios.
     * @example
     * // Update many ComissaoUsuarios
     * const comissaoUsuario = await prisma.comissaoUsuario.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ComissaoUsuarios and only return the `idComissaoUsuario`
     * const comissaoUsuarioWithIdComissaoUsuarioOnly = await prisma.comissaoUsuario.updateManyAndReturn({
     *   select: { idComissaoUsuario: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ComissaoUsuarioUpdateManyAndReturnArgs>(args: SelectSubset<T, ComissaoUsuarioUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComissaoUsuarioPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ComissaoUsuario.
     * @param {ComissaoUsuarioUpsertArgs} args - Arguments to update or create a ComissaoUsuario.
     * @example
     * // Update or create a ComissaoUsuario
     * const comissaoUsuario = await prisma.comissaoUsuario.upsert({
     *   create: {
     *     // ... data to create a ComissaoUsuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ComissaoUsuario we want to update
     *   }
     * })
     */
    upsert<T extends ComissaoUsuarioUpsertArgs>(args: SelectSubset<T, ComissaoUsuarioUpsertArgs<ExtArgs>>): Prisma__ComissaoUsuarioClient<$Result.GetResult<Prisma.$ComissaoUsuarioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ComissaoUsuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComissaoUsuarioCountArgs} args - Arguments to filter ComissaoUsuarios to count.
     * @example
     * // Count the number of ComissaoUsuarios
     * const count = await prisma.comissaoUsuario.count({
     *   where: {
     *     // ... the filter for the ComissaoUsuarios we want to count
     *   }
     * })
    **/
    count<T extends ComissaoUsuarioCountArgs>(
      args?: Subset<T, ComissaoUsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComissaoUsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ComissaoUsuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComissaoUsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComissaoUsuarioAggregateArgs>(args: Subset<T, ComissaoUsuarioAggregateArgs>): Prisma.PrismaPromise<GetComissaoUsuarioAggregateType<T>>

    /**
     * Group by ComissaoUsuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComissaoUsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComissaoUsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComissaoUsuarioGroupByArgs['orderBy'] }
        : { orderBy?: ComissaoUsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComissaoUsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComissaoUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ComissaoUsuario model
   */
  readonly fields: ComissaoUsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ComissaoUsuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComissaoUsuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Comissao<T extends ComissaoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComissaoDefaultArgs<ExtArgs>>): Prisma__ComissaoClient<$Result.GetResult<Prisma.$ComissaoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Usuarios<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ComissaoUsuario model
   */
  interface ComissaoUsuarioFieldRefs {
    readonly idComissaoUsuario: FieldRef<"ComissaoUsuario", 'Int'>
    readonly comissaoId: FieldRef<"ComissaoUsuario", 'Int'>
    readonly usuarioId: FieldRef<"ComissaoUsuario", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ComissaoUsuario findUnique
   */
  export type ComissaoUsuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComissaoUsuario
     */
    select?: ComissaoUsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComissaoUsuario
     */
    omit?: ComissaoUsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComissaoUsuarioInclude<ExtArgs> | null
    /**
     * Filter, which ComissaoUsuario to fetch.
     */
    where: ComissaoUsuarioWhereUniqueInput
  }

  /**
   * ComissaoUsuario findUniqueOrThrow
   */
  export type ComissaoUsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComissaoUsuario
     */
    select?: ComissaoUsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComissaoUsuario
     */
    omit?: ComissaoUsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComissaoUsuarioInclude<ExtArgs> | null
    /**
     * Filter, which ComissaoUsuario to fetch.
     */
    where: ComissaoUsuarioWhereUniqueInput
  }

  /**
   * ComissaoUsuario findFirst
   */
  export type ComissaoUsuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComissaoUsuario
     */
    select?: ComissaoUsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComissaoUsuario
     */
    omit?: ComissaoUsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComissaoUsuarioInclude<ExtArgs> | null
    /**
     * Filter, which ComissaoUsuario to fetch.
     */
    where?: ComissaoUsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComissaoUsuarios to fetch.
     */
    orderBy?: ComissaoUsuarioOrderByWithRelationInput | ComissaoUsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComissaoUsuarios.
     */
    cursor?: ComissaoUsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComissaoUsuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComissaoUsuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComissaoUsuarios.
     */
    distinct?: ComissaoUsuarioScalarFieldEnum | ComissaoUsuarioScalarFieldEnum[]
  }

  /**
   * ComissaoUsuario findFirstOrThrow
   */
  export type ComissaoUsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComissaoUsuario
     */
    select?: ComissaoUsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComissaoUsuario
     */
    omit?: ComissaoUsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComissaoUsuarioInclude<ExtArgs> | null
    /**
     * Filter, which ComissaoUsuario to fetch.
     */
    where?: ComissaoUsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComissaoUsuarios to fetch.
     */
    orderBy?: ComissaoUsuarioOrderByWithRelationInput | ComissaoUsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComissaoUsuarios.
     */
    cursor?: ComissaoUsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComissaoUsuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComissaoUsuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComissaoUsuarios.
     */
    distinct?: ComissaoUsuarioScalarFieldEnum | ComissaoUsuarioScalarFieldEnum[]
  }

  /**
   * ComissaoUsuario findMany
   */
  export type ComissaoUsuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComissaoUsuario
     */
    select?: ComissaoUsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComissaoUsuario
     */
    omit?: ComissaoUsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComissaoUsuarioInclude<ExtArgs> | null
    /**
     * Filter, which ComissaoUsuarios to fetch.
     */
    where?: ComissaoUsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComissaoUsuarios to fetch.
     */
    orderBy?: ComissaoUsuarioOrderByWithRelationInput | ComissaoUsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ComissaoUsuarios.
     */
    cursor?: ComissaoUsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComissaoUsuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComissaoUsuarios.
     */
    skip?: number
    distinct?: ComissaoUsuarioScalarFieldEnum | ComissaoUsuarioScalarFieldEnum[]
  }

  /**
   * ComissaoUsuario create
   */
  export type ComissaoUsuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComissaoUsuario
     */
    select?: ComissaoUsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComissaoUsuario
     */
    omit?: ComissaoUsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComissaoUsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a ComissaoUsuario.
     */
    data: XOR<ComissaoUsuarioCreateInput, ComissaoUsuarioUncheckedCreateInput>
  }

  /**
   * ComissaoUsuario createMany
   */
  export type ComissaoUsuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ComissaoUsuarios.
     */
    data: ComissaoUsuarioCreateManyInput | ComissaoUsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ComissaoUsuario createManyAndReturn
   */
  export type ComissaoUsuarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComissaoUsuario
     */
    select?: ComissaoUsuarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ComissaoUsuario
     */
    omit?: ComissaoUsuarioOmit<ExtArgs> | null
    /**
     * The data used to create many ComissaoUsuarios.
     */
    data: ComissaoUsuarioCreateManyInput | ComissaoUsuarioCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComissaoUsuarioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ComissaoUsuario update
   */
  export type ComissaoUsuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComissaoUsuario
     */
    select?: ComissaoUsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComissaoUsuario
     */
    omit?: ComissaoUsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComissaoUsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a ComissaoUsuario.
     */
    data: XOR<ComissaoUsuarioUpdateInput, ComissaoUsuarioUncheckedUpdateInput>
    /**
     * Choose, which ComissaoUsuario to update.
     */
    where: ComissaoUsuarioWhereUniqueInput
  }

  /**
   * ComissaoUsuario updateMany
   */
  export type ComissaoUsuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ComissaoUsuarios.
     */
    data: XOR<ComissaoUsuarioUpdateManyMutationInput, ComissaoUsuarioUncheckedUpdateManyInput>
    /**
     * Filter which ComissaoUsuarios to update
     */
    where?: ComissaoUsuarioWhereInput
    /**
     * Limit how many ComissaoUsuarios to update.
     */
    limit?: number
  }

  /**
   * ComissaoUsuario updateManyAndReturn
   */
  export type ComissaoUsuarioUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComissaoUsuario
     */
    select?: ComissaoUsuarioSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ComissaoUsuario
     */
    omit?: ComissaoUsuarioOmit<ExtArgs> | null
    /**
     * The data used to update ComissaoUsuarios.
     */
    data: XOR<ComissaoUsuarioUpdateManyMutationInput, ComissaoUsuarioUncheckedUpdateManyInput>
    /**
     * Filter which ComissaoUsuarios to update
     */
    where?: ComissaoUsuarioWhereInput
    /**
     * Limit how many ComissaoUsuarios to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComissaoUsuarioIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ComissaoUsuario upsert
   */
  export type ComissaoUsuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComissaoUsuario
     */
    select?: ComissaoUsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComissaoUsuario
     */
    omit?: ComissaoUsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComissaoUsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the ComissaoUsuario to update in case it exists.
     */
    where: ComissaoUsuarioWhereUniqueInput
    /**
     * In case the ComissaoUsuario found by the `where` argument doesn't exist, create a new ComissaoUsuario with this data.
     */
    create: XOR<ComissaoUsuarioCreateInput, ComissaoUsuarioUncheckedCreateInput>
    /**
     * In case the ComissaoUsuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComissaoUsuarioUpdateInput, ComissaoUsuarioUncheckedUpdateInput>
  }

  /**
   * ComissaoUsuario delete
   */
  export type ComissaoUsuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComissaoUsuario
     */
    select?: ComissaoUsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComissaoUsuario
     */
    omit?: ComissaoUsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComissaoUsuarioInclude<ExtArgs> | null
    /**
     * Filter which ComissaoUsuario to delete.
     */
    where: ComissaoUsuarioWhereUniqueInput
  }

  /**
   * ComissaoUsuario deleteMany
   */
  export type ComissaoUsuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComissaoUsuarios to delete
     */
    where?: ComissaoUsuarioWhereInput
    /**
     * Limit how many ComissaoUsuarios to delete.
     */
    limit?: number
  }

  /**
   * ComissaoUsuario without action
   */
  export type ComissaoUsuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComissaoUsuario
     */
    select?: ComissaoUsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComissaoUsuario
     */
    omit?: ComissaoUsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComissaoUsuarioInclude<ExtArgs> | null
  }


  /**
   * Model Categoria
   */

  export type AggregateCategoria = {
    _count: CategoriaCountAggregateOutputType | null
    _avg: CategoriaAvgAggregateOutputType | null
    _sum: CategoriaSumAggregateOutputType | null
    _min: CategoriaMinAggregateOutputType | null
    _max: CategoriaMaxAggregateOutputType | null
  }

  export type CategoriaAvgAggregateOutputType = {
    idCategoria: number | null
    sorteioDanca: number | null
    idadeInicial: number | null
    idadeLimite: number | null
    provaId: number | null
    provaTeoricaId: number | null
    provaPraticaId: number | null
  }

  export type CategoriaSumAggregateOutputType = {
    idCategoria: number | null
    sorteioDanca: number | null
    idadeInicial: number | null
    idadeLimite: number | null
    provaId: number | null
    provaTeoricaId: number | null
    provaPraticaId: number | null
  }

  export type CategoriaMinAggregateOutputType = {
    idCategoria: number | null
    nomeCategoria: string | null
    escolaridade: string | null
    sorteioDanca: number | null
    idadeInicial: number | null
    idadeLimite: number | null
    provaId: number | null
    provaTeoricaId: number | null
    provaPraticaId: number | null
  }

  export type CategoriaMaxAggregateOutputType = {
    idCategoria: number | null
    nomeCategoria: string | null
    escolaridade: string | null
    sorteioDanca: number | null
    idadeInicial: number | null
    idadeLimite: number | null
    provaId: number | null
    provaTeoricaId: number | null
    provaPraticaId: number | null
  }

  export type CategoriaCountAggregateOutputType = {
    idCategoria: number
    nomeCategoria: number
    escolaridade: number
    sorteioDanca: number
    idadeInicial: number
    idadeLimite: number
    provaId: number
    provaTeoricaId: number
    provaPraticaId: number
    _all: number
  }


  export type CategoriaAvgAggregateInputType = {
    idCategoria?: true
    sorteioDanca?: true
    idadeInicial?: true
    idadeLimite?: true
    provaId?: true
    provaTeoricaId?: true
    provaPraticaId?: true
  }

  export type CategoriaSumAggregateInputType = {
    idCategoria?: true
    sorteioDanca?: true
    idadeInicial?: true
    idadeLimite?: true
    provaId?: true
    provaTeoricaId?: true
    provaPraticaId?: true
  }

  export type CategoriaMinAggregateInputType = {
    idCategoria?: true
    nomeCategoria?: true
    escolaridade?: true
    sorteioDanca?: true
    idadeInicial?: true
    idadeLimite?: true
    provaId?: true
    provaTeoricaId?: true
    provaPraticaId?: true
  }

  export type CategoriaMaxAggregateInputType = {
    idCategoria?: true
    nomeCategoria?: true
    escolaridade?: true
    sorteioDanca?: true
    idadeInicial?: true
    idadeLimite?: true
    provaId?: true
    provaTeoricaId?: true
    provaPraticaId?: true
  }

  export type CategoriaCountAggregateInputType = {
    idCategoria?: true
    nomeCategoria?: true
    escolaridade?: true
    sorteioDanca?: true
    idadeInicial?: true
    idadeLimite?: true
    provaId?: true
    provaTeoricaId?: true
    provaPraticaId?: true
    _all?: true
  }

  export type CategoriaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categoria to aggregate.
     */
    where?: CategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categorias to fetch.
     */
    orderBy?: CategoriaOrderByWithRelationInput | CategoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categorias
    **/
    _count?: true | CategoriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoriaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategoriaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriaMaxAggregateInputType
  }

  export type GetCategoriaAggregateType<T extends CategoriaAggregateArgs> = {
        [P in keyof T & keyof AggregateCategoria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategoria[P]>
      : GetScalarType<T[P], AggregateCategoria[P]>
  }




  export type CategoriaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoriaWhereInput
    orderBy?: CategoriaOrderByWithAggregationInput | CategoriaOrderByWithAggregationInput[]
    by: CategoriaScalarFieldEnum[] | CategoriaScalarFieldEnum
    having?: CategoriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriaCountAggregateInputType | true
    _avg?: CategoriaAvgAggregateInputType
    _sum?: CategoriaSumAggregateInputType
    _min?: CategoriaMinAggregateInputType
    _max?: CategoriaMaxAggregateInputType
  }

  export type CategoriaGroupByOutputType = {
    idCategoria: number
    nomeCategoria: string
    escolaridade: string
    sorteioDanca: number
    idadeInicial: number
    idadeLimite: number | null
    provaId: number | null
    provaTeoricaId: number | null
    provaPraticaId: number | null
    _count: CategoriaCountAggregateOutputType | null
    _avg: CategoriaAvgAggregateOutputType | null
    _sum: CategoriaSumAggregateOutputType | null
    _min: CategoriaMinAggregateOutputType | null
    _max: CategoriaMaxAggregateOutputType | null
  }

  type GetCategoriaGroupByPayload<T extends CategoriaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriaGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriaGroupByOutputType[P]>
        }
      >
    >


  export type CategoriaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idCategoria?: boolean
    nomeCategoria?: boolean
    escolaridade?: boolean
    sorteioDanca?: boolean
    idadeInicial?: boolean
    idadeLimite?: boolean
    provaId?: boolean
    provaTeoricaId?: boolean
    provaPraticaId?: boolean
    candidatos?: boolean | Categoria$candidatosArgs<ExtArgs>
    Prova?: boolean | Categoria$ProvaArgs<ExtArgs>
    ProvaTeorica?: boolean | Categoria$ProvaTeoricaArgs<ExtArgs>
    ProvaPratica?: boolean | Categoria$ProvaPraticaArgs<ExtArgs>
    _count?: boolean | CategoriaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoria"]>

  export type CategoriaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idCategoria?: boolean
    nomeCategoria?: boolean
    escolaridade?: boolean
    sorteioDanca?: boolean
    idadeInicial?: boolean
    idadeLimite?: boolean
    provaId?: boolean
    provaTeoricaId?: boolean
    provaPraticaId?: boolean
    Prova?: boolean | Categoria$ProvaArgs<ExtArgs>
    ProvaTeorica?: boolean | Categoria$ProvaTeoricaArgs<ExtArgs>
    ProvaPratica?: boolean | Categoria$ProvaPraticaArgs<ExtArgs>
  }, ExtArgs["result"]["categoria"]>

  export type CategoriaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idCategoria?: boolean
    nomeCategoria?: boolean
    escolaridade?: boolean
    sorteioDanca?: boolean
    idadeInicial?: boolean
    idadeLimite?: boolean
    provaId?: boolean
    provaTeoricaId?: boolean
    provaPraticaId?: boolean
    Prova?: boolean | Categoria$ProvaArgs<ExtArgs>
    ProvaTeorica?: boolean | Categoria$ProvaTeoricaArgs<ExtArgs>
    ProvaPratica?: boolean | Categoria$ProvaPraticaArgs<ExtArgs>
  }, ExtArgs["result"]["categoria"]>

  export type CategoriaSelectScalar = {
    idCategoria?: boolean
    nomeCategoria?: boolean
    escolaridade?: boolean
    sorteioDanca?: boolean
    idadeInicial?: boolean
    idadeLimite?: boolean
    provaId?: boolean
    provaTeoricaId?: boolean
    provaPraticaId?: boolean
  }

  export type CategoriaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idCategoria" | "nomeCategoria" | "escolaridade" | "sorteioDanca" | "idadeInicial" | "idadeLimite" | "provaId" | "provaTeoricaId" | "provaPraticaId", ExtArgs["result"]["categoria"]>
  export type CategoriaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    candidatos?: boolean | Categoria$candidatosArgs<ExtArgs>
    Prova?: boolean | Categoria$ProvaArgs<ExtArgs>
    ProvaTeorica?: boolean | Categoria$ProvaTeoricaArgs<ExtArgs>
    ProvaPratica?: boolean | Categoria$ProvaPraticaArgs<ExtArgs>
    _count?: boolean | CategoriaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoriaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Prova?: boolean | Categoria$ProvaArgs<ExtArgs>
    ProvaTeorica?: boolean | Categoria$ProvaTeoricaArgs<ExtArgs>
    ProvaPratica?: boolean | Categoria$ProvaPraticaArgs<ExtArgs>
  }
  export type CategoriaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Prova?: boolean | Categoria$ProvaArgs<ExtArgs>
    ProvaTeorica?: boolean | Categoria$ProvaTeoricaArgs<ExtArgs>
    ProvaPratica?: boolean | Categoria$ProvaPraticaArgs<ExtArgs>
  }

  export type $CategoriaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Categoria"
    objects: {
      candidatos: Prisma.$CandidatoPayload<ExtArgs>[]
      Prova: Prisma.$ProvaPayload<ExtArgs> | null
      ProvaTeorica: Prisma.$ProvaTeoricaPayload<ExtArgs> | null
      ProvaPratica: Prisma.$ProvaPraticaPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      idCategoria: number
      nomeCategoria: string
      escolaridade: string
      sorteioDanca: number
      idadeInicial: number
      idadeLimite: number | null
      provaId: number | null
      provaTeoricaId: number | null
      provaPraticaId: number | null
    }, ExtArgs["result"]["categoria"]>
    composites: {}
  }

  type CategoriaGetPayload<S extends boolean | null | undefined | CategoriaDefaultArgs> = $Result.GetResult<Prisma.$CategoriaPayload, S>

  type CategoriaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoriaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoriaCountAggregateInputType | true
    }

  export interface CategoriaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Categoria'], meta: { name: 'Categoria' } }
    /**
     * Find zero or one Categoria that matches the filter.
     * @param {CategoriaFindUniqueArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoriaFindUniqueArgs>(args: SelectSubset<T, CategoriaFindUniqueArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Categoria that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoriaFindUniqueOrThrowArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoriaFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoriaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Categoria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaFindFirstArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoriaFindFirstArgs>(args?: SelectSubset<T, CategoriaFindFirstArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Categoria that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaFindFirstOrThrowArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoriaFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoriaFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categorias
     * const categorias = await prisma.categoria.findMany()
     * 
     * // Get first 10 Categorias
     * const categorias = await prisma.categoria.findMany({ take: 10 })
     * 
     * // Only select the `idCategoria`
     * const categoriaWithIdCategoriaOnly = await prisma.categoria.findMany({ select: { idCategoria: true } })
     * 
     */
    findMany<T extends CategoriaFindManyArgs>(args?: SelectSubset<T, CategoriaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Categoria.
     * @param {CategoriaCreateArgs} args - Arguments to create a Categoria.
     * @example
     * // Create one Categoria
     * const Categoria = await prisma.categoria.create({
     *   data: {
     *     // ... data to create a Categoria
     *   }
     * })
     * 
     */
    create<T extends CategoriaCreateArgs>(args: SelectSubset<T, CategoriaCreateArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categorias.
     * @param {CategoriaCreateManyArgs} args - Arguments to create many Categorias.
     * @example
     * // Create many Categorias
     * const categoria = await prisma.categoria.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoriaCreateManyArgs>(args?: SelectSubset<T, CategoriaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categorias and returns the data saved in the database.
     * @param {CategoriaCreateManyAndReturnArgs} args - Arguments to create many Categorias.
     * @example
     * // Create many Categorias
     * const categoria = await prisma.categoria.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categorias and only return the `idCategoria`
     * const categoriaWithIdCategoriaOnly = await prisma.categoria.createManyAndReturn({
     *   select: { idCategoria: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoriaCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoriaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Categoria.
     * @param {CategoriaDeleteArgs} args - Arguments to delete one Categoria.
     * @example
     * // Delete one Categoria
     * const Categoria = await prisma.categoria.delete({
     *   where: {
     *     // ... filter to delete one Categoria
     *   }
     * })
     * 
     */
    delete<T extends CategoriaDeleteArgs>(args: SelectSubset<T, CategoriaDeleteArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Categoria.
     * @param {CategoriaUpdateArgs} args - Arguments to update one Categoria.
     * @example
     * // Update one Categoria
     * const categoria = await prisma.categoria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoriaUpdateArgs>(args: SelectSubset<T, CategoriaUpdateArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categorias.
     * @param {CategoriaDeleteManyArgs} args - Arguments to filter Categorias to delete.
     * @example
     * // Delete a few Categorias
     * const { count } = await prisma.categoria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoriaDeleteManyArgs>(args?: SelectSubset<T, CategoriaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categorias
     * const categoria = await prisma.categoria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoriaUpdateManyArgs>(args: SelectSubset<T, CategoriaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categorias and returns the data updated in the database.
     * @param {CategoriaUpdateManyAndReturnArgs} args - Arguments to update many Categorias.
     * @example
     * // Update many Categorias
     * const categoria = await prisma.categoria.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categorias and only return the `idCategoria`
     * const categoriaWithIdCategoriaOnly = await prisma.categoria.updateManyAndReturn({
     *   select: { idCategoria: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoriaUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoriaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Categoria.
     * @param {CategoriaUpsertArgs} args - Arguments to update or create a Categoria.
     * @example
     * // Update or create a Categoria
     * const categoria = await prisma.categoria.upsert({
     *   create: {
     *     // ... data to create a Categoria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categoria we want to update
     *   }
     * })
     */
    upsert<T extends CategoriaUpsertArgs>(args: SelectSubset<T, CategoriaUpsertArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaCountArgs} args - Arguments to filter Categorias to count.
     * @example
     * // Count the number of Categorias
     * const count = await prisma.categoria.count({
     *   where: {
     *     // ... the filter for the Categorias we want to count
     *   }
     * })
    **/
    count<T extends CategoriaCountArgs>(
      args?: Subset<T, CategoriaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriaAggregateArgs>(args: Subset<T, CategoriaAggregateArgs>): Prisma.PrismaPromise<GetCategoriaAggregateType<T>>

    /**
     * Group by Categoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoriaGroupByArgs['orderBy'] }
        : { orderBy?: CategoriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Categoria model
   */
  readonly fields: CategoriaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Categoria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoriaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    candidatos<T extends Categoria$candidatosArgs<ExtArgs> = {}>(args?: Subset<T, Categoria$candidatosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CandidatoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Prova<T extends Categoria$ProvaArgs<ExtArgs> = {}>(args?: Subset<T, Categoria$ProvaArgs<ExtArgs>>): Prisma__ProvaClient<$Result.GetResult<Prisma.$ProvaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ProvaTeorica<T extends Categoria$ProvaTeoricaArgs<ExtArgs> = {}>(args?: Subset<T, Categoria$ProvaTeoricaArgs<ExtArgs>>): Prisma__ProvaTeoricaClient<$Result.GetResult<Prisma.$ProvaTeoricaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ProvaPratica<T extends Categoria$ProvaPraticaArgs<ExtArgs> = {}>(args?: Subset<T, Categoria$ProvaPraticaArgs<ExtArgs>>): Prisma__ProvaPraticaClient<$Result.GetResult<Prisma.$ProvaPraticaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Categoria model
   */
  interface CategoriaFieldRefs {
    readonly idCategoria: FieldRef<"Categoria", 'Int'>
    readonly nomeCategoria: FieldRef<"Categoria", 'String'>
    readonly escolaridade: FieldRef<"Categoria", 'String'>
    readonly sorteioDanca: FieldRef<"Categoria", 'Int'>
    readonly idadeInicial: FieldRef<"Categoria", 'Int'>
    readonly idadeLimite: FieldRef<"Categoria", 'Int'>
    readonly provaId: FieldRef<"Categoria", 'Int'>
    readonly provaTeoricaId: FieldRef<"Categoria", 'Int'>
    readonly provaPraticaId: FieldRef<"Categoria", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Categoria findUnique
   */
  export type CategoriaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * Filter, which Categoria to fetch.
     */
    where: CategoriaWhereUniqueInput
  }

  /**
   * Categoria findUniqueOrThrow
   */
  export type CategoriaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * Filter, which Categoria to fetch.
     */
    where: CategoriaWhereUniqueInput
  }

  /**
   * Categoria findFirst
   */
  export type CategoriaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * Filter, which Categoria to fetch.
     */
    where?: CategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categorias to fetch.
     */
    orderBy?: CategoriaOrderByWithRelationInput | CategoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categorias.
     */
    cursor?: CategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categorias.
     */
    distinct?: CategoriaScalarFieldEnum | CategoriaScalarFieldEnum[]
  }

  /**
   * Categoria findFirstOrThrow
   */
  export type CategoriaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * Filter, which Categoria to fetch.
     */
    where?: CategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categorias to fetch.
     */
    orderBy?: CategoriaOrderByWithRelationInput | CategoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categorias.
     */
    cursor?: CategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categorias.
     */
    distinct?: CategoriaScalarFieldEnum | CategoriaScalarFieldEnum[]
  }

  /**
   * Categoria findMany
   */
  export type CategoriaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * Filter, which Categorias to fetch.
     */
    where?: CategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categorias to fetch.
     */
    orderBy?: CategoriaOrderByWithRelationInput | CategoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categorias.
     */
    cursor?: CategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categorias.
     */
    skip?: number
    distinct?: CategoriaScalarFieldEnum | CategoriaScalarFieldEnum[]
  }

  /**
   * Categoria create
   */
  export type CategoriaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * The data needed to create a Categoria.
     */
    data: XOR<CategoriaCreateInput, CategoriaUncheckedCreateInput>
  }

  /**
   * Categoria createMany
   */
  export type CategoriaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categorias.
     */
    data: CategoriaCreateManyInput | CategoriaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Categoria createManyAndReturn
   */
  export type CategoriaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null
    /**
     * The data used to create many Categorias.
     */
    data: CategoriaCreateManyInput | CategoriaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Categoria update
   */
  export type CategoriaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * The data needed to update a Categoria.
     */
    data: XOR<CategoriaUpdateInput, CategoriaUncheckedUpdateInput>
    /**
     * Choose, which Categoria to update.
     */
    where: CategoriaWhereUniqueInput
  }

  /**
   * Categoria updateMany
   */
  export type CategoriaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categorias.
     */
    data: XOR<CategoriaUpdateManyMutationInput, CategoriaUncheckedUpdateManyInput>
    /**
     * Filter which Categorias to update
     */
    where?: CategoriaWhereInput
    /**
     * Limit how many Categorias to update.
     */
    limit?: number
  }

  /**
   * Categoria updateManyAndReturn
   */
  export type CategoriaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null
    /**
     * The data used to update Categorias.
     */
    data: XOR<CategoriaUpdateManyMutationInput, CategoriaUncheckedUpdateManyInput>
    /**
     * Filter which Categorias to update
     */
    where?: CategoriaWhereInput
    /**
     * Limit how many Categorias to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Categoria upsert
   */
  export type CategoriaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * The filter to search for the Categoria to update in case it exists.
     */
    where: CategoriaWhereUniqueInput
    /**
     * In case the Categoria found by the `where` argument doesn't exist, create a new Categoria with this data.
     */
    create: XOR<CategoriaCreateInput, CategoriaUncheckedCreateInput>
    /**
     * In case the Categoria was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoriaUpdateInput, CategoriaUncheckedUpdateInput>
  }

  /**
   * Categoria delete
   */
  export type CategoriaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * Filter which Categoria to delete.
     */
    where: CategoriaWhereUniqueInput
  }

  /**
   * Categoria deleteMany
   */
  export type CategoriaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categorias to delete
     */
    where?: CategoriaWhereInput
    /**
     * Limit how many Categorias to delete.
     */
    limit?: number
  }

  /**
   * Categoria.candidatos
   */
  export type Categoria$candidatosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Candidato
     */
    select?: CandidatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Candidato
     */
    omit?: CandidatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CandidatoInclude<ExtArgs> | null
    where?: CandidatoWhereInput
    orderBy?: CandidatoOrderByWithRelationInput | CandidatoOrderByWithRelationInput[]
    cursor?: CandidatoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CandidatoScalarFieldEnum | CandidatoScalarFieldEnum[]
  }

  /**
   * Categoria.Prova
   */
  export type Categoria$ProvaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prova
     */
    select?: ProvaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prova
     */
    omit?: ProvaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaInclude<ExtArgs> | null
    where?: ProvaWhereInput
  }

  /**
   * Categoria.ProvaTeorica
   */
  export type Categoria$ProvaTeoricaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvaTeorica
     */
    select?: ProvaTeoricaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProvaTeorica
     */
    omit?: ProvaTeoricaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaTeoricaInclude<ExtArgs> | null
    where?: ProvaTeoricaWhereInput
  }

  /**
   * Categoria.ProvaPratica
   */
  export type Categoria$ProvaPraticaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvaPratica
     */
    select?: ProvaPraticaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProvaPratica
     */
    omit?: ProvaPraticaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaPraticaInclude<ExtArgs> | null
    where?: ProvaPraticaWhereInput
  }

  /**
   * Categoria without action
   */
  export type CategoriaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
  }


  /**
   * Model Avaliacao
   */

  export type AggregateAvaliacao = {
    _count: AvaliacaoCountAggregateOutputType | null
    _avg: AvaliacaoAvgAggregateOutputType | null
    _sum: AvaliacaoSumAggregateOutputType | null
    _min: AvaliacaoMinAggregateOutputType | null
    _max: AvaliacaoMaxAggregateOutputType | null
  }

  export type AvaliacaoAvgAggregateOutputType = {
    idAvalicao: number | null
    comissaoId: number | null
    avaliadorId: number | null
    provaId: number | null
    blocoProvaId: number | null
    nota: number | null
    candidatoId: number | null
    fichaCandidatoIdFicha: number | null
  }

  export type AvaliacaoSumAggregateOutputType = {
    idAvalicao: number | null
    comissaoId: number | null
    avaliadorId: number | null
    provaId: number | null
    blocoProvaId: number | null
    nota: number | null
    candidatoId: number | null
    fichaCandidatoIdFicha: number | null
  }

  export type AvaliacaoMinAggregateOutputType = {
    idAvalicao: number | null
    dataAvaliacao: Date | null
    comissaoId: number | null
    avaliadorId: number | null
    provaId: number | null
    blocoProvaId: number | null
    nota: number | null
    candidatoId: number | null
    fichaCandidatoIdFicha: number | null
  }

  export type AvaliacaoMaxAggregateOutputType = {
    idAvalicao: number | null
    dataAvaliacao: Date | null
    comissaoId: number | null
    avaliadorId: number | null
    provaId: number | null
    blocoProvaId: number | null
    nota: number | null
    candidatoId: number | null
    fichaCandidatoIdFicha: number | null
  }

  export type AvaliacaoCountAggregateOutputType = {
    idAvalicao: number
    dataAvaliacao: number
    comissaoId: number
    avaliadorId: number
    provaId: number
    blocoProvaId: number
    nota: number
    candidatoId: number
    fichaCandidatoIdFicha: number
    _all: number
  }


  export type AvaliacaoAvgAggregateInputType = {
    idAvalicao?: true
    comissaoId?: true
    avaliadorId?: true
    provaId?: true
    blocoProvaId?: true
    nota?: true
    candidatoId?: true
    fichaCandidatoIdFicha?: true
  }

  export type AvaliacaoSumAggregateInputType = {
    idAvalicao?: true
    comissaoId?: true
    avaliadorId?: true
    provaId?: true
    blocoProvaId?: true
    nota?: true
    candidatoId?: true
    fichaCandidatoIdFicha?: true
  }

  export type AvaliacaoMinAggregateInputType = {
    idAvalicao?: true
    dataAvaliacao?: true
    comissaoId?: true
    avaliadorId?: true
    provaId?: true
    blocoProvaId?: true
    nota?: true
    candidatoId?: true
    fichaCandidatoIdFicha?: true
  }

  export type AvaliacaoMaxAggregateInputType = {
    idAvalicao?: true
    dataAvaliacao?: true
    comissaoId?: true
    avaliadorId?: true
    provaId?: true
    blocoProvaId?: true
    nota?: true
    candidatoId?: true
    fichaCandidatoIdFicha?: true
  }

  export type AvaliacaoCountAggregateInputType = {
    idAvalicao?: true
    dataAvaliacao?: true
    comissaoId?: true
    avaliadorId?: true
    provaId?: true
    blocoProvaId?: true
    nota?: true
    candidatoId?: true
    fichaCandidatoIdFicha?: true
    _all?: true
  }

  export type AvaliacaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Avaliacao to aggregate.
     */
    where?: AvaliacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Avaliacaos to fetch.
     */
    orderBy?: AvaliacaoOrderByWithRelationInput | AvaliacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AvaliacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Avaliacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Avaliacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Avaliacaos
    **/
    _count?: true | AvaliacaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AvaliacaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AvaliacaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AvaliacaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AvaliacaoMaxAggregateInputType
  }

  export type GetAvaliacaoAggregateType<T extends AvaliacaoAggregateArgs> = {
        [P in keyof T & keyof AggregateAvaliacao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAvaliacao[P]>
      : GetScalarType<T[P], AggregateAvaliacao[P]>
  }




  export type AvaliacaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvaliacaoWhereInput
    orderBy?: AvaliacaoOrderByWithAggregationInput | AvaliacaoOrderByWithAggregationInput[]
    by: AvaliacaoScalarFieldEnum[] | AvaliacaoScalarFieldEnum
    having?: AvaliacaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AvaliacaoCountAggregateInputType | true
    _avg?: AvaliacaoAvgAggregateInputType
    _sum?: AvaliacaoSumAggregateInputType
    _min?: AvaliacaoMinAggregateInputType
    _max?: AvaliacaoMaxAggregateInputType
  }

  export type AvaliacaoGroupByOutputType = {
    idAvalicao: number
    dataAvaliacao: Date
    comissaoId: number
    avaliadorId: number
    provaId: number
    blocoProvaId: number | null
    nota: number
    candidatoId: number
    fichaCandidatoIdFicha: number | null
    _count: AvaliacaoCountAggregateOutputType | null
    _avg: AvaliacaoAvgAggregateOutputType | null
    _sum: AvaliacaoSumAggregateOutputType | null
    _min: AvaliacaoMinAggregateOutputType | null
    _max: AvaliacaoMaxAggregateOutputType | null
  }

  type GetAvaliacaoGroupByPayload<T extends AvaliacaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AvaliacaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AvaliacaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AvaliacaoGroupByOutputType[P]>
            : GetScalarType<T[P], AvaliacaoGroupByOutputType[P]>
        }
      >
    >


  export type AvaliacaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idAvalicao?: boolean
    dataAvaliacao?: boolean
    comissaoId?: boolean
    avaliadorId?: boolean
    provaId?: boolean
    blocoProvaId?: boolean
    nota?: boolean
    candidatoId?: boolean
    fichaCandidatoIdFicha?: boolean
    Comissao?: boolean | ComissaoDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    Prova?: boolean | Avaliacao$ProvaArgs<ExtArgs>
    BlocoProva?: boolean | Avaliacao$BlocoProvaArgs<ExtArgs>
    quesitos?: boolean | Avaliacao$quesitosArgs<ExtArgs>
    Candidato?: boolean | CandidatoDefaultArgs<ExtArgs>
    FichaCandidato?: boolean | Avaliacao$FichaCandidatoArgs<ExtArgs>
    _count?: boolean | AvaliacaoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["avaliacao"]>

  export type AvaliacaoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idAvalicao?: boolean
    dataAvaliacao?: boolean
    comissaoId?: boolean
    avaliadorId?: boolean
    provaId?: boolean
    blocoProvaId?: boolean
    nota?: boolean
    candidatoId?: boolean
    fichaCandidatoIdFicha?: boolean
    Comissao?: boolean | ComissaoDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    Prova?: boolean | Avaliacao$ProvaArgs<ExtArgs>
    BlocoProva?: boolean | Avaliacao$BlocoProvaArgs<ExtArgs>
    Candidato?: boolean | CandidatoDefaultArgs<ExtArgs>
    FichaCandidato?: boolean | Avaliacao$FichaCandidatoArgs<ExtArgs>
  }, ExtArgs["result"]["avaliacao"]>

  export type AvaliacaoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idAvalicao?: boolean
    dataAvaliacao?: boolean
    comissaoId?: boolean
    avaliadorId?: boolean
    provaId?: boolean
    blocoProvaId?: boolean
    nota?: boolean
    candidatoId?: boolean
    fichaCandidatoIdFicha?: boolean
    Comissao?: boolean | ComissaoDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    Prova?: boolean | Avaliacao$ProvaArgs<ExtArgs>
    BlocoProva?: boolean | Avaliacao$BlocoProvaArgs<ExtArgs>
    Candidato?: boolean | CandidatoDefaultArgs<ExtArgs>
    FichaCandidato?: boolean | Avaliacao$FichaCandidatoArgs<ExtArgs>
  }, ExtArgs["result"]["avaliacao"]>

  export type AvaliacaoSelectScalar = {
    idAvalicao?: boolean
    dataAvaliacao?: boolean
    comissaoId?: boolean
    avaliadorId?: boolean
    provaId?: boolean
    blocoProvaId?: boolean
    nota?: boolean
    candidatoId?: boolean
    fichaCandidatoIdFicha?: boolean
  }

  export type AvaliacaoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idAvalicao" | "dataAvaliacao" | "comissaoId" | "avaliadorId" | "provaId" | "blocoProvaId" | "nota" | "candidatoId" | "fichaCandidatoIdFicha", ExtArgs["result"]["avaliacao"]>
  export type AvaliacaoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Comissao?: boolean | ComissaoDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    Prova?: boolean | Avaliacao$ProvaArgs<ExtArgs>
    BlocoProva?: boolean | Avaliacao$BlocoProvaArgs<ExtArgs>
    quesitos?: boolean | Avaliacao$quesitosArgs<ExtArgs>
    Candidato?: boolean | CandidatoDefaultArgs<ExtArgs>
    FichaCandidato?: boolean | Avaliacao$FichaCandidatoArgs<ExtArgs>
    _count?: boolean | AvaliacaoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AvaliacaoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Comissao?: boolean | ComissaoDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    Prova?: boolean | Avaliacao$ProvaArgs<ExtArgs>
    BlocoProva?: boolean | Avaliacao$BlocoProvaArgs<ExtArgs>
    Candidato?: boolean | CandidatoDefaultArgs<ExtArgs>
    FichaCandidato?: boolean | Avaliacao$FichaCandidatoArgs<ExtArgs>
  }
  export type AvaliacaoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Comissao?: boolean | ComissaoDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    Prova?: boolean | Avaliacao$ProvaArgs<ExtArgs>
    BlocoProva?: boolean | Avaliacao$BlocoProvaArgs<ExtArgs>
    Candidato?: boolean | CandidatoDefaultArgs<ExtArgs>
    FichaCandidato?: boolean | Avaliacao$FichaCandidatoArgs<ExtArgs>
  }

  export type $AvaliacaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Avaliacao"
    objects: {
      Comissao: Prisma.$ComissaoPayload<ExtArgs>
      Usuario: Prisma.$UsuarioPayload<ExtArgs>
      Prova: Prisma.$ProvaPayload<ExtArgs> | null
      BlocoProva: Prisma.$BlocoProvaPayload<ExtArgs> | null
      quesitos: Prisma.$QuesitosPayload<ExtArgs>[]
      Candidato: Prisma.$CandidatoPayload<ExtArgs>
      FichaCandidato: Prisma.$FichaCandidatoPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      idAvalicao: number
      dataAvaliacao: Date
      comissaoId: number
      avaliadorId: number
      provaId: number
      blocoProvaId: number | null
      nota: number
      candidatoId: number
      fichaCandidatoIdFicha: number | null
    }, ExtArgs["result"]["avaliacao"]>
    composites: {}
  }

  type AvaliacaoGetPayload<S extends boolean | null | undefined | AvaliacaoDefaultArgs> = $Result.GetResult<Prisma.$AvaliacaoPayload, S>

  type AvaliacaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AvaliacaoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AvaliacaoCountAggregateInputType | true
    }

  export interface AvaliacaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Avaliacao'], meta: { name: 'Avaliacao' } }
    /**
     * Find zero or one Avaliacao that matches the filter.
     * @param {AvaliacaoFindUniqueArgs} args - Arguments to find a Avaliacao
     * @example
     * // Get one Avaliacao
     * const avaliacao = await prisma.avaliacao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AvaliacaoFindUniqueArgs>(args: SelectSubset<T, AvaliacaoFindUniqueArgs<ExtArgs>>): Prisma__AvaliacaoClient<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Avaliacao that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AvaliacaoFindUniqueOrThrowArgs} args - Arguments to find a Avaliacao
     * @example
     * // Get one Avaliacao
     * const avaliacao = await prisma.avaliacao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AvaliacaoFindUniqueOrThrowArgs>(args: SelectSubset<T, AvaliacaoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AvaliacaoClient<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Avaliacao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvaliacaoFindFirstArgs} args - Arguments to find a Avaliacao
     * @example
     * // Get one Avaliacao
     * const avaliacao = await prisma.avaliacao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AvaliacaoFindFirstArgs>(args?: SelectSubset<T, AvaliacaoFindFirstArgs<ExtArgs>>): Prisma__AvaliacaoClient<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Avaliacao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvaliacaoFindFirstOrThrowArgs} args - Arguments to find a Avaliacao
     * @example
     * // Get one Avaliacao
     * const avaliacao = await prisma.avaliacao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AvaliacaoFindFirstOrThrowArgs>(args?: SelectSubset<T, AvaliacaoFindFirstOrThrowArgs<ExtArgs>>): Prisma__AvaliacaoClient<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Avaliacaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvaliacaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Avaliacaos
     * const avaliacaos = await prisma.avaliacao.findMany()
     * 
     * // Get first 10 Avaliacaos
     * const avaliacaos = await prisma.avaliacao.findMany({ take: 10 })
     * 
     * // Only select the `idAvalicao`
     * const avaliacaoWithIdAvalicaoOnly = await prisma.avaliacao.findMany({ select: { idAvalicao: true } })
     * 
     */
    findMany<T extends AvaliacaoFindManyArgs>(args?: SelectSubset<T, AvaliacaoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Avaliacao.
     * @param {AvaliacaoCreateArgs} args - Arguments to create a Avaliacao.
     * @example
     * // Create one Avaliacao
     * const Avaliacao = await prisma.avaliacao.create({
     *   data: {
     *     // ... data to create a Avaliacao
     *   }
     * })
     * 
     */
    create<T extends AvaliacaoCreateArgs>(args: SelectSubset<T, AvaliacaoCreateArgs<ExtArgs>>): Prisma__AvaliacaoClient<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Avaliacaos.
     * @param {AvaliacaoCreateManyArgs} args - Arguments to create many Avaliacaos.
     * @example
     * // Create many Avaliacaos
     * const avaliacao = await prisma.avaliacao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AvaliacaoCreateManyArgs>(args?: SelectSubset<T, AvaliacaoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Avaliacaos and returns the data saved in the database.
     * @param {AvaliacaoCreateManyAndReturnArgs} args - Arguments to create many Avaliacaos.
     * @example
     * // Create many Avaliacaos
     * const avaliacao = await prisma.avaliacao.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Avaliacaos and only return the `idAvalicao`
     * const avaliacaoWithIdAvalicaoOnly = await prisma.avaliacao.createManyAndReturn({
     *   select: { idAvalicao: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AvaliacaoCreateManyAndReturnArgs>(args?: SelectSubset<T, AvaliacaoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Avaliacao.
     * @param {AvaliacaoDeleteArgs} args - Arguments to delete one Avaliacao.
     * @example
     * // Delete one Avaliacao
     * const Avaliacao = await prisma.avaliacao.delete({
     *   where: {
     *     // ... filter to delete one Avaliacao
     *   }
     * })
     * 
     */
    delete<T extends AvaliacaoDeleteArgs>(args: SelectSubset<T, AvaliacaoDeleteArgs<ExtArgs>>): Prisma__AvaliacaoClient<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Avaliacao.
     * @param {AvaliacaoUpdateArgs} args - Arguments to update one Avaliacao.
     * @example
     * // Update one Avaliacao
     * const avaliacao = await prisma.avaliacao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AvaliacaoUpdateArgs>(args: SelectSubset<T, AvaliacaoUpdateArgs<ExtArgs>>): Prisma__AvaliacaoClient<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Avaliacaos.
     * @param {AvaliacaoDeleteManyArgs} args - Arguments to filter Avaliacaos to delete.
     * @example
     * // Delete a few Avaliacaos
     * const { count } = await prisma.avaliacao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AvaliacaoDeleteManyArgs>(args?: SelectSubset<T, AvaliacaoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Avaliacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvaliacaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Avaliacaos
     * const avaliacao = await prisma.avaliacao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AvaliacaoUpdateManyArgs>(args: SelectSubset<T, AvaliacaoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Avaliacaos and returns the data updated in the database.
     * @param {AvaliacaoUpdateManyAndReturnArgs} args - Arguments to update many Avaliacaos.
     * @example
     * // Update many Avaliacaos
     * const avaliacao = await prisma.avaliacao.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Avaliacaos and only return the `idAvalicao`
     * const avaliacaoWithIdAvalicaoOnly = await prisma.avaliacao.updateManyAndReturn({
     *   select: { idAvalicao: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AvaliacaoUpdateManyAndReturnArgs>(args: SelectSubset<T, AvaliacaoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Avaliacao.
     * @param {AvaliacaoUpsertArgs} args - Arguments to update or create a Avaliacao.
     * @example
     * // Update or create a Avaliacao
     * const avaliacao = await prisma.avaliacao.upsert({
     *   create: {
     *     // ... data to create a Avaliacao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Avaliacao we want to update
     *   }
     * })
     */
    upsert<T extends AvaliacaoUpsertArgs>(args: SelectSubset<T, AvaliacaoUpsertArgs<ExtArgs>>): Prisma__AvaliacaoClient<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Avaliacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvaliacaoCountArgs} args - Arguments to filter Avaliacaos to count.
     * @example
     * // Count the number of Avaliacaos
     * const count = await prisma.avaliacao.count({
     *   where: {
     *     // ... the filter for the Avaliacaos we want to count
     *   }
     * })
    **/
    count<T extends AvaliacaoCountArgs>(
      args?: Subset<T, AvaliacaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AvaliacaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Avaliacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvaliacaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AvaliacaoAggregateArgs>(args: Subset<T, AvaliacaoAggregateArgs>): Prisma.PrismaPromise<GetAvaliacaoAggregateType<T>>

    /**
     * Group by Avaliacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvaliacaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AvaliacaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AvaliacaoGroupByArgs['orderBy'] }
        : { orderBy?: AvaliacaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AvaliacaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAvaliacaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Avaliacao model
   */
  readonly fields: AvaliacaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Avaliacao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AvaliacaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Comissao<T extends ComissaoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComissaoDefaultArgs<ExtArgs>>): Prisma__ComissaoClient<$Result.GetResult<Prisma.$ComissaoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Prova<T extends Avaliacao$ProvaArgs<ExtArgs> = {}>(args?: Subset<T, Avaliacao$ProvaArgs<ExtArgs>>): Prisma__ProvaClient<$Result.GetResult<Prisma.$ProvaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    BlocoProva<T extends Avaliacao$BlocoProvaArgs<ExtArgs> = {}>(args?: Subset<T, Avaliacao$BlocoProvaArgs<ExtArgs>>): Prisma__BlocoProvaClient<$Result.GetResult<Prisma.$BlocoProvaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    quesitos<T extends Avaliacao$quesitosArgs<ExtArgs> = {}>(args?: Subset<T, Avaliacao$quesitosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuesitosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Candidato<T extends CandidatoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CandidatoDefaultArgs<ExtArgs>>): Prisma__CandidatoClient<$Result.GetResult<Prisma.$CandidatoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    FichaCandidato<T extends Avaliacao$FichaCandidatoArgs<ExtArgs> = {}>(args?: Subset<T, Avaliacao$FichaCandidatoArgs<ExtArgs>>): Prisma__FichaCandidatoClient<$Result.GetResult<Prisma.$FichaCandidatoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Avaliacao model
   */
  interface AvaliacaoFieldRefs {
    readonly idAvalicao: FieldRef<"Avaliacao", 'Int'>
    readonly dataAvaliacao: FieldRef<"Avaliacao", 'DateTime'>
    readonly comissaoId: FieldRef<"Avaliacao", 'Int'>
    readonly avaliadorId: FieldRef<"Avaliacao", 'Int'>
    readonly provaId: FieldRef<"Avaliacao", 'Int'>
    readonly blocoProvaId: FieldRef<"Avaliacao", 'Int'>
    readonly nota: FieldRef<"Avaliacao", 'Float'>
    readonly candidatoId: FieldRef<"Avaliacao", 'Int'>
    readonly fichaCandidatoIdFicha: FieldRef<"Avaliacao", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Avaliacao findUnique
   */
  export type AvaliacaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avaliacao
     */
    omit?: AvaliacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    /**
     * Filter, which Avaliacao to fetch.
     */
    where: AvaliacaoWhereUniqueInput
  }

  /**
   * Avaliacao findUniqueOrThrow
   */
  export type AvaliacaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avaliacao
     */
    omit?: AvaliacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    /**
     * Filter, which Avaliacao to fetch.
     */
    where: AvaliacaoWhereUniqueInput
  }

  /**
   * Avaliacao findFirst
   */
  export type AvaliacaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avaliacao
     */
    omit?: AvaliacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    /**
     * Filter, which Avaliacao to fetch.
     */
    where?: AvaliacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Avaliacaos to fetch.
     */
    orderBy?: AvaliacaoOrderByWithRelationInput | AvaliacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Avaliacaos.
     */
    cursor?: AvaliacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Avaliacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Avaliacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Avaliacaos.
     */
    distinct?: AvaliacaoScalarFieldEnum | AvaliacaoScalarFieldEnum[]
  }

  /**
   * Avaliacao findFirstOrThrow
   */
  export type AvaliacaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avaliacao
     */
    omit?: AvaliacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    /**
     * Filter, which Avaliacao to fetch.
     */
    where?: AvaliacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Avaliacaos to fetch.
     */
    orderBy?: AvaliacaoOrderByWithRelationInput | AvaliacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Avaliacaos.
     */
    cursor?: AvaliacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Avaliacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Avaliacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Avaliacaos.
     */
    distinct?: AvaliacaoScalarFieldEnum | AvaliacaoScalarFieldEnum[]
  }

  /**
   * Avaliacao findMany
   */
  export type AvaliacaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avaliacao
     */
    omit?: AvaliacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    /**
     * Filter, which Avaliacaos to fetch.
     */
    where?: AvaliacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Avaliacaos to fetch.
     */
    orderBy?: AvaliacaoOrderByWithRelationInput | AvaliacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Avaliacaos.
     */
    cursor?: AvaliacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Avaliacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Avaliacaos.
     */
    skip?: number
    distinct?: AvaliacaoScalarFieldEnum | AvaliacaoScalarFieldEnum[]
  }

  /**
   * Avaliacao create
   */
  export type AvaliacaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avaliacao
     */
    omit?: AvaliacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    /**
     * The data needed to create a Avaliacao.
     */
    data: XOR<AvaliacaoCreateInput, AvaliacaoUncheckedCreateInput>
  }

  /**
   * Avaliacao createMany
   */
  export type AvaliacaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Avaliacaos.
     */
    data: AvaliacaoCreateManyInput | AvaliacaoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Avaliacao createManyAndReturn
   */
  export type AvaliacaoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Avaliacao
     */
    omit?: AvaliacaoOmit<ExtArgs> | null
    /**
     * The data used to create many Avaliacaos.
     */
    data: AvaliacaoCreateManyInput | AvaliacaoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Avaliacao update
   */
  export type AvaliacaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avaliacao
     */
    omit?: AvaliacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    /**
     * The data needed to update a Avaliacao.
     */
    data: XOR<AvaliacaoUpdateInput, AvaliacaoUncheckedUpdateInput>
    /**
     * Choose, which Avaliacao to update.
     */
    where: AvaliacaoWhereUniqueInput
  }

  /**
   * Avaliacao updateMany
   */
  export type AvaliacaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Avaliacaos.
     */
    data: XOR<AvaliacaoUpdateManyMutationInput, AvaliacaoUncheckedUpdateManyInput>
    /**
     * Filter which Avaliacaos to update
     */
    where?: AvaliacaoWhereInput
    /**
     * Limit how many Avaliacaos to update.
     */
    limit?: number
  }

  /**
   * Avaliacao updateManyAndReturn
   */
  export type AvaliacaoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Avaliacao
     */
    omit?: AvaliacaoOmit<ExtArgs> | null
    /**
     * The data used to update Avaliacaos.
     */
    data: XOR<AvaliacaoUpdateManyMutationInput, AvaliacaoUncheckedUpdateManyInput>
    /**
     * Filter which Avaliacaos to update
     */
    where?: AvaliacaoWhereInput
    /**
     * Limit how many Avaliacaos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Avaliacao upsert
   */
  export type AvaliacaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avaliacao
     */
    omit?: AvaliacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    /**
     * The filter to search for the Avaliacao to update in case it exists.
     */
    where: AvaliacaoWhereUniqueInput
    /**
     * In case the Avaliacao found by the `where` argument doesn't exist, create a new Avaliacao with this data.
     */
    create: XOR<AvaliacaoCreateInput, AvaliacaoUncheckedCreateInput>
    /**
     * In case the Avaliacao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AvaliacaoUpdateInput, AvaliacaoUncheckedUpdateInput>
  }

  /**
   * Avaliacao delete
   */
  export type AvaliacaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avaliacao
     */
    omit?: AvaliacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    /**
     * Filter which Avaliacao to delete.
     */
    where: AvaliacaoWhereUniqueInput
  }

  /**
   * Avaliacao deleteMany
   */
  export type AvaliacaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Avaliacaos to delete
     */
    where?: AvaliacaoWhereInput
    /**
     * Limit how many Avaliacaos to delete.
     */
    limit?: number
  }

  /**
   * Avaliacao.Prova
   */
  export type Avaliacao$ProvaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prova
     */
    select?: ProvaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prova
     */
    omit?: ProvaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaInclude<ExtArgs> | null
    where?: ProvaWhereInput
  }

  /**
   * Avaliacao.BlocoProva
   */
  export type Avaliacao$BlocoProvaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlocoProva
     */
    select?: BlocoProvaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlocoProva
     */
    omit?: BlocoProvaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlocoProvaInclude<ExtArgs> | null
    where?: BlocoProvaWhereInput
  }

  /**
   * Avaliacao.quesitos
   */
  export type Avaliacao$quesitosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quesitos
     */
    select?: QuesitosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quesitos
     */
    omit?: QuesitosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuesitosInclude<ExtArgs> | null
    where?: QuesitosWhereInput
    orderBy?: QuesitosOrderByWithRelationInput | QuesitosOrderByWithRelationInput[]
    cursor?: QuesitosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuesitosScalarFieldEnum | QuesitosScalarFieldEnum[]
  }

  /**
   * Avaliacao.FichaCandidato
   */
  export type Avaliacao$FichaCandidatoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FichaCandidato
     */
    select?: FichaCandidatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FichaCandidato
     */
    omit?: FichaCandidatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FichaCandidatoInclude<ExtArgs> | null
    where?: FichaCandidatoWhereInput
  }

  /**
   * Avaliacao without action
   */
  export type AvaliacaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avaliacao
     */
    omit?: AvaliacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
  }


  /**
   * Model Prova
   */

  export type AggregateProva = {
    _count: ProvaCountAggregateOutputType | null
    _avg: ProvaAvgAggregateOutputType | null
    _sum: ProvaSumAggregateOutputType | null
    _min: ProvaMinAggregateOutputType | null
    _max: ProvaMaxAggregateOutputType | null
  }

  export type ProvaAvgAggregateOutputType = {
    idProva: number | null
    notaMaxima: number | null
  }

  export type ProvaSumAggregateOutputType = {
    idProva: number | null
    notaMaxima: number | null
  }

  export type ProvaMinAggregateOutputType = {
    idProva: number | null
    nomeProva: string | null
    notaMaxima: number | null
  }

  export type ProvaMaxAggregateOutputType = {
    idProva: number | null
    nomeProva: string | null
    notaMaxima: number | null
  }

  export type ProvaCountAggregateOutputType = {
    idProva: number
    nomeProva: number
    notaMaxima: number
    _all: number
  }


  export type ProvaAvgAggregateInputType = {
    idProva?: true
    notaMaxima?: true
  }

  export type ProvaSumAggregateInputType = {
    idProva?: true
    notaMaxima?: true
  }

  export type ProvaMinAggregateInputType = {
    idProva?: true
    nomeProva?: true
    notaMaxima?: true
  }

  export type ProvaMaxAggregateInputType = {
    idProva?: true
    nomeProva?: true
    notaMaxima?: true
  }

  export type ProvaCountAggregateInputType = {
    idProva?: true
    nomeProva?: true
    notaMaxima?: true
    _all?: true
  }

  export type ProvaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prova to aggregate.
     */
    where?: ProvaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prova to fetch.
     */
    orderBy?: ProvaOrderByWithRelationInput | ProvaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProvaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prova from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prova.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prova
    **/
    _count?: true | ProvaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProvaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProvaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProvaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProvaMaxAggregateInputType
  }

  export type GetProvaAggregateType<T extends ProvaAggregateArgs> = {
        [P in keyof T & keyof AggregateProva]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProva[P]>
      : GetScalarType<T[P], AggregateProva[P]>
  }




  export type ProvaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProvaWhereInput
    orderBy?: ProvaOrderByWithAggregationInput | ProvaOrderByWithAggregationInput[]
    by: ProvaScalarFieldEnum[] | ProvaScalarFieldEnum
    having?: ProvaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProvaCountAggregateInputType | true
    _avg?: ProvaAvgAggregateInputType
    _sum?: ProvaSumAggregateInputType
    _min?: ProvaMinAggregateInputType
    _max?: ProvaMaxAggregateInputType
  }

  export type ProvaGroupByOutputType = {
    idProva: number
    nomeProva: string
    notaMaxima: number
    _count: ProvaCountAggregateOutputType | null
    _avg: ProvaAvgAggregateOutputType | null
    _sum: ProvaSumAggregateOutputType | null
    _min: ProvaMinAggregateOutputType | null
    _max: ProvaMaxAggregateOutputType | null
  }

  type GetProvaGroupByPayload<T extends ProvaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProvaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProvaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProvaGroupByOutputType[P]>
            : GetScalarType<T[P], ProvaGroupByOutputType[P]>
        }
      >
    >


  export type ProvaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idProva?: boolean
    nomeProva?: boolean
    notaMaxima?: boolean
    categorias?: boolean | Prova$categoriasArgs<ExtArgs>
    ProvaTeorica?: boolean | Prova$ProvaTeoricaArgs<ExtArgs>
    ProvaPratica?: boolean | Prova$ProvaPraticaArgs<ExtArgs>
    recursos?: boolean | Prova$recursosArgs<ExtArgs>
    Avaliacao?: boolean | Prova$AvaliacaoArgs<ExtArgs>
    _count?: boolean | ProvaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prova"]>

  export type ProvaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idProva?: boolean
    nomeProva?: boolean
    notaMaxima?: boolean
  }, ExtArgs["result"]["prova"]>

  export type ProvaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idProva?: boolean
    nomeProva?: boolean
    notaMaxima?: boolean
  }, ExtArgs["result"]["prova"]>

  export type ProvaSelectScalar = {
    idProva?: boolean
    nomeProva?: boolean
    notaMaxima?: boolean
  }

  export type ProvaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idProva" | "nomeProva" | "notaMaxima", ExtArgs["result"]["prova"]>
  export type ProvaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categorias?: boolean | Prova$categoriasArgs<ExtArgs>
    ProvaTeorica?: boolean | Prova$ProvaTeoricaArgs<ExtArgs>
    ProvaPratica?: boolean | Prova$ProvaPraticaArgs<ExtArgs>
    recursos?: boolean | Prova$recursosArgs<ExtArgs>
    Avaliacao?: boolean | Prova$AvaliacaoArgs<ExtArgs>
    _count?: boolean | ProvaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProvaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProvaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProvaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Prova"
    objects: {
      categorias: Prisma.$CategoriaPayload<ExtArgs>[]
      ProvaTeorica: Prisma.$ProvaTeoricaPayload<ExtArgs>[]
      ProvaPratica: Prisma.$ProvaPraticaPayload<ExtArgs>[]
      recursos: Prisma.$RecursoPayload<ExtArgs>[]
      Avaliacao: Prisma.$AvaliacaoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idProva: number
      nomeProva: string
      notaMaxima: number
    }, ExtArgs["result"]["prova"]>
    composites: {}
  }

  type ProvaGetPayload<S extends boolean | null | undefined | ProvaDefaultArgs> = $Result.GetResult<Prisma.$ProvaPayload, S>

  type ProvaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProvaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProvaCountAggregateInputType | true
    }

  export interface ProvaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Prova'], meta: { name: 'Prova' } }
    /**
     * Find zero or one Prova that matches the filter.
     * @param {ProvaFindUniqueArgs} args - Arguments to find a Prova
     * @example
     * // Get one Prova
     * const prova = await prisma.prova.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProvaFindUniqueArgs>(args: SelectSubset<T, ProvaFindUniqueArgs<ExtArgs>>): Prisma__ProvaClient<$Result.GetResult<Prisma.$ProvaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Prova that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProvaFindUniqueOrThrowArgs} args - Arguments to find a Prova
     * @example
     * // Get one Prova
     * const prova = await prisma.prova.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProvaFindUniqueOrThrowArgs>(args: SelectSubset<T, ProvaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProvaClient<$Result.GetResult<Prisma.$ProvaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Prova that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvaFindFirstArgs} args - Arguments to find a Prova
     * @example
     * // Get one Prova
     * const prova = await prisma.prova.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProvaFindFirstArgs>(args?: SelectSubset<T, ProvaFindFirstArgs<ExtArgs>>): Prisma__ProvaClient<$Result.GetResult<Prisma.$ProvaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Prova that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvaFindFirstOrThrowArgs} args - Arguments to find a Prova
     * @example
     * // Get one Prova
     * const prova = await prisma.prova.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProvaFindFirstOrThrowArgs>(args?: SelectSubset<T, ProvaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProvaClient<$Result.GetResult<Prisma.$ProvaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Prova that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prova
     * const prova = await prisma.prova.findMany()
     * 
     * // Get first 10 Prova
     * const prova = await prisma.prova.findMany({ take: 10 })
     * 
     * // Only select the `idProva`
     * const provaWithIdProvaOnly = await prisma.prova.findMany({ select: { idProva: true } })
     * 
     */
    findMany<T extends ProvaFindManyArgs>(args?: SelectSubset<T, ProvaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProvaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Prova.
     * @param {ProvaCreateArgs} args - Arguments to create a Prova.
     * @example
     * // Create one Prova
     * const Prova = await prisma.prova.create({
     *   data: {
     *     // ... data to create a Prova
     *   }
     * })
     * 
     */
    create<T extends ProvaCreateArgs>(args: SelectSubset<T, ProvaCreateArgs<ExtArgs>>): Prisma__ProvaClient<$Result.GetResult<Prisma.$ProvaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Prova.
     * @param {ProvaCreateManyArgs} args - Arguments to create many Prova.
     * @example
     * // Create many Prova
     * const prova = await prisma.prova.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProvaCreateManyArgs>(args?: SelectSubset<T, ProvaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Prova and returns the data saved in the database.
     * @param {ProvaCreateManyAndReturnArgs} args - Arguments to create many Prova.
     * @example
     * // Create many Prova
     * const prova = await prisma.prova.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Prova and only return the `idProva`
     * const provaWithIdProvaOnly = await prisma.prova.createManyAndReturn({
     *   select: { idProva: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProvaCreateManyAndReturnArgs>(args?: SelectSubset<T, ProvaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProvaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Prova.
     * @param {ProvaDeleteArgs} args - Arguments to delete one Prova.
     * @example
     * // Delete one Prova
     * const Prova = await prisma.prova.delete({
     *   where: {
     *     // ... filter to delete one Prova
     *   }
     * })
     * 
     */
    delete<T extends ProvaDeleteArgs>(args: SelectSubset<T, ProvaDeleteArgs<ExtArgs>>): Prisma__ProvaClient<$Result.GetResult<Prisma.$ProvaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Prova.
     * @param {ProvaUpdateArgs} args - Arguments to update one Prova.
     * @example
     * // Update one Prova
     * const prova = await prisma.prova.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProvaUpdateArgs>(args: SelectSubset<T, ProvaUpdateArgs<ExtArgs>>): Prisma__ProvaClient<$Result.GetResult<Prisma.$ProvaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Prova.
     * @param {ProvaDeleteManyArgs} args - Arguments to filter Prova to delete.
     * @example
     * // Delete a few Prova
     * const { count } = await prisma.prova.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProvaDeleteManyArgs>(args?: SelectSubset<T, ProvaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prova.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prova
     * const prova = await prisma.prova.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProvaUpdateManyArgs>(args: SelectSubset<T, ProvaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prova and returns the data updated in the database.
     * @param {ProvaUpdateManyAndReturnArgs} args - Arguments to update many Prova.
     * @example
     * // Update many Prova
     * const prova = await prisma.prova.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Prova and only return the `idProva`
     * const provaWithIdProvaOnly = await prisma.prova.updateManyAndReturn({
     *   select: { idProva: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProvaUpdateManyAndReturnArgs>(args: SelectSubset<T, ProvaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProvaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Prova.
     * @param {ProvaUpsertArgs} args - Arguments to update or create a Prova.
     * @example
     * // Update or create a Prova
     * const prova = await prisma.prova.upsert({
     *   create: {
     *     // ... data to create a Prova
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prova we want to update
     *   }
     * })
     */
    upsert<T extends ProvaUpsertArgs>(args: SelectSubset<T, ProvaUpsertArgs<ExtArgs>>): Prisma__ProvaClient<$Result.GetResult<Prisma.$ProvaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Prova.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvaCountArgs} args - Arguments to filter Prova to count.
     * @example
     * // Count the number of Prova
     * const count = await prisma.prova.count({
     *   where: {
     *     // ... the filter for the Prova we want to count
     *   }
     * })
    **/
    count<T extends ProvaCountArgs>(
      args?: Subset<T, ProvaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProvaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prova.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProvaAggregateArgs>(args: Subset<T, ProvaAggregateArgs>): Prisma.PrismaPromise<GetProvaAggregateType<T>>

    /**
     * Group by Prova.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProvaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProvaGroupByArgs['orderBy'] }
        : { orderBy?: ProvaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProvaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProvaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Prova model
   */
  readonly fields: ProvaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Prova.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProvaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categorias<T extends Prova$categoriasArgs<ExtArgs> = {}>(args?: Subset<T, Prova$categoriasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ProvaTeorica<T extends Prova$ProvaTeoricaArgs<ExtArgs> = {}>(args?: Subset<T, Prova$ProvaTeoricaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProvaTeoricaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ProvaPratica<T extends Prova$ProvaPraticaArgs<ExtArgs> = {}>(args?: Subset<T, Prova$ProvaPraticaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProvaPraticaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recursos<T extends Prova$recursosArgs<ExtArgs> = {}>(args?: Subset<T, Prova$recursosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecursoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Avaliacao<T extends Prova$AvaliacaoArgs<ExtArgs> = {}>(args?: Subset<T, Prova$AvaliacaoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Prova model
   */
  interface ProvaFieldRefs {
    readonly idProva: FieldRef<"Prova", 'Int'>
    readonly nomeProva: FieldRef<"Prova", 'String'>
    readonly notaMaxima: FieldRef<"Prova", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Prova findUnique
   */
  export type ProvaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prova
     */
    select?: ProvaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prova
     */
    omit?: ProvaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaInclude<ExtArgs> | null
    /**
     * Filter, which Prova to fetch.
     */
    where: ProvaWhereUniqueInput
  }

  /**
   * Prova findUniqueOrThrow
   */
  export type ProvaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prova
     */
    select?: ProvaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prova
     */
    omit?: ProvaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaInclude<ExtArgs> | null
    /**
     * Filter, which Prova to fetch.
     */
    where: ProvaWhereUniqueInput
  }

  /**
   * Prova findFirst
   */
  export type ProvaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prova
     */
    select?: ProvaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prova
     */
    omit?: ProvaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaInclude<ExtArgs> | null
    /**
     * Filter, which Prova to fetch.
     */
    where?: ProvaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prova to fetch.
     */
    orderBy?: ProvaOrderByWithRelationInput | ProvaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prova.
     */
    cursor?: ProvaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prova from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prova.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prova.
     */
    distinct?: ProvaScalarFieldEnum | ProvaScalarFieldEnum[]
  }

  /**
   * Prova findFirstOrThrow
   */
  export type ProvaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prova
     */
    select?: ProvaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prova
     */
    omit?: ProvaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaInclude<ExtArgs> | null
    /**
     * Filter, which Prova to fetch.
     */
    where?: ProvaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prova to fetch.
     */
    orderBy?: ProvaOrderByWithRelationInput | ProvaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prova.
     */
    cursor?: ProvaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prova from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prova.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prova.
     */
    distinct?: ProvaScalarFieldEnum | ProvaScalarFieldEnum[]
  }

  /**
   * Prova findMany
   */
  export type ProvaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prova
     */
    select?: ProvaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prova
     */
    omit?: ProvaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaInclude<ExtArgs> | null
    /**
     * Filter, which Prova to fetch.
     */
    where?: ProvaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prova to fetch.
     */
    orderBy?: ProvaOrderByWithRelationInput | ProvaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prova.
     */
    cursor?: ProvaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prova from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prova.
     */
    skip?: number
    distinct?: ProvaScalarFieldEnum | ProvaScalarFieldEnum[]
  }

  /**
   * Prova create
   */
  export type ProvaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prova
     */
    select?: ProvaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prova
     */
    omit?: ProvaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaInclude<ExtArgs> | null
    /**
     * The data needed to create a Prova.
     */
    data: XOR<ProvaCreateInput, ProvaUncheckedCreateInput>
  }

  /**
   * Prova createMany
   */
  export type ProvaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Prova.
     */
    data: ProvaCreateManyInput | ProvaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Prova createManyAndReturn
   */
  export type ProvaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prova
     */
    select?: ProvaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Prova
     */
    omit?: ProvaOmit<ExtArgs> | null
    /**
     * The data used to create many Prova.
     */
    data: ProvaCreateManyInput | ProvaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Prova update
   */
  export type ProvaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prova
     */
    select?: ProvaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prova
     */
    omit?: ProvaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaInclude<ExtArgs> | null
    /**
     * The data needed to update a Prova.
     */
    data: XOR<ProvaUpdateInput, ProvaUncheckedUpdateInput>
    /**
     * Choose, which Prova to update.
     */
    where: ProvaWhereUniqueInput
  }

  /**
   * Prova updateMany
   */
  export type ProvaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Prova.
     */
    data: XOR<ProvaUpdateManyMutationInput, ProvaUncheckedUpdateManyInput>
    /**
     * Filter which Prova to update
     */
    where?: ProvaWhereInput
    /**
     * Limit how many Prova to update.
     */
    limit?: number
  }

  /**
   * Prova updateManyAndReturn
   */
  export type ProvaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prova
     */
    select?: ProvaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Prova
     */
    omit?: ProvaOmit<ExtArgs> | null
    /**
     * The data used to update Prova.
     */
    data: XOR<ProvaUpdateManyMutationInput, ProvaUncheckedUpdateManyInput>
    /**
     * Filter which Prova to update
     */
    where?: ProvaWhereInput
    /**
     * Limit how many Prova to update.
     */
    limit?: number
  }

  /**
   * Prova upsert
   */
  export type ProvaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prova
     */
    select?: ProvaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prova
     */
    omit?: ProvaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaInclude<ExtArgs> | null
    /**
     * The filter to search for the Prova to update in case it exists.
     */
    where: ProvaWhereUniqueInput
    /**
     * In case the Prova found by the `where` argument doesn't exist, create a new Prova with this data.
     */
    create: XOR<ProvaCreateInput, ProvaUncheckedCreateInput>
    /**
     * In case the Prova was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProvaUpdateInput, ProvaUncheckedUpdateInput>
  }

  /**
   * Prova delete
   */
  export type ProvaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prova
     */
    select?: ProvaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prova
     */
    omit?: ProvaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaInclude<ExtArgs> | null
    /**
     * Filter which Prova to delete.
     */
    where: ProvaWhereUniqueInput
  }

  /**
   * Prova deleteMany
   */
  export type ProvaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prova to delete
     */
    where?: ProvaWhereInput
    /**
     * Limit how many Prova to delete.
     */
    limit?: number
  }

  /**
   * Prova.categorias
   */
  export type Prova$categoriasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    where?: CategoriaWhereInput
    orderBy?: CategoriaOrderByWithRelationInput | CategoriaOrderByWithRelationInput[]
    cursor?: CategoriaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoriaScalarFieldEnum | CategoriaScalarFieldEnum[]
  }

  /**
   * Prova.ProvaTeorica
   */
  export type Prova$ProvaTeoricaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvaTeorica
     */
    select?: ProvaTeoricaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProvaTeorica
     */
    omit?: ProvaTeoricaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaTeoricaInclude<ExtArgs> | null
    where?: ProvaTeoricaWhereInput
    orderBy?: ProvaTeoricaOrderByWithRelationInput | ProvaTeoricaOrderByWithRelationInput[]
    cursor?: ProvaTeoricaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProvaTeoricaScalarFieldEnum | ProvaTeoricaScalarFieldEnum[]
  }

  /**
   * Prova.ProvaPratica
   */
  export type Prova$ProvaPraticaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvaPratica
     */
    select?: ProvaPraticaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProvaPratica
     */
    omit?: ProvaPraticaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaPraticaInclude<ExtArgs> | null
    where?: ProvaPraticaWhereInput
    orderBy?: ProvaPraticaOrderByWithRelationInput | ProvaPraticaOrderByWithRelationInput[]
    cursor?: ProvaPraticaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProvaPraticaScalarFieldEnum | ProvaPraticaScalarFieldEnum[]
  }

  /**
   * Prova.recursos
   */
  export type Prova$recursosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recurso
     */
    select?: RecursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recurso
     */
    omit?: RecursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecursoInclude<ExtArgs> | null
    where?: RecursoWhereInput
    orderBy?: RecursoOrderByWithRelationInput | RecursoOrderByWithRelationInput[]
    cursor?: RecursoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecursoScalarFieldEnum | RecursoScalarFieldEnum[]
  }

  /**
   * Prova.Avaliacao
   */
  export type Prova$AvaliacaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avaliacao
     */
    omit?: AvaliacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    where?: AvaliacaoWhereInput
    orderBy?: AvaliacaoOrderByWithRelationInput | AvaliacaoOrderByWithRelationInput[]
    cursor?: AvaliacaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AvaliacaoScalarFieldEnum | AvaliacaoScalarFieldEnum[]
  }

  /**
   * Prova without action
   */
  export type ProvaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prova
     */
    select?: ProvaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prova
     */
    omit?: ProvaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaInclude<ExtArgs> | null
  }


  /**
   * Model ProvaTeorica
   */

  export type AggregateProvaTeorica = {
    _count: ProvaTeoricaCountAggregateOutputType | null
    _avg: ProvaTeoricaAvgAggregateOutputType | null
    _sum: ProvaTeoricaSumAggregateOutputType | null
    _min: ProvaTeoricaMinAggregateOutputType | null
    _max: ProvaTeoricaMaxAggregateOutputType | null
  }

  export type ProvaTeoricaAvgAggregateOutputType = {
    idprovaTeorica: number | null
    provaId: number | null
    numQuestao: number | null
  }

  export type ProvaTeoricaSumAggregateOutputType = {
    idprovaTeorica: number | null
    provaId: number | null
    numQuestao: number | null
  }

  export type ProvaTeoricaMinAggregateOutputType = {
    idprovaTeorica: number | null
    provaId: number | null
    gabaritoOficinal: Bytes | null
    numQuestao: number | null
  }

  export type ProvaTeoricaMaxAggregateOutputType = {
    idprovaTeorica: number | null
    provaId: number | null
    gabaritoOficinal: Bytes | null
    numQuestao: number | null
  }

  export type ProvaTeoricaCountAggregateOutputType = {
    idprovaTeorica: number
    provaId: number
    gabaritoOficinal: number
    numQuestao: number
    _all: number
  }


  export type ProvaTeoricaAvgAggregateInputType = {
    idprovaTeorica?: true
    provaId?: true
    numQuestao?: true
  }

  export type ProvaTeoricaSumAggregateInputType = {
    idprovaTeorica?: true
    provaId?: true
    numQuestao?: true
  }

  export type ProvaTeoricaMinAggregateInputType = {
    idprovaTeorica?: true
    provaId?: true
    gabaritoOficinal?: true
    numQuestao?: true
  }

  export type ProvaTeoricaMaxAggregateInputType = {
    idprovaTeorica?: true
    provaId?: true
    gabaritoOficinal?: true
    numQuestao?: true
  }

  export type ProvaTeoricaCountAggregateInputType = {
    idprovaTeorica?: true
    provaId?: true
    gabaritoOficinal?: true
    numQuestao?: true
    _all?: true
  }

  export type ProvaTeoricaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProvaTeorica to aggregate.
     */
    where?: ProvaTeoricaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProvaTeoricas to fetch.
     */
    orderBy?: ProvaTeoricaOrderByWithRelationInput | ProvaTeoricaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProvaTeoricaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProvaTeoricas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProvaTeoricas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProvaTeoricas
    **/
    _count?: true | ProvaTeoricaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProvaTeoricaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProvaTeoricaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProvaTeoricaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProvaTeoricaMaxAggregateInputType
  }

  export type GetProvaTeoricaAggregateType<T extends ProvaTeoricaAggregateArgs> = {
        [P in keyof T & keyof AggregateProvaTeorica]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProvaTeorica[P]>
      : GetScalarType<T[P], AggregateProvaTeorica[P]>
  }




  export type ProvaTeoricaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProvaTeoricaWhereInput
    orderBy?: ProvaTeoricaOrderByWithAggregationInput | ProvaTeoricaOrderByWithAggregationInput[]
    by: ProvaTeoricaScalarFieldEnum[] | ProvaTeoricaScalarFieldEnum
    having?: ProvaTeoricaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProvaTeoricaCountAggregateInputType | true
    _avg?: ProvaTeoricaAvgAggregateInputType
    _sum?: ProvaTeoricaSumAggregateInputType
    _min?: ProvaTeoricaMinAggregateInputType
    _max?: ProvaTeoricaMaxAggregateInputType
  }

  export type ProvaTeoricaGroupByOutputType = {
    idprovaTeorica: number
    provaId: number | null
    gabaritoOficinal: Bytes
    numQuestao: number
    _count: ProvaTeoricaCountAggregateOutputType | null
    _avg: ProvaTeoricaAvgAggregateOutputType | null
    _sum: ProvaTeoricaSumAggregateOutputType | null
    _min: ProvaTeoricaMinAggregateOutputType | null
    _max: ProvaTeoricaMaxAggregateOutputType | null
  }

  type GetProvaTeoricaGroupByPayload<T extends ProvaTeoricaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProvaTeoricaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProvaTeoricaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProvaTeoricaGroupByOutputType[P]>
            : GetScalarType<T[P], ProvaTeoricaGroupByOutputType[P]>
        }
      >
    >


  export type ProvaTeoricaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idprovaTeorica?: boolean
    provaId?: boolean
    gabaritoOficinal?: boolean
    numQuestao?: boolean
    Prova?: boolean | ProvaTeorica$ProvaArgs<ExtArgs>
    quesitos?: boolean | ProvaTeorica$quesitosArgs<ExtArgs>
    Categoria?: boolean | ProvaTeorica$CategoriaArgs<ExtArgs>
    Recurso?: boolean | ProvaTeorica$RecursoArgs<ExtArgs>
    _count?: boolean | ProvaTeoricaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["provaTeorica"]>

  export type ProvaTeoricaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idprovaTeorica?: boolean
    provaId?: boolean
    gabaritoOficinal?: boolean
    numQuestao?: boolean
    Prova?: boolean | ProvaTeorica$ProvaArgs<ExtArgs>
  }, ExtArgs["result"]["provaTeorica"]>

  export type ProvaTeoricaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idprovaTeorica?: boolean
    provaId?: boolean
    gabaritoOficinal?: boolean
    numQuestao?: boolean
    Prova?: boolean | ProvaTeorica$ProvaArgs<ExtArgs>
  }, ExtArgs["result"]["provaTeorica"]>

  export type ProvaTeoricaSelectScalar = {
    idprovaTeorica?: boolean
    provaId?: boolean
    gabaritoOficinal?: boolean
    numQuestao?: boolean
  }

  export type ProvaTeoricaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idprovaTeorica" | "provaId" | "gabaritoOficinal" | "numQuestao", ExtArgs["result"]["provaTeorica"]>
  export type ProvaTeoricaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Prova?: boolean | ProvaTeorica$ProvaArgs<ExtArgs>
    quesitos?: boolean | ProvaTeorica$quesitosArgs<ExtArgs>
    Categoria?: boolean | ProvaTeorica$CategoriaArgs<ExtArgs>
    Recurso?: boolean | ProvaTeorica$RecursoArgs<ExtArgs>
    _count?: boolean | ProvaTeoricaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProvaTeoricaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Prova?: boolean | ProvaTeorica$ProvaArgs<ExtArgs>
  }
  export type ProvaTeoricaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Prova?: boolean | ProvaTeorica$ProvaArgs<ExtArgs>
  }

  export type $ProvaTeoricaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProvaTeorica"
    objects: {
      Prova: Prisma.$ProvaPayload<ExtArgs> | null
      quesitos: Prisma.$QuesitosPayload<ExtArgs>[]
      Categoria: Prisma.$CategoriaPayload<ExtArgs>[]
      Recurso: Prisma.$RecursoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idprovaTeorica: number
      provaId: number | null
      gabaritoOficinal: Prisma.Bytes
      numQuestao: number
    }, ExtArgs["result"]["provaTeorica"]>
    composites: {}
  }

  type ProvaTeoricaGetPayload<S extends boolean | null | undefined | ProvaTeoricaDefaultArgs> = $Result.GetResult<Prisma.$ProvaTeoricaPayload, S>

  type ProvaTeoricaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProvaTeoricaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProvaTeoricaCountAggregateInputType | true
    }

  export interface ProvaTeoricaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProvaTeorica'], meta: { name: 'ProvaTeorica' } }
    /**
     * Find zero or one ProvaTeorica that matches the filter.
     * @param {ProvaTeoricaFindUniqueArgs} args - Arguments to find a ProvaTeorica
     * @example
     * // Get one ProvaTeorica
     * const provaTeorica = await prisma.provaTeorica.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProvaTeoricaFindUniqueArgs>(args: SelectSubset<T, ProvaTeoricaFindUniqueArgs<ExtArgs>>): Prisma__ProvaTeoricaClient<$Result.GetResult<Prisma.$ProvaTeoricaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProvaTeorica that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProvaTeoricaFindUniqueOrThrowArgs} args - Arguments to find a ProvaTeorica
     * @example
     * // Get one ProvaTeorica
     * const provaTeorica = await prisma.provaTeorica.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProvaTeoricaFindUniqueOrThrowArgs>(args: SelectSubset<T, ProvaTeoricaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProvaTeoricaClient<$Result.GetResult<Prisma.$ProvaTeoricaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProvaTeorica that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvaTeoricaFindFirstArgs} args - Arguments to find a ProvaTeorica
     * @example
     * // Get one ProvaTeorica
     * const provaTeorica = await prisma.provaTeorica.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProvaTeoricaFindFirstArgs>(args?: SelectSubset<T, ProvaTeoricaFindFirstArgs<ExtArgs>>): Prisma__ProvaTeoricaClient<$Result.GetResult<Prisma.$ProvaTeoricaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProvaTeorica that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvaTeoricaFindFirstOrThrowArgs} args - Arguments to find a ProvaTeorica
     * @example
     * // Get one ProvaTeorica
     * const provaTeorica = await prisma.provaTeorica.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProvaTeoricaFindFirstOrThrowArgs>(args?: SelectSubset<T, ProvaTeoricaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProvaTeoricaClient<$Result.GetResult<Prisma.$ProvaTeoricaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProvaTeoricas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvaTeoricaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProvaTeoricas
     * const provaTeoricas = await prisma.provaTeorica.findMany()
     * 
     * // Get first 10 ProvaTeoricas
     * const provaTeoricas = await prisma.provaTeorica.findMany({ take: 10 })
     * 
     * // Only select the `idprovaTeorica`
     * const provaTeoricaWithIdprovaTeoricaOnly = await prisma.provaTeorica.findMany({ select: { idprovaTeorica: true } })
     * 
     */
    findMany<T extends ProvaTeoricaFindManyArgs>(args?: SelectSubset<T, ProvaTeoricaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProvaTeoricaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProvaTeorica.
     * @param {ProvaTeoricaCreateArgs} args - Arguments to create a ProvaTeorica.
     * @example
     * // Create one ProvaTeorica
     * const ProvaTeorica = await prisma.provaTeorica.create({
     *   data: {
     *     // ... data to create a ProvaTeorica
     *   }
     * })
     * 
     */
    create<T extends ProvaTeoricaCreateArgs>(args: SelectSubset<T, ProvaTeoricaCreateArgs<ExtArgs>>): Prisma__ProvaTeoricaClient<$Result.GetResult<Prisma.$ProvaTeoricaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProvaTeoricas.
     * @param {ProvaTeoricaCreateManyArgs} args - Arguments to create many ProvaTeoricas.
     * @example
     * // Create many ProvaTeoricas
     * const provaTeorica = await prisma.provaTeorica.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProvaTeoricaCreateManyArgs>(args?: SelectSubset<T, ProvaTeoricaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProvaTeoricas and returns the data saved in the database.
     * @param {ProvaTeoricaCreateManyAndReturnArgs} args - Arguments to create many ProvaTeoricas.
     * @example
     * // Create many ProvaTeoricas
     * const provaTeorica = await prisma.provaTeorica.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProvaTeoricas and only return the `idprovaTeorica`
     * const provaTeoricaWithIdprovaTeoricaOnly = await prisma.provaTeorica.createManyAndReturn({
     *   select: { idprovaTeorica: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProvaTeoricaCreateManyAndReturnArgs>(args?: SelectSubset<T, ProvaTeoricaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProvaTeoricaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProvaTeorica.
     * @param {ProvaTeoricaDeleteArgs} args - Arguments to delete one ProvaTeorica.
     * @example
     * // Delete one ProvaTeorica
     * const ProvaTeorica = await prisma.provaTeorica.delete({
     *   where: {
     *     // ... filter to delete one ProvaTeorica
     *   }
     * })
     * 
     */
    delete<T extends ProvaTeoricaDeleteArgs>(args: SelectSubset<T, ProvaTeoricaDeleteArgs<ExtArgs>>): Prisma__ProvaTeoricaClient<$Result.GetResult<Prisma.$ProvaTeoricaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProvaTeorica.
     * @param {ProvaTeoricaUpdateArgs} args - Arguments to update one ProvaTeorica.
     * @example
     * // Update one ProvaTeorica
     * const provaTeorica = await prisma.provaTeorica.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProvaTeoricaUpdateArgs>(args: SelectSubset<T, ProvaTeoricaUpdateArgs<ExtArgs>>): Prisma__ProvaTeoricaClient<$Result.GetResult<Prisma.$ProvaTeoricaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProvaTeoricas.
     * @param {ProvaTeoricaDeleteManyArgs} args - Arguments to filter ProvaTeoricas to delete.
     * @example
     * // Delete a few ProvaTeoricas
     * const { count } = await prisma.provaTeorica.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProvaTeoricaDeleteManyArgs>(args?: SelectSubset<T, ProvaTeoricaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProvaTeoricas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvaTeoricaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProvaTeoricas
     * const provaTeorica = await prisma.provaTeorica.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProvaTeoricaUpdateManyArgs>(args: SelectSubset<T, ProvaTeoricaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProvaTeoricas and returns the data updated in the database.
     * @param {ProvaTeoricaUpdateManyAndReturnArgs} args - Arguments to update many ProvaTeoricas.
     * @example
     * // Update many ProvaTeoricas
     * const provaTeorica = await prisma.provaTeorica.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProvaTeoricas and only return the `idprovaTeorica`
     * const provaTeoricaWithIdprovaTeoricaOnly = await prisma.provaTeorica.updateManyAndReturn({
     *   select: { idprovaTeorica: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProvaTeoricaUpdateManyAndReturnArgs>(args: SelectSubset<T, ProvaTeoricaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProvaTeoricaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProvaTeorica.
     * @param {ProvaTeoricaUpsertArgs} args - Arguments to update or create a ProvaTeorica.
     * @example
     * // Update or create a ProvaTeorica
     * const provaTeorica = await prisma.provaTeorica.upsert({
     *   create: {
     *     // ... data to create a ProvaTeorica
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProvaTeorica we want to update
     *   }
     * })
     */
    upsert<T extends ProvaTeoricaUpsertArgs>(args: SelectSubset<T, ProvaTeoricaUpsertArgs<ExtArgs>>): Prisma__ProvaTeoricaClient<$Result.GetResult<Prisma.$ProvaTeoricaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProvaTeoricas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvaTeoricaCountArgs} args - Arguments to filter ProvaTeoricas to count.
     * @example
     * // Count the number of ProvaTeoricas
     * const count = await prisma.provaTeorica.count({
     *   where: {
     *     // ... the filter for the ProvaTeoricas we want to count
     *   }
     * })
    **/
    count<T extends ProvaTeoricaCountArgs>(
      args?: Subset<T, ProvaTeoricaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProvaTeoricaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProvaTeorica.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvaTeoricaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProvaTeoricaAggregateArgs>(args: Subset<T, ProvaTeoricaAggregateArgs>): Prisma.PrismaPromise<GetProvaTeoricaAggregateType<T>>

    /**
     * Group by ProvaTeorica.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvaTeoricaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProvaTeoricaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProvaTeoricaGroupByArgs['orderBy'] }
        : { orderBy?: ProvaTeoricaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProvaTeoricaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProvaTeoricaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProvaTeorica model
   */
  readonly fields: ProvaTeoricaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProvaTeorica.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProvaTeoricaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Prova<T extends ProvaTeorica$ProvaArgs<ExtArgs> = {}>(args?: Subset<T, ProvaTeorica$ProvaArgs<ExtArgs>>): Prisma__ProvaClient<$Result.GetResult<Prisma.$ProvaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    quesitos<T extends ProvaTeorica$quesitosArgs<ExtArgs> = {}>(args?: Subset<T, ProvaTeorica$quesitosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuesitosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Categoria<T extends ProvaTeorica$CategoriaArgs<ExtArgs> = {}>(args?: Subset<T, ProvaTeorica$CategoriaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Recurso<T extends ProvaTeorica$RecursoArgs<ExtArgs> = {}>(args?: Subset<T, ProvaTeorica$RecursoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecursoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProvaTeorica model
   */
  interface ProvaTeoricaFieldRefs {
    readonly idprovaTeorica: FieldRef<"ProvaTeorica", 'Int'>
    readonly provaId: FieldRef<"ProvaTeorica", 'Int'>
    readonly gabaritoOficinal: FieldRef<"ProvaTeorica", 'Bytes'>
    readonly numQuestao: FieldRef<"ProvaTeorica", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProvaTeorica findUnique
   */
  export type ProvaTeoricaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvaTeorica
     */
    select?: ProvaTeoricaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProvaTeorica
     */
    omit?: ProvaTeoricaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaTeoricaInclude<ExtArgs> | null
    /**
     * Filter, which ProvaTeorica to fetch.
     */
    where: ProvaTeoricaWhereUniqueInput
  }

  /**
   * ProvaTeorica findUniqueOrThrow
   */
  export type ProvaTeoricaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvaTeorica
     */
    select?: ProvaTeoricaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProvaTeorica
     */
    omit?: ProvaTeoricaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaTeoricaInclude<ExtArgs> | null
    /**
     * Filter, which ProvaTeorica to fetch.
     */
    where: ProvaTeoricaWhereUniqueInput
  }

  /**
   * ProvaTeorica findFirst
   */
  export type ProvaTeoricaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvaTeorica
     */
    select?: ProvaTeoricaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProvaTeorica
     */
    omit?: ProvaTeoricaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaTeoricaInclude<ExtArgs> | null
    /**
     * Filter, which ProvaTeorica to fetch.
     */
    where?: ProvaTeoricaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProvaTeoricas to fetch.
     */
    orderBy?: ProvaTeoricaOrderByWithRelationInput | ProvaTeoricaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProvaTeoricas.
     */
    cursor?: ProvaTeoricaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProvaTeoricas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProvaTeoricas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProvaTeoricas.
     */
    distinct?: ProvaTeoricaScalarFieldEnum | ProvaTeoricaScalarFieldEnum[]
  }

  /**
   * ProvaTeorica findFirstOrThrow
   */
  export type ProvaTeoricaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvaTeorica
     */
    select?: ProvaTeoricaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProvaTeorica
     */
    omit?: ProvaTeoricaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaTeoricaInclude<ExtArgs> | null
    /**
     * Filter, which ProvaTeorica to fetch.
     */
    where?: ProvaTeoricaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProvaTeoricas to fetch.
     */
    orderBy?: ProvaTeoricaOrderByWithRelationInput | ProvaTeoricaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProvaTeoricas.
     */
    cursor?: ProvaTeoricaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProvaTeoricas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProvaTeoricas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProvaTeoricas.
     */
    distinct?: ProvaTeoricaScalarFieldEnum | ProvaTeoricaScalarFieldEnum[]
  }

  /**
   * ProvaTeorica findMany
   */
  export type ProvaTeoricaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvaTeorica
     */
    select?: ProvaTeoricaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProvaTeorica
     */
    omit?: ProvaTeoricaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaTeoricaInclude<ExtArgs> | null
    /**
     * Filter, which ProvaTeoricas to fetch.
     */
    where?: ProvaTeoricaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProvaTeoricas to fetch.
     */
    orderBy?: ProvaTeoricaOrderByWithRelationInput | ProvaTeoricaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProvaTeoricas.
     */
    cursor?: ProvaTeoricaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProvaTeoricas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProvaTeoricas.
     */
    skip?: number
    distinct?: ProvaTeoricaScalarFieldEnum | ProvaTeoricaScalarFieldEnum[]
  }

  /**
   * ProvaTeorica create
   */
  export type ProvaTeoricaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvaTeorica
     */
    select?: ProvaTeoricaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProvaTeorica
     */
    omit?: ProvaTeoricaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaTeoricaInclude<ExtArgs> | null
    /**
     * The data needed to create a ProvaTeorica.
     */
    data: XOR<ProvaTeoricaCreateInput, ProvaTeoricaUncheckedCreateInput>
  }

  /**
   * ProvaTeorica createMany
   */
  export type ProvaTeoricaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProvaTeoricas.
     */
    data: ProvaTeoricaCreateManyInput | ProvaTeoricaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProvaTeorica createManyAndReturn
   */
  export type ProvaTeoricaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvaTeorica
     */
    select?: ProvaTeoricaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProvaTeorica
     */
    omit?: ProvaTeoricaOmit<ExtArgs> | null
    /**
     * The data used to create many ProvaTeoricas.
     */
    data: ProvaTeoricaCreateManyInput | ProvaTeoricaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaTeoricaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProvaTeorica update
   */
  export type ProvaTeoricaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvaTeorica
     */
    select?: ProvaTeoricaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProvaTeorica
     */
    omit?: ProvaTeoricaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaTeoricaInclude<ExtArgs> | null
    /**
     * The data needed to update a ProvaTeorica.
     */
    data: XOR<ProvaTeoricaUpdateInput, ProvaTeoricaUncheckedUpdateInput>
    /**
     * Choose, which ProvaTeorica to update.
     */
    where: ProvaTeoricaWhereUniqueInput
  }

  /**
   * ProvaTeorica updateMany
   */
  export type ProvaTeoricaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProvaTeoricas.
     */
    data: XOR<ProvaTeoricaUpdateManyMutationInput, ProvaTeoricaUncheckedUpdateManyInput>
    /**
     * Filter which ProvaTeoricas to update
     */
    where?: ProvaTeoricaWhereInput
    /**
     * Limit how many ProvaTeoricas to update.
     */
    limit?: number
  }

  /**
   * ProvaTeorica updateManyAndReturn
   */
  export type ProvaTeoricaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvaTeorica
     */
    select?: ProvaTeoricaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProvaTeorica
     */
    omit?: ProvaTeoricaOmit<ExtArgs> | null
    /**
     * The data used to update ProvaTeoricas.
     */
    data: XOR<ProvaTeoricaUpdateManyMutationInput, ProvaTeoricaUncheckedUpdateManyInput>
    /**
     * Filter which ProvaTeoricas to update
     */
    where?: ProvaTeoricaWhereInput
    /**
     * Limit how many ProvaTeoricas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaTeoricaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProvaTeorica upsert
   */
  export type ProvaTeoricaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvaTeorica
     */
    select?: ProvaTeoricaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProvaTeorica
     */
    omit?: ProvaTeoricaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaTeoricaInclude<ExtArgs> | null
    /**
     * The filter to search for the ProvaTeorica to update in case it exists.
     */
    where: ProvaTeoricaWhereUniqueInput
    /**
     * In case the ProvaTeorica found by the `where` argument doesn't exist, create a new ProvaTeorica with this data.
     */
    create: XOR<ProvaTeoricaCreateInput, ProvaTeoricaUncheckedCreateInput>
    /**
     * In case the ProvaTeorica was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProvaTeoricaUpdateInput, ProvaTeoricaUncheckedUpdateInput>
  }

  /**
   * ProvaTeorica delete
   */
  export type ProvaTeoricaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvaTeorica
     */
    select?: ProvaTeoricaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProvaTeorica
     */
    omit?: ProvaTeoricaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaTeoricaInclude<ExtArgs> | null
    /**
     * Filter which ProvaTeorica to delete.
     */
    where: ProvaTeoricaWhereUniqueInput
  }

  /**
   * ProvaTeorica deleteMany
   */
  export type ProvaTeoricaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProvaTeoricas to delete
     */
    where?: ProvaTeoricaWhereInput
    /**
     * Limit how many ProvaTeoricas to delete.
     */
    limit?: number
  }

  /**
   * ProvaTeorica.Prova
   */
  export type ProvaTeorica$ProvaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prova
     */
    select?: ProvaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prova
     */
    omit?: ProvaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaInclude<ExtArgs> | null
    where?: ProvaWhereInput
  }

  /**
   * ProvaTeorica.quesitos
   */
  export type ProvaTeorica$quesitosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quesitos
     */
    select?: QuesitosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quesitos
     */
    omit?: QuesitosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuesitosInclude<ExtArgs> | null
    where?: QuesitosWhereInput
    orderBy?: QuesitosOrderByWithRelationInput | QuesitosOrderByWithRelationInput[]
    cursor?: QuesitosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuesitosScalarFieldEnum | QuesitosScalarFieldEnum[]
  }

  /**
   * ProvaTeorica.Categoria
   */
  export type ProvaTeorica$CategoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    where?: CategoriaWhereInput
    orderBy?: CategoriaOrderByWithRelationInput | CategoriaOrderByWithRelationInput[]
    cursor?: CategoriaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoriaScalarFieldEnum | CategoriaScalarFieldEnum[]
  }

  /**
   * ProvaTeorica.Recurso
   */
  export type ProvaTeorica$RecursoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recurso
     */
    select?: RecursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recurso
     */
    omit?: RecursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecursoInclude<ExtArgs> | null
    where?: RecursoWhereInput
    orderBy?: RecursoOrderByWithRelationInput | RecursoOrderByWithRelationInput[]
    cursor?: RecursoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecursoScalarFieldEnum | RecursoScalarFieldEnum[]
  }

  /**
   * ProvaTeorica without action
   */
  export type ProvaTeoricaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvaTeorica
     */
    select?: ProvaTeoricaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProvaTeorica
     */
    omit?: ProvaTeoricaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaTeoricaInclude<ExtArgs> | null
  }


  /**
   * Model ProvaPratica
   */

  export type AggregateProvaPratica = {
    _count: ProvaPraticaCountAggregateOutputType | null
    _avg: ProvaPraticaAvgAggregateOutputType | null
    _sum: ProvaPraticaSumAggregateOutputType | null
    _min: ProvaPraticaMinAggregateOutputType | null
    _max: ProvaPraticaMaxAggregateOutputType | null
  }

  export type ProvaPraticaAvgAggregateOutputType = {
    idProvaPratica: number | null
    provaId: number | null
  }

  export type ProvaPraticaSumAggregateOutputType = {
    idProvaPratica: number | null
    provaId: number | null
  }

  export type ProvaPraticaMinAggregateOutputType = {
    idProvaPratica: number | null
    provaId: number | null
  }

  export type ProvaPraticaMaxAggregateOutputType = {
    idProvaPratica: number | null
    provaId: number | null
  }

  export type ProvaPraticaCountAggregateOutputType = {
    idProvaPratica: number
    provaId: number
    _all: number
  }


  export type ProvaPraticaAvgAggregateInputType = {
    idProvaPratica?: true
    provaId?: true
  }

  export type ProvaPraticaSumAggregateInputType = {
    idProvaPratica?: true
    provaId?: true
  }

  export type ProvaPraticaMinAggregateInputType = {
    idProvaPratica?: true
    provaId?: true
  }

  export type ProvaPraticaMaxAggregateInputType = {
    idProvaPratica?: true
    provaId?: true
  }

  export type ProvaPraticaCountAggregateInputType = {
    idProvaPratica?: true
    provaId?: true
    _all?: true
  }

  export type ProvaPraticaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProvaPratica to aggregate.
     */
    where?: ProvaPraticaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProvaPraticas to fetch.
     */
    orderBy?: ProvaPraticaOrderByWithRelationInput | ProvaPraticaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProvaPraticaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProvaPraticas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProvaPraticas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProvaPraticas
    **/
    _count?: true | ProvaPraticaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProvaPraticaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProvaPraticaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProvaPraticaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProvaPraticaMaxAggregateInputType
  }

  export type GetProvaPraticaAggregateType<T extends ProvaPraticaAggregateArgs> = {
        [P in keyof T & keyof AggregateProvaPratica]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProvaPratica[P]>
      : GetScalarType<T[P], AggregateProvaPratica[P]>
  }




  export type ProvaPraticaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProvaPraticaWhereInput
    orderBy?: ProvaPraticaOrderByWithAggregationInput | ProvaPraticaOrderByWithAggregationInput[]
    by: ProvaPraticaScalarFieldEnum[] | ProvaPraticaScalarFieldEnum
    having?: ProvaPraticaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProvaPraticaCountAggregateInputType | true
    _avg?: ProvaPraticaAvgAggregateInputType
    _sum?: ProvaPraticaSumAggregateInputType
    _min?: ProvaPraticaMinAggregateInputType
    _max?: ProvaPraticaMaxAggregateInputType
  }

  export type ProvaPraticaGroupByOutputType = {
    idProvaPratica: number
    provaId: number | null
    _count: ProvaPraticaCountAggregateOutputType | null
    _avg: ProvaPraticaAvgAggregateOutputType | null
    _sum: ProvaPraticaSumAggregateOutputType | null
    _min: ProvaPraticaMinAggregateOutputType | null
    _max: ProvaPraticaMaxAggregateOutputType | null
  }

  type GetProvaPraticaGroupByPayload<T extends ProvaPraticaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProvaPraticaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProvaPraticaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProvaPraticaGroupByOutputType[P]>
            : GetScalarType<T[P], ProvaPraticaGroupByOutputType[P]>
        }
      >
    >


  export type ProvaPraticaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idProvaPratica?: boolean
    provaId?: boolean
    prova?: boolean | ProvaPratica$provaArgs<ExtArgs>
    blocosProvas?: boolean | ProvaPratica$blocosProvasArgs<ExtArgs>
    Categoria?: boolean | ProvaPratica$CategoriaArgs<ExtArgs>
    Recurso?: boolean | ProvaPratica$RecursoArgs<ExtArgs>
    _count?: boolean | ProvaPraticaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["provaPratica"]>

  export type ProvaPraticaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idProvaPratica?: boolean
    provaId?: boolean
    prova?: boolean | ProvaPratica$provaArgs<ExtArgs>
  }, ExtArgs["result"]["provaPratica"]>

  export type ProvaPraticaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idProvaPratica?: boolean
    provaId?: boolean
    prova?: boolean | ProvaPratica$provaArgs<ExtArgs>
  }, ExtArgs["result"]["provaPratica"]>

  export type ProvaPraticaSelectScalar = {
    idProvaPratica?: boolean
    provaId?: boolean
  }

  export type ProvaPraticaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idProvaPratica" | "provaId", ExtArgs["result"]["provaPratica"]>
  export type ProvaPraticaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prova?: boolean | ProvaPratica$provaArgs<ExtArgs>
    blocosProvas?: boolean | ProvaPratica$blocosProvasArgs<ExtArgs>
    Categoria?: boolean | ProvaPratica$CategoriaArgs<ExtArgs>
    Recurso?: boolean | ProvaPratica$RecursoArgs<ExtArgs>
    _count?: boolean | ProvaPraticaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProvaPraticaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prova?: boolean | ProvaPratica$provaArgs<ExtArgs>
  }
  export type ProvaPraticaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prova?: boolean | ProvaPratica$provaArgs<ExtArgs>
  }

  export type $ProvaPraticaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProvaPratica"
    objects: {
      prova: Prisma.$ProvaPayload<ExtArgs> | null
      blocosProvas: Prisma.$BlocoProvaPayload<ExtArgs>[]
      Categoria: Prisma.$CategoriaPayload<ExtArgs>[]
      Recurso: Prisma.$RecursoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idProvaPratica: number
      provaId: number | null
    }, ExtArgs["result"]["provaPratica"]>
    composites: {}
  }

  type ProvaPraticaGetPayload<S extends boolean | null | undefined | ProvaPraticaDefaultArgs> = $Result.GetResult<Prisma.$ProvaPraticaPayload, S>

  type ProvaPraticaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProvaPraticaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProvaPraticaCountAggregateInputType | true
    }

  export interface ProvaPraticaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProvaPratica'], meta: { name: 'ProvaPratica' } }
    /**
     * Find zero or one ProvaPratica that matches the filter.
     * @param {ProvaPraticaFindUniqueArgs} args - Arguments to find a ProvaPratica
     * @example
     * // Get one ProvaPratica
     * const provaPratica = await prisma.provaPratica.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProvaPraticaFindUniqueArgs>(args: SelectSubset<T, ProvaPraticaFindUniqueArgs<ExtArgs>>): Prisma__ProvaPraticaClient<$Result.GetResult<Prisma.$ProvaPraticaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProvaPratica that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProvaPraticaFindUniqueOrThrowArgs} args - Arguments to find a ProvaPratica
     * @example
     * // Get one ProvaPratica
     * const provaPratica = await prisma.provaPratica.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProvaPraticaFindUniqueOrThrowArgs>(args: SelectSubset<T, ProvaPraticaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProvaPraticaClient<$Result.GetResult<Prisma.$ProvaPraticaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProvaPratica that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvaPraticaFindFirstArgs} args - Arguments to find a ProvaPratica
     * @example
     * // Get one ProvaPratica
     * const provaPratica = await prisma.provaPratica.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProvaPraticaFindFirstArgs>(args?: SelectSubset<T, ProvaPraticaFindFirstArgs<ExtArgs>>): Prisma__ProvaPraticaClient<$Result.GetResult<Prisma.$ProvaPraticaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProvaPratica that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvaPraticaFindFirstOrThrowArgs} args - Arguments to find a ProvaPratica
     * @example
     * // Get one ProvaPratica
     * const provaPratica = await prisma.provaPratica.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProvaPraticaFindFirstOrThrowArgs>(args?: SelectSubset<T, ProvaPraticaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProvaPraticaClient<$Result.GetResult<Prisma.$ProvaPraticaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProvaPraticas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvaPraticaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProvaPraticas
     * const provaPraticas = await prisma.provaPratica.findMany()
     * 
     * // Get first 10 ProvaPraticas
     * const provaPraticas = await prisma.provaPratica.findMany({ take: 10 })
     * 
     * // Only select the `idProvaPratica`
     * const provaPraticaWithIdProvaPraticaOnly = await prisma.provaPratica.findMany({ select: { idProvaPratica: true } })
     * 
     */
    findMany<T extends ProvaPraticaFindManyArgs>(args?: SelectSubset<T, ProvaPraticaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProvaPraticaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProvaPratica.
     * @param {ProvaPraticaCreateArgs} args - Arguments to create a ProvaPratica.
     * @example
     * // Create one ProvaPratica
     * const ProvaPratica = await prisma.provaPratica.create({
     *   data: {
     *     // ... data to create a ProvaPratica
     *   }
     * })
     * 
     */
    create<T extends ProvaPraticaCreateArgs>(args: SelectSubset<T, ProvaPraticaCreateArgs<ExtArgs>>): Prisma__ProvaPraticaClient<$Result.GetResult<Prisma.$ProvaPraticaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProvaPraticas.
     * @param {ProvaPraticaCreateManyArgs} args - Arguments to create many ProvaPraticas.
     * @example
     * // Create many ProvaPraticas
     * const provaPratica = await prisma.provaPratica.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProvaPraticaCreateManyArgs>(args?: SelectSubset<T, ProvaPraticaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProvaPraticas and returns the data saved in the database.
     * @param {ProvaPraticaCreateManyAndReturnArgs} args - Arguments to create many ProvaPraticas.
     * @example
     * // Create many ProvaPraticas
     * const provaPratica = await prisma.provaPratica.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProvaPraticas and only return the `idProvaPratica`
     * const provaPraticaWithIdProvaPraticaOnly = await prisma.provaPratica.createManyAndReturn({
     *   select: { idProvaPratica: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProvaPraticaCreateManyAndReturnArgs>(args?: SelectSubset<T, ProvaPraticaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProvaPraticaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProvaPratica.
     * @param {ProvaPraticaDeleteArgs} args - Arguments to delete one ProvaPratica.
     * @example
     * // Delete one ProvaPratica
     * const ProvaPratica = await prisma.provaPratica.delete({
     *   where: {
     *     // ... filter to delete one ProvaPratica
     *   }
     * })
     * 
     */
    delete<T extends ProvaPraticaDeleteArgs>(args: SelectSubset<T, ProvaPraticaDeleteArgs<ExtArgs>>): Prisma__ProvaPraticaClient<$Result.GetResult<Prisma.$ProvaPraticaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProvaPratica.
     * @param {ProvaPraticaUpdateArgs} args - Arguments to update one ProvaPratica.
     * @example
     * // Update one ProvaPratica
     * const provaPratica = await prisma.provaPratica.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProvaPraticaUpdateArgs>(args: SelectSubset<T, ProvaPraticaUpdateArgs<ExtArgs>>): Prisma__ProvaPraticaClient<$Result.GetResult<Prisma.$ProvaPraticaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProvaPraticas.
     * @param {ProvaPraticaDeleteManyArgs} args - Arguments to filter ProvaPraticas to delete.
     * @example
     * // Delete a few ProvaPraticas
     * const { count } = await prisma.provaPratica.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProvaPraticaDeleteManyArgs>(args?: SelectSubset<T, ProvaPraticaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProvaPraticas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvaPraticaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProvaPraticas
     * const provaPratica = await prisma.provaPratica.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProvaPraticaUpdateManyArgs>(args: SelectSubset<T, ProvaPraticaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProvaPraticas and returns the data updated in the database.
     * @param {ProvaPraticaUpdateManyAndReturnArgs} args - Arguments to update many ProvaPraticas.
     * @example
     * // Update many ProvaPraticas
     * const provaPratica = await prisma.provaPratica.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProvaPraticas and only return the `idProvaPratica`
     * const provaPraticaWithIdProvaPraticaOnly = await prisma.provaPratica.updateManyAndReturn({
     *   select: { idProvaPratica: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProvaPraticaUpdateManyAndReturnArgs>(args: SelectSubset<T, ProvaPraticaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProvaPraticaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProvaPratica.
     * @param {ProvaPraticaUpsertArgs} args - Arguments to update or create a ProvaPratica.
     * @example
     * // Update or create a ProvaPratica
     * const provaPratica = await prisma.provaPratica.upsert({
     *   create: {
     *     // ... data to create a ProvaPratica
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProvaPratica we want to update
     *   }
     * })
     */
    upsert<T extends ProvaPraticaUpsertArgs>(args: SelectSubset<T, ProvaPraticaUpsertArgs<ExtArgs>>): Prisma__ProvaPraticaClient<$Result.GetResult<Prisma.$ProvaPraticaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProvaPraticas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvaPraticaCountArgs} args - Arguments to filter ProvaPraticas to count.
     * @example
     * // Count the number of ProvaPraticas
     * const count = await prisma.provaPratica.count({
     *   where: {
     *     // ... the filter for the ProvaPraticas we want to count
     *   }
     * })
    **/
    count<T extends ProvaPraticaCountArgs>(
      args?: Subset<T, ProvaPraticaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProvaPraticaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProvaPratica.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvaPraticaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProvaPraticaAggregateArgs>(args: Subset<T, ProvaPraticaAggregateArgs>): Prisma.PrismaPromise<GetProvaPraticaAggregateType<T>>

    /**
     * Group by ProvaPratica.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvaPraticaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProvaPraticaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProvaPraticaGroupByArgs['orderBy'] }
        : { orderBy?: ProvaPraticaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProvaPraticaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProvaPraticaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProvaPratica model
   */
  readonly fields: ProvaPraticaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProvaPratica.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProvaPraticaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prova<T extends ProvaPratica$provaArgs<ExtArgs> = {}>(args?: Subset<T, ProvaPratica$provaArgs<ExtArgs>>): Prisma__ProvaClient<$Result.GetResult<Prisma.$ProvaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    blocosProvas<T extends ProvaPratica$blocosProvasArgs<ExtArgs> = {}>(args?: Subset<T, ProvaPratica$blocosProvasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlocoProvaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Categoria<T extends ProvaPratica$CategoriaArgs<ExtArgs> = {}>(args?: Subset<T, ProvaPratica$CategoriaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Recurso<T extends ProvaPratica$RecursoArgs<ExtArgs> = {}>(args?: Subset<T, ProvaPratica$RecursoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecursoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProvaPratica model
   */
  interface ProvaPraticaFieldRefs {
    readonly idProvaPratica: FieldRef<"ProvaPratica", 'Int'>
    readonly provaId: FieldRef<"ProvaPratica", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProvaPratica findUnique
   */
  export type ProvaPraticaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvaPratica
     */
    select?: ProvaPraticaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProvaPratica
     */
    omit?: ProvaPraticaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaPraticaInclude<ExtArgs> | null
    /**
     * Filter, which ProvaPratica to fetch.
     */
    where: ProvaPraticaWhereUniqueInput
  }

  /**
   * ProvaPratica findUniqueOrThrow
   */
  export type ProvaPraticaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvaPratica
     */
    select?: ProvaPraticaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProvaPratica
     */
    omit?: ProvaPraticaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaPraticaInclude<ExtArgs> | null
    /**
     * Filter, which ProvaPratica to fetch.
     */
    where: ProvaPraticaWhereUniqueInput
  }

  /**
   * ProvaPratica findFirst
   */
  export type ProvaPraticaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvaPratica
     */
    select?: ProvaPraticaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProvaPratica
     */
    omit?: ProvaPraticaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaPraticaInclude<ExtArgs> | null
    /**
     * Filter, which ProvaPratica to fetch.
     */
    where?: ProvaPraticaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProvaPraticas to fetch.
     */
    orderBy?: ProvaPraticaOrderByWithRelationInput | ProvaPraticaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProvaPraticas.
     */
    cursor?: ProvaPraticaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProvaPraticas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProvaPraticas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProvaPraticas.
     */
    distinct?: ProvaPraticaScalarFieldEnum | ProvaPraticaScalarFieldEnum[]
  }

  /**
   * ProvaPratica findFirstOrThrow
   */
  export type ProvaPraticaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvaPratica
     */
    select?: ProvaPraticaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProvaPratica
     */
    omit?: ProvaPraticaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaPraticaInclude<ExtArgs> | null
    /**
     * Filter, which ProvaPratica to fetch.
     */
    where?: ProvaPraticaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProvaPraticas to fetch.
     */
    orderBy?: ProvaPraticaOrderByWithRelationInput | ProvaPraticaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProvaPraticas.
     */
    cursor?: ProvaPraticaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProvaPraticas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProvaPraticas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProvaPraticas.
     */
    distinct?: ProvaPraticaScalarFieldEnum | ProvaPraticaScalarFieldEnum[]
  }

  /**
   * ProvaPratica findMany
   */
  export type ProvaPraticaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvaPratica
     */
    select?: ProvaPraticaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProvaPratica
     */
    omit?: ProvaPraticaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaPraticaInclude<ExtArgs> | null
    /**
     * Filter, which ProvaPraticas to fetch.
     */
    where?: ProvaPraticaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProvaPraticas to fetch.
     */
    orderBy?: ProvaPraticaOrderByWithRelationInput | ProvaPraticaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProvaPraticas.
     */
    cursor?: ProvaPraticaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProvaPraticas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProvaPraticas.
     */
    skip?: number
    distinct?: ProvaPraticaScalarFieldEnum | ProvaPraticaScalarFieldEnum[]
  }

  /**
   * ProvaPratica create
   */
  export type ProvaPraticaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvaPratica
     */
    select?: ProvaPraticaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProvaPratica
     */
    omit?: ProvaPraticaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaPraticaInclude<ExtArgs> | null
    /**
     * The data needed to create a ProvaPratica.
     */
    data?: XOR<ProvaPraticaCreateInput, ProvaPraticaUncheckedCreateInput>
  }

  /**
   * ProvaPratica createMany
   */
  export type ProvaPraticaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProvaPraticas.
     */
    data: ProvaPraticaCreateManyInput | ProvaPraticaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProvaPratica createManyAndReturn
   */
  export type ProvaPraticaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvaPratica
     */
    select?: ProvaPraticaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProvaPratica
     */
    omit?: ProvaPraticaOmit<ExtArgs> | null
    /**
     * The data used to create many ProvaPraticas.
     */
    data: ProvaPraticaCreateManyInput | ProvaPraticaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaPraticaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProvaPratica update
   */
  export type ProvaPraticaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvaPratica
     */
    select?: ProvaPraticaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProvaPratica
     */
    omit?: ProvaPraticaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaPraticaInclude<ExtArgs> | null
    /**
     * The data needed to update a ProvaPratica.
     */
    data: XOR<ProvaPraticaUpdateInput, ProvaPraticaUncheckedUpdateInput>
    /**
     * Choose, which ProvaPratica to update.
     */
    where: ProvaPraticaWhereUniqueInput
  }

  /**
   * ProvaPratica updateMany
   */
  export type ProvaPraticaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProvaPraticas.
     */
    data: XOR<ProvaPraticaUpdateManyMutationInput, ProvaPraticaUncheckedUpdateManyInput>
    /**
     * Filter which ProvaPraticas to update
     */
    where?: ProvaPraticaWhereInput
    /**
     * Limit how many ProvaPraticas to update.
     */
    limit?: number
  }

  /**
   * ProvaPratica updateManyAndReturn
   */
  export type ProvaPraticaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvaPratica
     */
    select?: ProvaPraticaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProvaPratica
     */
    omit?: ProvaPraticaOmit<ExtArgs> | null
    /**
     * The data used to update ProvaPraticas.
     */
    data: XOR<ProvaPraticaUpdateManyMutationInput, ProvaPraticaUncheckedUpdateManyInput>
    /**
     * Filter which ProvaPraticas to update
     */
    where?: ProvaPraticaWhereInput
    /**
     * Limit how many ProvaPraticas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaPraticaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProvaPratica upsert
   */
  export type ProvaPraticaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvaPratica
     */
    select?: ProvaPraticaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProvaPratica
     */
    omit?: ProvaPraticaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaPraticaInclude<ExtArgs> | null
    /**
     * The filter to search for the ProvaPratica to update in case it exists.
     */
    where: ProvaPraticaWhereUniqueInput
    /**
     * In case the ProvaPratica found by the `where` argument doesn't exist, create a new ProvaPratica with this data.
     */
    create: XOR<ProvaPraticaCreateInput, ProvaPraticaUncheckedCreateInput>
    /**
     * In case the ProvaPratica was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProvaPraticaUpdateInput, ProvaPraticaUncheckedUpdateInput>
  }

  /**
   * ProvaPratica delete
   */
  export type ProvaPraticaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvaPratica
     */
    select?: ProvaPraticaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProvaPratica
     */
    omit?: ProvaPraticaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaPraticaInclude<ExtArgs> | null
    /**
     * Filter which ProvaPratica to delete.
     */
    where: ProvaPraticaWhereUniqueInput
  }

  /**
   * ProvaPratica deleteMany
   */
  export type ProvaPraticaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProvaPraticas to delete
     */
    where?: ProvaPraticaWhereInput
    /**
     * Limit how many ProvaPraticas to delete.
     */
    limit?: number
  }

  /**
   * ProvaPratica.prova
   */
  export type ProvaPratica$provaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prova
     */
    select?: ProvaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prova
     */
    omit?: ProvaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaInclude<ExtArgs> | null
    where?: ProvaWhereInput
  }

  /**
   * ProvaPratica.blocosProvas
   */
  export type ProvaPratica$blocosProvasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlocoProva
     */
    select?: BlocoProvaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlocoProva
     */
    omit?: BlocoProvaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlocoProvaInclude<ExtArgs> | null
    where?: BlocoProvaWhereInput
    orderBy?: BlocoProvaOrderByWithRelationInput | BlocoProvaOrderByWithRelationInput[]
    cursor?: BlocoProvaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlocoProvaScalarFieldEnum | BlocoProvaScalarFieldEnum[]
  }

  /**
   * ProvaPratica.Categoria
   */
  export type ProvaPratica$CategoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Categoria
     */
    omit?: CategoriaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    where?: CategoriaWhereInput
    orderBy?: CategoriaOrderByWithRelationInput | CategoriaOrderByWithRelationInput[]
    cursor?: CategoriaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoriaScalarFieldEnum | CategoriaScalarFieldEnum[]
  }

  /**
   * ProvaPratica.Recurso
   */
  export type ProvaPratica$RecursoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recurso
     */
    select?: RecursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recurso
     */
    omit?: RecursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecursoInclude<ExtArgs> | null
    where?: RecursoWhereInput
    orderBy?: RecursoOrderByWithRelationInput | RecursoOrderByWithRelationInput[]
    cursor?: RecursoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecursoScalarFieldEnum | RecursoScalarFieldEnum[]
  }

  /**
   * ProvaPratica without action
   */
  export type ProvaPraticaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvaPratica
     */
    select?: ProvaPraticaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProvaPratica
     */
    omit?: ProvaPraticaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaPraticaInclude<ExtArgs> | null
  }


  /**
   * Model BlocoProva
   */

  export type AggregateBlocoProva = {
    _count: BlocoProvaCountAggregateOutputType | null
    _avg: BlocoProvaAvgAggregateOutputType | null
    _sum: BlocoProvaSumAggregateOutputType | null
    _min: BlocoProvaMinAggregateOutputType | null
    _max: BlocoProvaMaxAggregateOutputType | null
  }

  export type BlocoProvaAvgAggregateOutputType = {
    idBloco: number | null
    notaMaximaBloco: number | null
    provaPraticaId: number | null
  }

  export type BlocoProvaSumAggregateOutputType = {
    idBloco: number | null
    notaMaximaBloco: number | null
    provaPraticaId: number | null
  }

  export type BlocoProvaMinAggregateOutputType = {
    idBloco: number | null
    nomeBloco: string | null
    notaMaximaBloco: number | null
    provaPraticaId: number | null
  }

  export type BlocoProvaMaxAggregateOutputType = {
    idBloco: number | null
    nomeBloco: string | null
    notaMaximaBloco: number | null
    provaPraticaId: number | null
  }

  export type BlocoProvaCountAggregateOutputType = {
    idBloco: number
    nomeBloco: number
    notaMaximaBloco: number
    provaPraticaId: number
    _all: number
  }


  export type BlocoProvaAvgAggregateInputType = {
    idBloco?: true
    notaMaximaBloco?: true
    provaPraticaId?: true
  }

  export type BlocoProvaSumAggregateInputType = {
    idBloco?: true
    notaMaximaBloco?: true
    provaPraticaId?: true
  }

  export type BlocoProvaMinAggregateInputType = {
    idBloco?: true
    nomeBloco?: true
    notaMaximaBloco?: true
    provaPraticaId?: true
  }

  export type BlocoProvaMaxAggregateInputType = {
    idBloco?: true
    nomeBloco?: true
    notaMaximaBloco?: true
    provaPraticaId?: true
  }

  export type BlocoProvaCountAggregateInputType = {
    idBloco?: true
    nomeBloco?: true
    notaMaximaBloco?: true
    provaPraticaId?: true
    _all?: true
  }

  export type BlocoProvaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlocoProva to aggregate.
     */
    where?: BlocoProvaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlocoProva to fetch.
     */
    orderBy?: BlocoProvaOrderByWithRelationInput | BlocoProvaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlocoProvaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlocoProva from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlocoProva.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlocoProva
    **/
    _count?: true | BlocoProvaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlocoProvaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlocoProvaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlocoProvaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlocoProvaMaxAggregateInputType
  }

  export type GetBlocoProvaAggregateType<T extends BlocoProvaAggregateArgs> = {
        [P in keyof T & keyof AggregateBlocoProva]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlocoProva[P]>
      : GetScalarType<T[P], AggregateBlocoProva[P]>
  }




  export type BlocoProvaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlocoProvaWhereInput
    orderBy?: BlocoProvaOrderByWithAggregationInput | BlocoProvaOrderByWithAggregationInput[]
    by: BlocoProvaScalarFieldEnum[] | BlocoProvaScalarFieldEnum
    having?: BlocoProvaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlocoProvaCountAggregateInputType | true
    _avg?: BlocoProvaAvgAggregateInputType
    _sum?: BlocoProvaSumAggregateInputType
    _min?: BlocoProvaMinAggregateInputType
    _max?: BlocoProvaMaxAggregateInputType
  }

  export type BlocoProvaGroupByOutputType = {
    idBloco: number
    nomeBloco: string
    notaMaximaBloco: number
    provaPraticaId: number | null
    _count: BlocoProvaCountAggregateOutputType | null
    _avg: BlocoProvaAvgAggregateOutputType | null
    _sum: BlocoProvaSumAggregateOutputType | null
    _min: BlocoProvaMinAggregateOutputType | null
    _max: BlocoProvaMaxAggregateOutputType | null
  }

  type GetBlocoProvaGroupByPayload<T extends BlocoProvaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlocoProvaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlocoProvaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlocoProvaGroupByOutputType[P]>
            : GetScalarType<T[P], BlocoProvaGroupByOutputType[P]>
        }
      >
    >


  export type BlocoProvaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idBloco?: boolean
    nomeBloco?: boolean
    notaMaximaBloco?: boolean
    provaPraticaId?: boolean
    ProvaPratica?: boolean | BlocoProva$ProvaPraticaArgs<ExtArgs>
    quesitos?: boolean | BlocoProva$quesitosArgs<ExtArgs>
    Avaliacao?: boolean | BlocoProva$AvaliacaoArgs<ExtArgs>
    _count?: boolean | BlocoProvaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blocoProva"]>

  export type BlocoProvaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idBloco?: boolean
    nomeBloco?: boolean
    notaMaximaBloco?: boolean
    provaPraticaId?: boolean
    ProvaPratica?: boolean | BlocoProva$ProvaPraticaArgs<ExtArgs>
  }, ExtArgs["result"]["blocoProva"]>

  export type BlocoProvaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idBloco?: boolean
    nomeBloco?: boolean
    notaMaximaBloco?: boolean
    provaPraticaId?: boolean
    ProvaPratica?: boolean | BlocoProva$ProvaPraticaArgs<ExtArgs>
  }, ExtArgs["result"]["blocoProva"]>

  export type BlocoProvaSelectScalar = {
    idBloco?: boolean
    nomeBloco?: boolean
    notaMaximaBloco?: boolean
    provaPraticaId?: boolean
  }

  export type BlocoProvaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idBloco" | "nomeBloco" | "notaMaximaBloco" | "provaPraticaId", ExtArgs["result"]["blocoProva"]>
  export type BlocoProvaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ProvaPratica?: boolean | BlocoProva$ProvaPraticaArgs<ExtArgs>
    quesitos?: boolean | BlocoProva$quesitosArgs<ExtArgs>
    Avaliacao?: boolean | BlocoProva$AvaliacaoArgs<ExtArgs>
    _count?: boolean | BlocoProvaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BlocoProvaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ProvaPratica?: boolean | BlocoProva$ProvaPraticaArgs<ExtArgs>
  }
  export type BlocoProvaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ProvaPratica?: boolean | BlocoProva$ProvaPraticaArgs<ExtArgs>
  }

  export type $BlocoProvaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlocoProva"
    objects: {
      ProvaPratica: Prisma.$ProvaPraticaPayload<ExtArgs> | null
      quesitos: Prisma.$QuesitosPayload<ExtArgs>[]
      Avaliacao: Prisma.$AvaliacaoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idBloco: number
      nomeBloco: string
      notaMaximaBloco: number
      provaPraticaId: number | null
    }, ExtArgs["result"]["blocoProva"]>
    composites: {}
  }

  type BlocoProvaGetPayload<S extends boolean | null | undefined | BlocoProvaDefaultArgs> = $Result.GetResult<Prisma.$BlocoProvaPayload, S>

  type BlocoProvaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlocoProvaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlocoProvaCountAggregateInputType | true
    }

  export interface BlocoProvaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlocoProva'], meta: { name: 'BlocoProva' } }
    /**
     * Find zero or one BlocoProva that matches the filter.
     * @param {BlocoProvaFindUniqueArgs} args - Arguments to find a BlocoProva
     * @example
     * // Get one BlocoProva
     * const blocoProva = await prisma.blocoProva.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlocoProvaFindUniqueArgs>(args: SelectSubset<T, BlocoProvaFindUniqueArgs<ExtArgs>>): Prisma__BlocoProvaClient<$Result.GetResult<Prisma.$BlocoProvaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BlocoProva that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlocoProvaFindUniqueOrThrowArgs} args - Arguments to find a BlocoProva
     * @example
     * // Get one BlocoProva
     * const blocoProva = await prisma.blocoProva.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlocoProvaFindUniqueOrThrowArgs>(args: SelectSubset<T, BlocoProvaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlocoProvaClient<$Result.GetResult<Prisma.$BlocoProvaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlocoProva that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlocoProvaFindFirstArgs} args - Arguments to find a BlocoProva
     * @example
     * // Get one BlocoProva
     * const blocoProva = await prisma.blocoProva.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlocoProvaFindFirstArgs>(args?: SelectSubset<T, BlocoProvaFindFirstArgs<ExtArgs>>): Prisma__BlocoProvaClient<$Result.GetResult<Prisma.$BlocoProvaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlocoProva that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlocoProvaFindFirstOrThrowArgs} args - Arguments to find a BlocoProva
     * @example
     * // Get one BlocoProva
     * const blocoProva = await prisma.blocoProva.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlocoProvaFindFirstOrThrowArgs>(args?: SelectSubset<T, BlocoProvaFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlocoProvaClient<$Result.GetResult<Prisma.$BlocoProvaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BlocoProva that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlocoProvaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlocoProva
     * const blocoProva = await prisma.blocoProva.findMany()
     * 
     * // Get first 10 BlocoProva
     * const blocoProva = await prisma.blocoProva.findMany({ take: 10 })
     * 
     * // Only select the `idBloco`
     * const blocoProvaWithIdBlocoOnly = await prisma.blocoProva.findMany({ select: { idBloco: true } })
     * 
     */
    findMany<T extends BlocoProvaFindManyArgs>(args?: SelectSubset<T, BlocoProvaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlocoProvaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BlocoProva.
     * @param {BlocoProvaCreateArgs} args - Arguments to create a BlocoProva.
     * @example
     * // Create one BlocoProva
     * const BlocoProva = await prisma.blocoProva.create({
     *   data: {
     *     // ... data to create a BlocoProva
     *   }
     * })
     * 
     */
    create<T extends BlocoProvaCreateArgs>(args: SelectSubset<T, BlocoProvaCreateArgs<ExtArgs>>): Prisma__BlocoProvaClient<$Result.GetResult<Prisma.$BlocoProvaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BlocoProva.
     * @param {BlocoProvaCreateManyArgs} args - Arguments to create many BlocoProva.
     * @example
     * // Create many BlocoProva
     * const blocoProva = await prisma.blocoProva.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlocoProvaCreateManyArgs>(args?: SelectSubset<T, BlocoProvaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlocoProva and returns the data saved in the database.
     * @param {BlocoProvaCreateManyAndReturnArgs} args - Arguments to create many BlocoProva.
     * @example
     * // Create many BlocoProva
     * const blocoProva = await prisma.blocoProva.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlocoProva and only return the `idBloco`
     * const blocoProvaWithIdBlocoOnly = await prisma.blocoProva.createManyAndReturn({
     *   select: { idBloco: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlocoProvaCreateManyAndReturnArgs>(args?: SelectSubset<T, BlocoProvaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlocoProvaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BlocoProva.
     * @param {BlocoProvaDeleteArgs} args - Arguments to delete one BlocoProva.
     * @example
     * // Delete one BlocoProva
     * const BlocoProva = await prisma.blocoProva.delete({
     *   where: {
     *     // ... filter to delete one BlocoProva
     *   }
     * })
     * 
     */
    delete<T extends BlocoProvaDeleteArgs>(args: SelectSubset<T, BlocoProvaDeleteArgs<ExtArgs>>): Prisma__BlocoProvaClient<$Result.GetResult<Prisma.$BlocoProvaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BlocoProva.
     * @param {BlocoProvaUpdateArgs} args - Arguments to update one BlocoProva.
     * @example
     * // Update one BlocoProva
     * const blocoProva = await prisma.blocoProva.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlocoProvaUpdateArgs>(args: SelectSubset<T, BlocoProvaUpdateArgs<ExtArgs>>): Prisma__BlocoProvaClient<$Result.GetResult<Prisma.$BlocoProvaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BlocoProva.
     * @param {BlocoProvaDeleteManyArgs} args - Arguments to filter BlocoProva to delete.
     * @example
     * // Delete a few BlocoProva
     * const { count } = await prisma.blocoProva.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlocoProvaDeleteManyArgs>(args?: SelectSubset<T, BlocoProvaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlocoProva.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlocoProvaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlocoProva
     * const blocoProva = await prisma.blocoProva.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlocoProvaUpdateManyArgs>(args: SelectSubset<T, BlocoProvaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlocoProva and returns the data updated in the database.
     * @param {BlocoProvaUpdateManyAndReturnArgs} args - Arguments to update many BlocoProva.
     * @example
     * // Update many BlocoProva
     * const blocoProva = await prisma.blocoProva.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BlocoProva and only return the `idBloco`
     * const blocoProvaWithIdBlocoOnly = await prisma.blocoProva.updateManyAndReturn({
     *   select: { idBloco: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlocoProvaUpdateManyAndReturnArgs>(args: SelectSubset<T, BlocoProvaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlocoProvaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BlocoProva.
     * @param {BlocoProvaUpsertArgs} args - Arguments to update or create a BlocoProva.
     * @example
     * // Update or create a BlocoProva
     * const blocoProva = await prisma.blocoProva.upsert({
     *   create: {
     *     // ... data to create a BlocoProva
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlocoProva we want to update
     *   }
     * })
     */
    upsert<T extends BlocoProvaUpsertArgs>(args: SelectSubset<T, BlocoProvaUpsertArgs<ExtArgs>>): Prisma__BlocoProvaClient<$Result.GetResult<Prisma.$BlocoProvaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BlocoProva.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlocoProvaCountArgs} args - Arguments to filter BlocoProva to count.
     * @example
     * // Count the number of BlocoProva
     * const count = await prisma.blocoProva.count({
     *   where: {
     *     // ... the filter for the BlocoProva we want to count
     *   }
     * })
    **/
    count<T extends BlocoProvaCountArgs>(
      args?: Subset<T, BlocoProvaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlocoProvaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlocoProva.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlocoProvaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlocoProvaAggregateArgs>(args: Subset<T, BlocoProvaAggregateArgs>): Prisma.PrismaPromise<GetBlocoProvaAggregateType<T>>

    /**
     * Group by BlocoProva.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlocoProvaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlocoProvaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlocoProvaGroupByArgs['orderBy'] }
        : { orderBy?: BlocoProvaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlocoProvaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlocoProvaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlocoProva model
   */
  readonly fields: BlocoProvaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlocoProva.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlocoProvaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ProvaPratica<T extends BlocoProva$ProvaPraticaArgs<ExtArgs> = {}>(args?: Subset<T, BlocoProva$ProvaPraticaArgs<ExtArgs>>): Prisma__ProvaPraticaClient<$Result.GetResult<Prisma.$ProvaPraticaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    quesitos<T extends BlocoProva$quesitosArgs<ExtArgs> = {}>(args?: Subset<T, BlocoProva$quesitosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuesitosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Avaliacao<T extends BlocoProva$AvaliacaoArgs<ExtArgs> = {}>(args?: Subset<T, BlocoProva$AvaliacaoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlocoProva model
   */
  interface BlocoProvaFieldRefs {
    readonly idBloco: FieldRef<"BlocoProva", 'Int'>
    readonly nomeBloco: FieldRef<"BlocoProva", 'String'>
    readonly notaMaximaBloco: FieldRef<"BlocoProva", 'Float'>
    readonly provaPraticaId: FieldRef<"BlocoProva", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * BlocoProva findUnique
   */
  export type BlocoProvaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlocoProva
     */
    select?: BlocoProvaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlocoProva
     */
    omit?: BlocoProvaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlocoProvaInclude<ExtArgs> | null
    /**
     * Filter, which BlocoProva to fetch.
     */
    where: BlocoProvaWhereUniqueInput
  }

  /**
   * BlocoProva findUniqueOrThrow
   */
  export type BlocoProvaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlocoProva
     */
    select?: BlocoProvaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlocoProva
     */
    omit?: BlocoProvaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlocoProvaInclude<ExtArgs> | null
    /**
     * Filter, which BlocoProva to fetch.
     */
    where: BlocoProvaWhereUniqueInput
  }

  /**
   * BlocoProva findFirst
   */
  export type BlocoProvaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlocoProva
     */
    select?: BlocoProvaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlocoProva
     */
    omit?: BlocoProvaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlocoProvaInclude<ExtArgs> | null
    /**
     * Filter, which BlocoProva to fetch.
     */
    where?: BlocoProvaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlocoProva to fetch.
     */
    orderBy?: BlocoProvaOrderByWithRelationInput | BlocoProvaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlocoProva.
     */
    cursor?: BlocoProvaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlocoProva from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlocoProva.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlocoProva.
     */
    distinct?: BlocoProvaScalarFieldEnum | BlocoProvaScalarFieldEnum[]
  }

  /**
   * BlocoProva findFirstOrThrow
   */
  export type BlocoProvaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlocoProva
     */
    select?: BlocoProvaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlocoProva
     */
    omit?: BlocoProvaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlocoProvaInclude<ExtArgs> | null
    /**
     * Filter, which BlocoProva to fetch.
     */
    where?: BlocoProvaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlocoProva to fetch.
     */
    orderBy?: BlocoProvaOrderByWithRelationInput | BlocoProvaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlocoProva.
     */
    cursor?: BlocoProvaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlocoProva from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlocoProva.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlocoProva.
     */
    distinct?: BlocoProvaScalarFieldEnum | BlocoProvaScalarFieldEnum[]
  }

  /**
   * BlocoProva findMany
   */
  export type BlocoProvaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlocoProva
     */
    select?: BlocoProvaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlocoProva
     */
    omit?: BlocoProvaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlocoProvaInclude<ExtArgs> | null
    /**
     * Filter, which BlocoProva to fetch.
     */
    where?: BlocoProvaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlocoProva to fetch.
     */
    orderBy?: BlocoProvaOrderByWithRelationInput | BlocoProvaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlocoProva.
     */
    cursor?: BlocoProvaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlocoProva from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlocoProva.
     */
    skip?: number
    distinct?: BlocoProvaScalarFieldEnum | BlocoProvaScalarFieldEnum[]
  }

  /**
   * BlocoProva create
   */
  export type BlocoProvaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlocoProva
     */
    select?: BlocoProvaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlocoProva
     */
    omit?: BlocoProvaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlocoProvaInclude<ExtArgs> | null
    /**
     * The data needed to create a BlocoProva.
     */
    data: XOR<BlocoProvaCreateInput, BlocoProvaUncheckedCreateInput>
  }

  /**
   * BlocoProva createMany
   */
  export type BlocoProvaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlocoProva.
     */
    data: BlocoProvaCreateManyInput | BlocoProvaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlocoProva createManyAndReturn
   */
  export type BlocoProvaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlocoProva
     */
    select?: BlocoProvaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlocoProva
     */
    omit?: BlocoProvaOmit<ExtArgs> | null
    /**
     * The data used to create many BlocoProva.
     */
    data: BlocoProvaCreateManyInput | BlocoProvaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlocoProvaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlocoProva update
   */
  export type BlocoProvaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlocoProva
     */
    select?: BlocoProvaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlocoProva
     */
    omit?: BlocoProvaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlocoProvaInclude<ExtArgs> | null
    /**
     * The data needed to update a BlocoProva.
     */
    data: XOR<BlocoProvaUpdateInput, BlocoProvaUncheckedUpdateInput>
    /**
     * Choose, which BlocoProva to update.
     */
    where: BlocoProvaWhereUniqueInput
  }

  /**
   * BlocoProva updateMany
   */
  export type BlocoProvaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlocoProva.
     */
    data: XOR<BlocoProvaUpdateManyMutationInput, BlocoProvaUncheckedUpdateManyInput>
    /**
     * Filter which BlocoProva to update
     */
    where?: BlocoProvaWhereInput
    /**
     * Limit how many BlocoProva to update.
     */
    limit?: number
  }

  /**
   * BlocoProva updateManyAndReturn
   */
  export type BlocoProvaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlocoProva
     */
    select?: BlocoProvaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlocoProva
     */
    omit?: BlocoProvaOmit<ExtArgs> | null
    /**
     * The data used to update BlocoProva.
     */
    data: XOR<BlocoProvaUpdateManyMutationInput, BlocoProvaUncheckedUpdateManyInput>
    /**
     * Filter which BlocoProva to update
     */
    where?: BlocoProvaWhereInput
    /**
     * Limit how many BlocoProva to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlocoProvaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlocoProva upsert
   */
  export type BlocoProvaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlocoProva
     */
    select?: BlocoProvaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlocoProva
     */
    omit?: BlocoProvaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlocoProvaInclude<ExtArgs> | null
    /**
     * The filter to search for the BlocoProva to update in case it exists.
     */
    where: BlocoProvaWhereUniqueInput
    /**
     * In case the BlocoProva found by the `where` argument doesn't exist, create a new BlocoProva with this data.
     */
    create: XOR<BlocoProvaCreateInput, BlocoProvaUncheckedCreateInput>
    /**
     * In case the BlocoProva was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlocoProvaUpdateInput, BlocoProvaUncheckedUpdateInput>
  }

  /**
   * BlocoProva delete
   */
  export type BlocoProvaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlocoProva
     */
    select?: BlocoProvaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlocoProva
     */
    omit?: BlocoProvaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlocoProvaInclude<ExtArgs> | null
    /**
     * Filter which BlocoProva to delete.
     */
    where: BlocoProvaWhereUniqueInput
  }

  /**
   * BlocoProva deleteMany
   */
  export type BlocoProvaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlocoProva to delete
     */
    where?: BlocoProvaWhereInput
    /**
     * Limit how many BlocoProva to delete.
     */
    limit?: number
  }

  /**
   * BlocoProva.ProvaPratica
   */
  export type BlocoProva$ProvaPraticaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvaPratica
     */
    select?: ProvaPraticaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProvaPratica
     */
    omit?: ProvaPraticaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaPraticaInclude<ExtArgs> | null
    where?: ProvaPraticaWhereInput
  }

  /**
   * BlocoProva.quesitos
   */
  export type BlocoProva$quesitosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quesitos
     */
    select?: QuesitosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quesitos
     */
    omit?: QuesitosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuesitosInclude<ExtArgs> | null
    where?: QuesitosWhereInput
    orderBy?: QuesitosOrderByWithRelationInput | QuesitosOrderByWithRelationInput[]
    cursor?: QuesitosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuesitosScalarFieldEnum | QuesitosScalarFieldEnum[]
  }

  /**
   * BlocoProva.Avaliacao
   */
  export type BlocoProva$AvaliacaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avaliacao
     */
    omit?: AvaliacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    where?: AvaliacaoWhereInput
    orderBy?: AvaliacaoOrderByWithRelationInput | AvaliacaoOrderByWithRelationInput[]
    cursor?: AvaliacaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AvaliacaoScalarFieldEnum | AvaliacaoScalarFieldEnum[]
  }

  /**
   * BlocoProva without action
   */
  export type BlocoProvaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlocoProva
     */
    select?: BlocoProvaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlocoProva
     */
    omit?: BlocoProvaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlocoProvaInclude<ExtArgs> | null
  }


  /**
   * Model Quesitos
   */

  export type AggregateQuesitos = {
    _count: QuesitosCountAggregateOutputType | null
    _avg: QuesitosAvgAggregateOutputType | null
    _sum: QuesitosSumAggregateOutputType | null
    _min: QuesitosMinAggregateOutputType | null
    _max: QuesitosMaxAggregateOutputType | null
  }

  export type QuesitosAvgAggregateOutputType = {
    idQuesito: number | null
    notaMaximaQuesito: number | null
    blocoProvaIdBloco: number | null
    provaTeoricaIdprovaTeorica: number | null
    preferenciaSorteioDancaId: number | null
    avaliacaoIdAvalicao: number | null
  }

  export type QuesitosSumAggregateOutputType = {
    idQuesito: number | null
    notaMaximaQuesito: number | null
    blocoProvaIdBloco: number | null
    provaTeoricaIdprovaTeorica: number | null
    preferenciaSorteioDancaId: number | null
    avaliacaoIdAvalicao: number | null
  }

  export type QuesitosMinAggregateOutputType = {
    idQuesito: number | null
    nomeQuesito: string | null
    notaMaximaQuesito: number | null
    danca: boolean | null
    dancaSalaoTradicional: $Enums.DancaSalaoTradicional | null
    blocoProvaIdBloco: number | null
    provaTeoricaIdprovaTeorica: number | null
    preferenciaSorteioDancaId: number | null
    avaliacaoIdAvalicao: number | null
  }

  export type QuesitosMaxAggregateOutputType = {
    idQuesito: number | null
    nomeQuesito: string | null
    notaMaximaQuesito: number | null
    danca: boolean | null
    dancaSalaoTradicional: $Enums.DancaSalaoTradicional | null
    blocoProvaIdBloco: number | null
    provaTeoricaIdprovaTeorica: number | null
    preferenciaSorteioDancaId: number | null
    avaliacaoIdAvalicao: number | null
  }

  export type QuesitosCountAggregateOutputType = {
    idQuesito: number
    nomeQuesito: number
    notaMaximaQuesito: number
    danca: number
    dancaSalaoTradicional: number
    blocoProvaIdBloco: number
    provaTeoricaIdprovaTeorica: number
    preferenciaSorteioDancaId: number
    avaliacaoIdAvalicao: number
    _all: number
  }


  export type QuesitosAvgAggregateInputType = {
    idQuesito?: true
    notaMaximaQuesito?: true
    blocoProvaIdBloco?: true
    provaTeoricaIdprovaTeorica?: true
    preferenciaSorteioDancaId?: true
    avaliacaoIdAvalicao?: true
  }

  export type QuesitosSumAggregateInputType = {
    idQuesito?: true
    notaMaximaQuesito?: true
    blocoProvaIdBloco?: true
    provaTeoricaIdprovaTeorica?: true
    preferenciaSorteioDancaId?: true
    avaliacaoIdAvalicao?: true
  }

  export type QuesitosMinAggregateInputType = {
    idQuesito?: true
    nomeQuesito?: true
    notaMaximaQuesito?: true
    danca?: true
    dancaSalaoTradicional?: true
    blocoProvaIdBloco?: true
    provaTeoricaIdprovaTeorica?: true
    preferenciaSorteioDancaId?: true
    avaliacaoIdAvalicao?: true
  }

  export type QuesitosMaxAggregateInputType = {
    idQuesito?: true
    nomeQuesito?: true
    notaMaximaQuesito?: true
    danca?: true
    dancaSalaoTradicional?: true
    blocoProvaIdBloco?: true
    provaTeoricaIdprovaTeorica?: true
    preferenciaSorteioDancaId?: true
    avaliacaoIdAvalicao?: true
  }

  export type QuesitosCountAggregateInputType = {
    idQuesito?: true
    nomeQuesito?: true
    notaMaximaQuesito?: true
    danca?: true
    dancaSalaoTradicional?: true
    blocoProvaIdBloco?: true
    provaTeoricaIdprovaTeorica?: true
    preferenciaSorteioDancaId?: true
    avaliacaoIdAvalicao?: true
    _all?: true
  }

  export type QuesitosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quesitos to aggregate.
     */
    where?: QuesitosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quesitos to fetch.
     */
    orderBy?: QuesitosOrderByWithRelationInput | QuesitosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuesitosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quesitos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quesitos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Quesitos
    **/
    _count?: true | QuesitosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuesitosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuesitosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuesitosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuesitosMaxAggregateInputType
  }

  export type GetQuesitosAggregateType<T extends QuesitosAggregateArgs> = {
        [P in keyof T & keyof AggregateQuesitos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuesitos[P]>
      : GetScalarType<T[P], AggregateQuesitos[P]>
  }




  export type QuesitosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuesitosWhereInput
    orderBy?: QuesitosOrderByWithAggregationInput | QuesitosOrderByWithAggregationInput[]
    by: QuesitosScalarFieldEnum[] | QuesitosScalarFieldEnum
    having?: QuesitosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuesitosCountAggregateInputType | true
    _avg?: QuesitosAvgAggregateInputType
    _sum?: QuesitosSumAggregateInputType
    _min?: QuesitosMinAggregateInputType
    _max?: QuesitosMaxAggregateInputType
  }

  export type QuesitosGroupByOutputType = {
    idQuesito: number
    nomeQuesito: string
    notaMaximaQuesito: number
    danca: boolean
    dancaSalaoTradicional: $Enums.DancaSalaoTradicional
    blocoProvaIdBloco: number | null
    provaTeoricaIdprovaTeorica: number | null
    preferenciaSorteioDancaId: number | null
    avaliacaoIdAvalicao: number | null
    _count: QuesitosCountAggregateOutputType | null
    _avg: QuesitosAvgAggregateOutputType | null
    _sum: QuesitosSumAggregateOutputType | null
    _min: QuesitosMinAggregateOutputType | null
    _max: QuesitosMaxAggregateOutputType | null
  }

  type GetQuesitosGroupByPayload<T extends QuesitosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuesitosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuesitosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuesitosGroupByOutputType[P]>
            : GetScalarType<T[P], QuesitosGroupByOutputType[P]>
        }
      >
    >


  export type QuesitosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idQuesito?: boolean
    nomeQuesito?: boolean
    notaMaximaQuesito?: boolean
    danca?: boolean
    dancaSalaoTradicional?: boolean
    blocoProvaIdBloco?: boolean
    provaTeoricaIdprovaTeorica?: boolean
    preferenciaSorteioDancaId?: boolean
    avaliacaoIdAvalicao?: boolean
    BlocoProva?: boolean | Quesitos$BlocoProvaArgs<ExtArgs>
    ProvaTeorica?: boolean | Quesitos$ProvaTeoricaArgs<ExtArgs>
    subeQuesitos?: boolean | Quesitos$subeQuesitosArgs<ExtArgs>
    recursos?: boolean | Quesitos$recursosArgs<ExtArgs>
    PreferenciaSorteioDanca?: boolean | Quesitos$PreferenciaSorteioDancaArgs<ExtArgs>
    Avaliacao?: boolean | Quesitos$AvaliacaoArgs<ExtArgs>
    _count?: boolean | QuesitosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quesitos"]>

  export type QuesitosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idQuesito?: boolean
    nomeQuesito?: boolean
    notaMaximaQuesito?: boolean
    danca?: boolean
    dancaSalaoTradicional?: boolean
    blocoProvaIdBloco?: boolean
    provaTeoricaIdprovaTeorica?: boolean
    preferenciaSorteioDancaId?: boolean
    avaliacaoIdAvalicao?: boolean
    BlocoProva?: boolean | Quesitos$BlocoProvaArgs<ExtArgs>
    ProvaTeorica?: boolean | Quesitos$ProvaTeoricaArgs<ExtArgs>
    PreferenciaSorteioDanca?: boolean | Quesitos$PreferenciaSorteioDancaArgs<ExtArgs>
    Avaliacao?: boolean | Quesitos$AvaliacaoArgs<ExtArgs>
  }, ExtArgs["result"]["quesitos"]>

  export type QuesitosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idQuesito?: boolean
    nomeQuesito?: boolean
    notaMaximaQuesito?: boolean
    danca?: boolean
    dancaSalaoTradicional?: boolean
    blocoProvaIdBloco?: boolean
    provaTeoricaIdprovaTeorica?: boolean
    preferenciaSorteioDancaId?: boolean
    avaliacaoIdAvalicao?: boolean
    BlocoProva?: boolean | Quesitos$BlocoProvaArgs<ExtArgs>
    ProvaTeorica?: boolean | Quesitos$ProvaTeoricaArgs<ExtArgs>
    PreferenciaSorteioDanca?: boolean | Quesitos$PreferenciaSorteioDancaArgs<ExtArgs>
    Avaliacao?: boolean | Quesitos$AvaliacaoArgs<ExtArgs>
  }, ExtArgs["result"]["quesitos"]>

  export type QuesitosSelectScalar = {
    idQuesito?: boolean
    nomeQuesito?: boolean
    notaMaximaQuesito?: boolean
    danca?: boolean
    dancaSalaoTradicional?: boolean
    blocoProvaIdBloco?: boolean
    provaTeoricaIdprovaTeorica?: boolean
    preferenciaSorteioDancaId?: boolean
    avaliacaoIdAvalicao?: boolean
  }

  export type QuesitosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idQuesito" | "nomeQuesito" | "notaMaximaQuesito" | "danca" | "dancaSalaoTradicional" | "blocoProvaIdBloco" | "provaTeoricaIdprovaTeorica" | "preferenciaSorteioDancaId" | "avaliacaoIdAvalicao", ExtArgs["result"]["quesitos"]>
  export type QuesitosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BlocoProva?: boolean | Quesitos$BlocoProvaArgs<ExtArgs>
    ProvaTeorica?: boolean | Quesitos$ProvaTeoricaArgs<ExtArgs>
    subeQuesitos?: boolean | Quesitos$subeQuesitosArgs<ExtArgs>
    recursos?: boolean | Quesitos$recursosArgs<ExtArgs>
    PreferenciaSorteioDanca?: boolean | Quesitos$PreferenciaSorteioDancaArgs<ExtArgs>
    Avaliacao?: boolean | Quesitos$AvaliacaoArgs<ExtArgs>
    _count?: boolean | QuesitosCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuesitosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BlocoProva?: boolean | Quesitos$BlocoProvaArgs<ExtArgs>
    ProvaTeorica?: boolean | Quesitos$ProvaTeoricaArgs<ExtArgs>
    PreferenciaSorteioDanca?: boolean | Quesitos$PreferenciaSorteioDancaArgs<ExtArgs>
    Avaliacao?: boolean | Quesitos$AvaliacaoArgs<ExtArgs>
  }
  export type QuesitosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BlocoProva?: boolean | Quesitos$BlocoProvaArgs<ExtArgs>
    ProvaTeorica?: boolean | Quesitos$ProvaTeoricaArgs<ExtArgs>
    PreferenciaSorteioDanca?: boolean | Quesitos$PreferenciaSorteioDancaArgs<ExtArgs>
    Avaliacao?: boolean | Quesitos$AvaliacaoArgs<ExtArgs>
  }

  export type $QuesitosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Quesitos"
    objects: {
      BlocoProva: Prisma.$BlocoProvaPayload<ExtArgs> | null
      ProvaTeorica: Prisma.$ProvaTeoricaPayload<ExtArgs> | null
      subeQuesitos: Prisma.$SubQuesitosPayload<ExtArgs>[]
      recursos: Prisma.$RecursoPayload<ExtArgs>[]
      PreferenciaSorteioDanca: Prisma.$PreferenciaSorteioDancaPayload<ExtArgs> | null
      Avaliacao: Prisma.$AvaliacaoPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      idQuesito: number
      nomeQuesito: string
      notaMaximaQuesito: number
      danca: boolean
      dancaSalaoTradicional: $Enums.DancaSalaoTradicional
      blocoProvaIdBloco: number | null
      provaTeoricaIdprovaTeorica: number | null
      preferenciaSorteioDancaId: number | null
      avaliacaoIdAvalicao: number | null
    }, ExtArgs["result"]["quesitos"]>
    composites: {}
  }

  type QuesitosGetPayload<S extends boolean | null | undefined | QuesitosDefaultArgs> = $Result.GetResult<Prisma.$QuesitosPayload, S>

  type QuesitosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuesitosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuesitosCountAggregateInputType | true
    }

  export interface QuesitosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Quesitos'], meta: { name: 'Quesitos' } }
    /**
     * Find zero or one Quesitos that matches the filter.
     * @param {QuesitosFindUniqueArgs} args - Arguments to find a Quesitos
     * @example
     * // Get one Quesitos
     * const quesitos = await prisma.quesitos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuesitosFindUniqueArgs>(args: SelectSubset<T, QuesitosFindUniqueArgs<ExtArgs>>): Prisma__QuesitosClient<$Result.GetResult<Prisma.$QuesitosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Quesitos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuesitosFindUniqueOrThrowArgs} args - Arguments to find a Quesitos
     * @example
     * // Get one Quesitos
     * const quesitos = await prisma.quesitos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuesitosFindUniqueOrThrowArgs>(args: SelectSubset<T, QuesitosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuesitosClient<$Result.GetResult<Prisma.$QuesitosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quesitos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuesitosFindFirstArgs} args - Arguments to find a Quesitos
     * @example
     * // Get one Quesitos
     * const quesitos = await prisma.quesitos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuesitosFindFirstArgs>(args?: SelectSubset<T, QuesitosFindFirstArgs<ExtArgs>>): Prisma__QuesitosClient<$Result.GetResult<Prisma.$QuesitosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quesitos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuesitosFindFirstOrThrowArgs} args - Arguments to find a Quesitos
     * @example
     * // Get one Quesitos
     * const quesitos = await prisma.quesitos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuesitosFindFirstOrThrowArgs>(args?: SelectSubset<T, QuesitosFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuesitosClient<$Result.GetResult<Prisma.$QuesitosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Quesitos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuesitosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quesitos
     * const quesitos = await prisma.quesitos.findMany()
     * 
     * // Get first 10 Quesitos
     * const quesitos = await prisma.quesitos.findMany({ take: 10 })
     * 
     * // Only select the `idQuesito`
     * const quesitosWithIdQuesitoOnly = await prisma.quesitos.findMany({ select: { idQuesito: true } })
     * 
     */
    findMany<T extends QuesitosFindManyArgs>(args?: SelectSubset<T, QuesitosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuesitosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Quesitos.
     * @param {QuesitosCreateArgs} args - Arguments to create a Quesitos.
     * @example
     * // Create one Quesitos
     * const Quesitos = await prisma.quesitos.create({
     *   data: {
     *     // ... data to create a Quesitos
     *   }
     * })
     * 
     */
    create<T extends QuesitosCreateArgs>(args: SelectSubset<T, QuesitosCreateArgs<ExtArgs>>): Prisma__QuesitosClient<$Result.GetResult<Prisma.$QuesitosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Quesitos.
     * @param {QuesitosCreateManyArgs} args - Arguments to create many Quesitos.
     * @example
     * // Create many Quesitos
     * const quesitos = await prisma.quesitos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuesitosCreateManyArgs>(args?: SelectSubset<T, QuesitosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Quesitos and returns the data saved in the database.
     * @param {QuesitosCreateManyAndReturnArgs} args - Arguments to create many Quesitos.
     * @example
     * // Create many Quesitos
     * const quesitos = await prisma.quesitos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Quesitos and only return the `idQuesito`
     * const quesitosWithIdQuesitoOnly = await prisma.quesitos.createManyAndReturn({
     *   select: { idQuesito: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuesitosCreateManyAndReturnArgs>(args?: SelectSubset<T, QuesitosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuesitosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Quesitos.
     * @param {QuesitosDeleteArgs} args - Arguments to delete one Quesitos.
     * @example
     * // Delete one Quesitos
     * const Quesitos = await prisma.quesitos.delete({
     *   where: {
     *     // ... filter to delete one Quesitos
     *   }
     * })
     * 
     */
    delete<T extends QuesitosDeleteArgs>(args: SelectSubset<T, QuesitosDeleteArgs<ExtArgs>>): Prisma__QuesitosClient<$Result.GetResult<Prisma.$QuesitosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Quesitos.
     * @param {QuesitosUpdateArgs} args - Arguments to update one Quesitos.
     * @example
     * // Update one Quesitos
     * const quesitos = await prisma.quesitos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuesitosUpdateArgs>(args: SelectSubset<T, QuesitosUpdateArgs<ExtArgs>>): Prisma__QuesitosClient<$Result.GetResult<Prisma.$QuesitosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Quesitos.
     * @param {QuesitosDeleteManyArgs} args - Arguments to filter Quesitos to delete.
     * @example
     * // Delete a few Quesitos
     * const { count } = await prisma.quesitos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuesitosDeleteManyArgs>(args?: SelectSubset<T, QuesitosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quesitos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuesitosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quesitos
     * const quesitos = await prisma.quesitos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuesitosUpdateManyArgs>(args: SelectSubset<T, QuesitosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quesitos and returns the data updated in the database.
     * @param {QuesitosUpdateManyAndReturnArgs} args - Arguments to update many Quesitos.
     * @example
     * // Update many Quesitos
     * const quesitos = await prisma.quesitos.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Quesitos and only return the `idQuesito`
     * const quesitosWithIdQuesitoOnly = await prisma.quesitos.updateManyAndReturn({
     *   select: { idQuesito: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuesitosUpdateManyAndReturnArgs>(args: SelectSubset<T, QuesitosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuesitosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Quesitos.
     * @param {QuesitosUpsertArgs} args - Arguments to update or create a Quesitos.
     * @example
     * // Update or create a Quesitos
     * const quesitos = await prisma.quesitos.upsert({
     *   create: {
     *     // ... data to create a Quesitos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quesitos we want to update
     *   }
     * })
     */
    upsert<T extends QuesitosUpsertArgs>(args: SelectSubset<T, QuesitosUpsertArgs<ExtArgs>>): Prisma__QuesitosClient<$Result.GetResult<Prisma.$QuesitosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Quesitos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuesitosCountArgs} args - Arguments to filter Quesitos to count.
     * @example
     * // Count the number of Quesitos
     * const count = await prisma.quesitos.count({
     *   where: {
     *     // ... the filter for the Quesitos we want to count
     *   }
     * })
    **/
    count<T extends QuesitosCountArgs>(
      args?: Subset<T, QuesitosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuesitosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quesitos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuesitosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuesitosAggregateArgs>(args: Subset<T, QuesitosAggregateArgs>): Prisma.PrismaPromise<GetQuesitosAggregateType<T>>

    /**
     * Group by Quesitos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuesitosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuesitosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuesitosGroupByArgs['orderBy'] }
        : { orderBy?: QuesitosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuesitosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuesitosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Quesitos model
   */
  readonly fields: QuesitosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Quesitos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuesitosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    BlocoProva<T extends Quesitos$BlocoProvaArgs<ExtArgs> = {}>(args?: Subset<T, Quesitos$BlocoProvaArgs<ExtArgs>>): Prisma__BlocoProvaClient<$Result.GetResult<Prisma.$BlocoProvaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ProvaTeorica<T extends Quesitos$ProvaTeoricaArgs<ExtArgs> = {}>(args?: Subset<T, Quesitos$ProvaTeoricaArgs<ExtArgs>>): Prisma__ProvaTeoricaClient<$Result.GetResult<Prisma.$ProvaTeoricaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subeQuesitos<T extends Quesitos$subeQuesitosArgs<ExtArgs> = {}>(args?: Subset<T, Quesitos$subeQuesitosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubQuesitosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recursos<T extends Quesitos$recursosArgs<ExtArgs> = {}>(args?: Subset<T, Quesitos$recursosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecursoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PreferenciaSorteioDanca<T extends Quesitos$PreferenciaSorteioDancaArgs<ExtArgs> = {}>(args?: Subset<T, Quesitos$PreferenciaSorteioDancaArgs<ExtArgs>>): Prisma__PreferenciaSorteioDancaClient<$Result.GetResult<Prisma.$PreferenciaSorteioDancaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Avaliacao<T extends Quesitos$AvaliacaoArgs<ExtArgs> = {}>(args?: Subset<T, Quesitos$AvaliacaoArgs<ExtArgs>>): Prisma__AvaliacaoClient<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Quesitos model
   */
  interface QuesitosFieldRefs {
    readonly idQuesito: FieldRef<"Quesitos", 'Int'>
    readonly nomeQuesito: FieldRef<"Quesitos", 'String'>
    readonly notaMaximaQuesito: FieldRef<"Quesitos", 'Float'>
    readonly danca: FieldRef<"Quesitos", 'Boolean'>
    readonly dancaSalaoTradicional: FieldRef<"Quesitos", 'DancaSalaoTradicional'>
    readonly blocoProvaIdBloco: FieldRef<"Quesitos", 'Int'>
    readonly provaTeoricaIdprovaTeorica: FieldRef<"Quesitos", 'Int'>
    readonly preferenciaSorteioDancaId: FieldRef<"Quesitos", 'Int'>
    readonly avaliacaoIdAvalicao: FieldRef<"Quesitos", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Quesitos findUnique
   */
  export type QuesitosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quesitos
     */
    select?: QuesitosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quesitos
     */
    omit?: QuesitosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuesitosInclude<ExtArgs> | null
    /**
     * Filter, which Quesitos to fetch.
     */
    where: QuesitosWhereUniqueInput
  }

  /**
   * Quesitos findUniqueOrThrow
   */
  export type QuesitosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quesitos
     */
    select?: QuesitosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quesitos
     */
    omit?: QuesitosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuesitosInclude<ExtArgs> | null
    /**
     * Filter, which Quesitos to fetch.
     */
    where: QuesitosWhereUniqueInput
  }

  /**
   * Quesitos findFirst
   */
  export type QuesitosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quesitos
     */
    select?: QuesitosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quesitos
     */
    omit?: QuesitosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuesitosInclude<ExtArgs> | null
    /**
     * Filter, which Quesitos to fetch.
     */
    where?: QuesitosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quesitos to fetch.
     */
    orderBy?: QuesitosOrderByWithRelationInput | QuesitosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quesitos.
     */
    cursor?: QuesitosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quesitos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quesitos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quesitos.
     */
    distinct?: QuesitosScalarFieldEnum | QuesitosScalarFieldEnum[]
  }

  /**
   * Quesitos findFirstOrThrow
   */
  export type QuesitosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quesitos
     */
    select?: QuesitosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quesitos
     */
    omit?: QuesitosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuesitosInclude<ExtArgs> | null
    /**
     * Filter, which Quesitos to fetch.
     */
    where?: QuesitosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quesitos to fetch.
     */
    orderBy?: QuesitosOrderByWithRelationInput | QuesitosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quesitos.
     */
    cursor?: QuesitosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quesitos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quesitos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quesitos.
     */
    distinct?: QuesitosScalarFieldEnum | QuesitosScalarFieldEnum[]
  }

  /**
   * Quesitos findMany
   */
  export type QuesitosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quesitos
     */
    select?: QuesitosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quesitos
     */
    omit?: QuesitosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuesitosInclude<ExtArgs> | null
    /**
     * Filter, which Quesitos to fetch.
     */
    where?: QuesitosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quesitos to fetch.
     */
    orderBy?: QuesitosOrderByWithRelationInput | QuesitosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Quesitos.
     */
    cursor?: QuesitosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quesitos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quesitos.
     */
    skip?: number
    distinct?: QuesitosScalarFieldEnum | QuesitosScalarFieldEnum[]
  }

  /**
   * Quesitos create
   */
  export type QuesitosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quesitos
     */
    select?: QuesitosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quesitos
     */
    omit?: QuesitosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuesitosInclude<ExtArgs> | null
    /**
     * The data needed to create a Quesitos.
     */
    data: XOR<QuesitosCreateInput, QuesitosUncheckedCreateInput>
  }

  /**
   * Quesitos createMany
   */
  export type QuesitosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Quesitos.
     */
    data: QuesitosCreateManyInput | QuesitosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Quesitos createManyAndReturn
   */
  export type QuesitosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quesitos
     */
    select?: QuesitosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quesitos
     */
    omit?: QuesitosOmit<ExtArgs> | null
    /**
     * The data used to create many Quesitos.
     */
    data: QuesitosCreateManyInput | QuesitosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuesitosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quesitos update
   */
  export type QuesitosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quesitos
     */
    select?: QuesitosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quesitos
     */
    omit?: QuesitosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuesitosInclude<ExtArgs> | null
    /**
     * The data needed to update a Quesitos.
     */
    data: XOR<QuesitosUpdateInput, QuesitosUncheckedUpdateInput>
    /**
     * Choose, which Quesitos to update.
     */
    where: QuesitosWhereUniqueInput
  }

  /**
   * Quesitos updateMany
   */
  export type QuesitosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Quesitos.
     */
    data: XOR<QuesitosUpdateManyMutationInput, QuesitosUncheckedUpdateManyInput>
    /**
     * Filter which Quesitos to update
     */
    where?: QuesitosWhereInput
    /**
     * Limit how many Quesitos to update.
     */
    limit?: number
  }

  /**
   * Quesitos updateManyAndReturn
   */
  export type QuesitosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quesitos
     */
    select?: QuesitosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quesitos
     */
    omit?: QuesitosOmit<ExtArgs> | null
    /**
     * The data used to update Quesitos.
     */
    data: XOR<QuesitosUpdateManyMutationInput, QuesitosUncheckedUpdateManyInput>
    /**
     * Filter which Quesitos to update
     */
    where?: QuesitosWhereInput
    /**
     * Limit how many Quesitos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuesitosIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quesitos upsert
   */
  export type QuesitosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quesitos
     */
    select?: QuesitosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quesitos
     */
    omit?: QuesitosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuesitosInclude<ExtArgs> | null
    /**
     * The filter to search for the Quesitos to update in case it exists.
     */
    where: QuesitosWhereUniqueInput
    /**
     * In case the Quesitos found by the `where` argument doesn't exist, create a new Quesitos with this data.
     */
    create: XOR<QuesitosCreateInput, QuesitosUncheckedCreateInput>
    /**
     * In case the Quesitos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuesitosUpdateInput, QuesitosUncheckedUpdateInput>
  }

  /**
   * Quesitos delete
   */
  export type QuesitosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quesitos
     */
    select?: QuesitosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quesitos
     */
    omit?: QuesitosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuesitosInclude<ExtArgs> | null
    /**
     * Filter which Quesitos to delete.
     */
    where: QuesitosWhereUniqueInput
  }

  /**
   * Quesitos deleteMany
   */
  export type QuesitosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quesitos to delete
     */
    where?: QuesitosWhereInput
    /**
     * Limit how many Quesitos to delete.
     */
    limit?: number
  }

  /**
   * Quesitos.BlocoProva
   */
  export type Quesitos$BlocoProvaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlocoProva
     */
    select?: BlocoProvaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlocoProva
     */
    omit?: BlocoProvaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlocoProvaInclude<ExtArgs> | null
    where?: BlocoProvaWhereInput
  }

  /**
   * Quesitos.ProvaTeorica
   */
  export type Quesitos$ProvaTeoricaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvaTeorica
     */
    select?: ProvaTeoricaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProvaTeorica
     */
    omit?: ProvaTeoricaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaTeoricaInclude<ExtArgs> | null
    where?: ProvaTeoricaWhereInput
  }

  /**
   * Quesitos.subeQuesitos
   */
  export type Quesitos$subeQuesitosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubQuesitos
     */
    select?: SubQuesitosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubQuesitos
     */
    omit?: SubQuesitosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubQuesitosInclude<ExtArgs> | null
    where?: SubQuesitosWhereInput
    orderBy?: SubQuesitosOrderByWithRelationInput | SubQuesitosOrderByWithRelationInput[]
    cursor?: SubQuesitosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubQuesitosScalarFieldEnum | SubQuesitosScalarFieldEnum[]
  }

  /**
   * Quesitos.recursos
   */
  export type Quesitos$recursosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recurso
     */
    select?: RecursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recurso
     */
    omit?: RecursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecursoInclude<ExtArgs> | null
    where?: RecursoWhereInput
    orderBy?: RecursoOrderByWithRelationInput | RecursoOrderByWithRelationInput[]
    cursor?: RecursoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecursoScalarFieldEnum | RecursoScalarFieldEnum[]
  }

  /**
   * Quesitos.PreferenciaSorteioDanca
   */
  export type Quesitos$PreferenciaSorteioDancaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferenciaSorteioDanca
     */
    select?: PreferenciaSorteioDancaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreferenciaSorteioDanca
     */
    omit?: PreferenciaSorteioDancaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferenciaSorteioDancaInclude<ExtArgs> | null
    where?: PreferenciaSorteioDancaWhereInput
  }

  /**
   * Quesitos.Avaliacao
   */
  export type Quesitos$AvaliacaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avaliacao
     */
    omit?: AvaliacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    where?: AvaliacaoWhereInput
  }

  /**
   * Quesitos without action
   */
  export type QuesitosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quesitos
     */
    select?: QuesitosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quesitos
     */
    omit?: QuesitosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuesitosInclude<ExtArgs> | null
  }


  /**
   * Model SubQuesitos
   */

  export type AggregateSubQuesitos = {
    _count: SubQuesitosCountAggregateOutputType | null
    _avg: SubQuesitosAvgAggregateOutputType | null
    _sum: SubQuesitosSumAggregateOutputType | null
    _min: SubQuesitosMinAggregateOutputType | null
    _max: SubQuesitosMaxAggregateOutputType | null
  }

  export type SubQuesitosAvgAggregateOutputType = {
    idSubequestios: number | null
    notaSubequesito: number | null
    quesitoId: number | null
  }

  export type SubQuesitosSumAggregateOutputType = {
    idSubequestios: number | null
    notaSubequesito: number | null
    quesitoId: number | null
  }

  export type SubQuesitosMinAggregateOutputType = {
    idSubequestios: number | null
    nomeSubquesito: string | null
    notaSubequesito: number | null
    quesitoId: number | null
  }

  export type SubQuesitosMaxAggregateOutputType = {
    idSubequestios: number | null
    nomeSubquesito: string | null
    notaSubequesito: number | null
    quesitoId: number | null
  }

  export type SubQuesitosCountAggregateOutputType = {
    idSubequestios: number
    nomeSubquesito: number
    notaSubequesito: number
    quesitoId: number
    _all: number
  }


  export type SubQuesitosAvgAggregateInputType = {
    idSubequestios?: true
    notaSubequesito?: true
    quesitoId?: true
  }

  export type SubQuesitosSumAggregateInputType = {
    idSubequestios?: true
    notaSubequesito?: true
    quesitoId?: true
  }

  export type SubQuesitosMinAggregateInputType = {
    idSubequestios?: true
    nomeSubquesito?: true
    notaSubequesito?: true
    quesitoId?: true
  }

  export type SubQuesitosMaxAggregateInputType = {
    idSubequestios?: true
    nomeSubquesito?: true
    notaSubequesito?: true
    quesitoId?: true
  }

  export type SubQuesitosCountAggregateInputType = {
    idSubequestios?: true
    nomeSubquesito?: true
    notaSubequesito?: true
    quesitoId?: true
    _all?: true
  }

  export type SubQuesitosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubQuesitos to aggregate.
     */
    where?: SubQuesitosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubQuesitos to fetch.
     */
    orderBy?: SubQuesitosOrderByWithRelationInput | SubQuesitosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubQuesitosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubQuesitos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubQuesitos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubQuesitos
    **/
    _count?: true | SubQuesitosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubQuesitosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubQuesitosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubQuesitosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubQuesitosMaxAggregateInputType
  }

  export type GetSubQuesitosAggregateType<T extends SubQuesitosAggregateArgs> = {
        [P in keyof T & keyof AggregateSubQuesitos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubQuesitos[P]>
      : GetScalarType<T[P], AggregateSubQuesitos[P]>
  }




  export type SubQuesitosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubQuesitosWhereInput
    orderBy?: SubQuesitosOrderByWithAggregationInput | SubQuesitosOrderByWithAggregationInput[]
    by: SubQuesitosScalarFieldEnum[] | SubQuesitosScalarFieldEnum
    having?: SubQuesitosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubQuesitosCountAggregateInputType | true
    _avg?: SubQuesitosAvgAggregateInputType
    _sum?: SubQuesitosSumAggregateInputType
    _min?: SubQuesitosMinAggregateInputType
    _max?: SubQuesitosMaxAggregateInputType
  }

  export type SubQuesitosGroupByOutputType = {
    idSubequestios: number
    nomeSubquesito: string
    notaSubequesito: number
    quesitoId: number
    _count: SubQuesitosCountAggregateOutputType | null
    _avg: SubQuesitosAvgAggregateOutputType | null
    _sum: SubQuesitosSumAggregateOutputType | null
    _min: SubQuesitosMinAggregateOutputType | null
    _max: SubQuesitosMaxAggregateOutputType | null
  }

  type GetSubQuesitosGroupByPayload<T extends SubQuesitosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubQuesitosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubQuesitosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubQuesitosGroupByOutputType[P]>
            : GetScalarType<T[P], SubQuesitosGroupByOutputType[P]>
        }
      >
    >


  export type SubQuesitosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idSubequestios?: boolean
    nomeSubquesito?: boolean
    notaSubequesito?: boolean
    quesitoId?: boolean
    Quesito?: boolean | QuesitosDefaultArgs<ExtArgs>
    subequesitosFilhos?: boolean | SubQuesitos$subequesitosFilhosArgs<ExtArgs>
    subequesitosPai?: boolean | SubQuesitos$subequesitosPaiArgs<ExtArgs>
    _count?: boolean | SubQuesitosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subQuesitos"]>

  export type SubQuesitosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idSubequestios?: boolean
    nomeSubquesito?: boolean
    notaSubequesito?: boolean
    quesitoId?: boolean
    Quesito?: boolean | QuesitosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subQuesitos"]>

  export type SubQuesitosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idSubequestios?: boolean
    nomeSubquesito?: boolean
    notaSubequesito?: boolean
    quesitoId?: boolean
    Quesito?: boolean | QuesitosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subQuesitos"]>

  export type SubQuesitosSelectScalar = {
    idSubequestios?: boolean
    nomeSubquesito?: boolean
    notaSubequesito?: boolean
    quesitoId?: boolean
  }

  export type SubQuesitosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idSubequestios" | "nomeSubquesito" | "notaSubequesito" | "quesitoId", ExtArgs["result"]["subQuesitos"]>
  export type SubQuesitosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Quesito?: boolean | QuesitosDefaultArgs<ExtArgs>
    subequesitosFilhos?: boolean | SubQuesitos$subequesitosFilhosArgs<ExtArgs>
    subequesitosPai?: boolean | SubQuesitos$subequesitosPaiArgs<ExtArgs>
    _count?: boolean | SubQuesitosCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubQuesitosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Quesito?: boolean | QuesitosDefaultArgs<ExtArgs>
  }
  export type SubQuesitosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Quesito?: boolean | QuesitosDefaultArgs<ExtArgs>
  }

  export type $SubQuesitosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubQuesitos"
    objects: {
      Quesito: Prisma.$QuesitosPayload<ExtArgs>
      subequesitosFilhos: Prisma.$SubQuesitosPayload<ExtArgs>[]
      subequesitosPai: Prisma.$SubQuesitosPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idSubequestios: number
      nomeSubquesito: string
      notaSubequesito: number
      quesitoId: number
    }, ExtArgs["result"]["subQuesitos"]>
    composites: {}
  }

  type SubQuesitosGetPayload<S extends boolean | null | undefined | SubQuesitosDefaultArgs> = $Result.GetResult<Prisma.$SubQuesitosPayload, S>

  type SubQuesitosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubQuesitosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubQuesitosCountAggregateInputType | true
    }

  export interface SubQuesitosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubQuesitos'], meta: { name: 'SubQuesitos' } }
    /**
     * Find zero or one SubQuesitos that matches the filter.
     * @param {SubQuesitosFindUniqueArgs} args - Arguments to find a SubQuesitos
     * @example
     * // Get one SubQuesitos
     * const subQuesitos = await prisma.subQuesitos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubQuesitosFindUniqueArgs>(args: SelectSubset<T, SubQuesitosFindUniqueArgs<ExtArgs>>): Prisma__SubQuesitosClient<$Result.GetResult<Prisma.$SubQuesitosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubQuesitos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubQuesitosFindUniqueOrThrowArgs} args - Arguments to find a SubQuesitos
     * @example
     * // Get one SubQuesitos
     * const subQuesitos = await prisma.subQuesitos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubQuesitosFindUniqueOrThrowArgs>(args: SelectSubset<T, SubQuesitosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubQuesitosClient<$Result.GetResult<Prisma.$SubQuesitosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubQuesitos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubQuesitosFindFirstArgs} args - Arguments to find a SubQuesitos
     * @example
     * // Get one SubQuesitos
     * const subQuesitos = await prisma.subQuesitos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubQuesitosFindFirstArgs>(args?: SelectSubset<T, SubQuesitosFindFirstArgs<ExtArgs>>): Prisma__SubQuesitosClient<$Result.GetResult<Prisma.$SubQuesitosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubQuesitos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubQuesitosFindFirstOrThrowArgs} args - Arguments to find a SubQuesitos
     * @example
     * // Get one SubQuesitos
     * const subQuesitos = await prisma.subQuesitos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubQuesitosFindFirstOrThrowArgs>(args?: SelectSubset<T, SubQuesitosFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubQuesitosClient<$Result.GetResult<Prisma.$SubQuesitosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubQuesitos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubQuesitosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubQuesitos
     * const subQuesitos = await prisma.subQuesitos.findMany()
     * 
     * // Get first 10 SubQuesitos
     * const subQuesitos = await prisma.subQuesitos.findMany({ take: 10 })
     * 
     * // Only select the `idSubequestios`
     * const subQuesitosWithIdSubequestiosOnly = await prisma.subQuesitos.findMany({ select: { idSubequestios: true } })
     * 
     */
    findMany<T extends SubQuesitosFindManyArgs>(args?: SelectSubset<T, SubQuesitosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubQuesitosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubQuesitos.
     * @param {SubQuesitosCreateArgs} args - Arguments to create a SubQuesitos.
     * @example
     * // Create one SubQuesitos
     * const SubQuesitos = await prisma.subQuesitos.create({
     *   data: {
     *     // ... data to create a SubQuesitos
     *   }
     * })
     * 
     */
    create<T extends SubQuesitosCreateArgs>(args: SelectSubset<T, SubQuesitosCreateArgs<ExtArgs>>): Prisma__SubQuesitosClient<$Result.GetResult<Prisma.$SubQuesitosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubQuesitos.
     * @param {SubQuesitosCreateManyArgs} args - Arguments to create many SubQuesitos.
     * @example
     * // Create many SubQuesitos
     * const subQuesitos = await prisma.subQuesitos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubQuesitosCreateManyArgs>(args?: SelectSubset<T, SubQuesitosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubQuesitos and returns the data saved in the database.
     * @param {SubQuesitosCreateManyAndReturnArgs} args - Arguments to create many SubQuesitos.
     * @example
     * // Create many SubQuesitos
     * const subQuesitos = await prisma.subQuesitos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubQuesitos and only return the `idSubequestios`
     * const subQuesitosWithIdSubequestiosOnly = await prisma.subQuesitos.createManyAndReturn({
     *   select: { idSubequestios: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubQuesitosCreateManyAndReturnArgs>(args?: SelectSubset<T, SubQuesitosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubQuesitosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubQuesitos.
     * @param {SubQuesitosDeleteArgs} args - Arguments to delete one SubQuesitos.
     * @example
     * // Delete one SubQuesitos
     * const SubQuesitos = await prisma.subQuesitos.delete({
     *   where: {
     *     // ... filter to delete one SubQuesitos
     *   }
     * })
     * 
     */
    delete<T extends SubQuesitosDeleteArgs>(args: SelectSubset<T, SubQuesitosDeleteArgs<ExtArgs>>): Prisma__SubQuesitosClient<$Result.GetResult<Prisma.$SubQuesitosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubQuesitos.
     * @param {SubQuesitosUpdateArgs} args - Arguments to update one SubQuesitos.
     * @example
     * // Update one SubQuesitos
     * const subQuesitos = await prisma.subQuesitos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubQuesitosUpdateArgs>(args: SelectSubset<T, SubQuesitosUpdateArgs<ExtArgs>>): Prisma__SubQuesitosClient<$Result.GetResult<Prisma.$SubQuesitosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubQuesitos.
     * @param {SubQuesitosDeleteManyArgs} args - Arguments to filter SubQuesitos to delete.
     * @example
     * // Delete a few SubQuesitos
     * const { count } = await prisma.subQuesitos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubQuesitosDeleteManyArgs>(args?: SelectSubset<T, SubQuesitosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubQuesitos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubQuesitosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubQuesitos
     * const subQuesitos = await prisma.subQuesitos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubQuesitosUpdateManyArgs>(args: SelectSubset<T, SubQuesitosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubQuesitos and returns the data updated in the database.
     * @param {SubQuesitosUpdateManyAndReturnArgs} args - Arguments to update many SubQuesitos.
     * @example
     * // Update many SubQuesitos
     * const subQuesitos = await prisma.subQuesitos.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubQuesitos and only return the `idSubequestios`
     * const subQuesitosWithIdSubequestiosOnly = await prisma.subQuesitos.updateManyAndReturn({
     *   select: { idSubequestios: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubQuesitosUpdateManyAndReturnArgs>(args: SelectSubset<T, SubQuesitosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubQuesitosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubQuesitos.
     * @param {SubQuesitosUpsertArgs} args - Arguments to update or create a SubQuesitos.
     * @example
     * // Update or create a SubQuesitos
     * const subQuesitos = await prisma.subQuesitos.upsert({
     *   create: {
     *     // ... data to create a SubQuesitos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubQuesitos we want to update
     *   }
     * })
     */
    upsert<T extends SubQuesitosUpsertArgs>(args: SelectSubset<T, SubQuesitosUpsertArgs<ExtArgs>>): Prisma__SubQuesitosClient<$Result.GetResult<Prisma.$SubQuesitosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubQuesitos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubQuesitosCountArgs} args - Arguments to filter SubQuesitos to count.
     * @example
     * // Count the number of SubQuesitos
     * const count = await prisma.subQuesitos.count({
     *   where: {
     *     // ... the filter for the SubQuesitos we want to count
     *   }
     * })
    **/
    count<T extends SubQuesitosCountArgs>(
      args?: Subset<T, SubQuesitosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubQuesitosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubQuesitos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubQuesitosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubQuesitosAggregateArgs>(args: Subset<T, SubQuesitosAggregateArgs>): Prisma.PrismaPromise<GetSubQuesitosAggregateType<T>>

    /**
     * Group by SubQuesitos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubQuesitosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubQuesitosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubQuesitosGroupByArgs['orderBy'] }
        : { orderBy?: SubQuesitosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubQuesitosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubQuesitosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubQuesitos model
   */
  readonly fields: SubQuesitosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubQuesitos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubQuesitosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Quesito<T extends QuesitosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuesitosDefaultArgs<ExtArgs>>): Prisma__QuesitosClient<$Result.GetResult<Prisma.$QuesitosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subequesitosFilhos<T extends SubQuesitos$subequesitosFilhosArgs<ExtArgs> = {}>(args?: Subset<T, SubQuesitos$subequesitosFilhosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubQuesitosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subequesitosPai<T extends SubQuesitos$subequesitosPaiArgs<ExtArgs> = {}>(args?: Subset<T, SubQuesitos$subequesitosPaiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubQuesitosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubQuesitos model
   */
  interface SubQuesitosFieldRefs {
    readonly idSubequestios: FieldRef<"SubQuesitos", 'Int'>
    readonly nomeSubquesito: FieldRef<"SubQuesitos", 'String'>
    readonly notaSubequesito: FieldRef<"SubQuesitos", 'Float'>
    readonly quesitoId: FieldRef<"SubQuesitos", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SubQuesitos findUnique
   */
  export type SubQuesitosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubQuesitos
     */
    select?: SubQuesitosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubQuesitos
     */
    omit?: SubQuesitosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubQuesitosInclude<ExtArgs> | null
    /**
     * Filter, which SubQuesitos to fetch.
     */
    where: SubQuesitosWhereUniqueInput
  }

  /**
   * SubQuesitos findUniqueOrThrow
   */
  export type SubQuesitosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubQuesitos
     */
    select?: SubQuesitosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubQuesitos
     */
    omit?: SubQuesitosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubQuesitosInclude<ExtArgs> | null
    /**
     * Filter, which SubQuesitos to fetch.
     */
    where: SubQuesitosWhereUniqueInput
  }

  /**
   * SubQuesitos findFirst
   */
  export type SubQuesitosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubQuesitos
     */
    select?: SubQuesitosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubQuesitos
     */
    omit?: SubQuesitosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubQuesitosInclude<ExtArgs> | null
    /**
     * Filter, which SubQuesitos to fetch.
     */
    where?: SubQuesitosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubQuesitos to fetch.
     */
    orderBy?: SubQuesitosOrderByWithRelationInput | SubQuesitosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubQuesitos.
     */
    cursor?: SubQuesitosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubQuesitos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubQuesitos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubQuesitos.
     */
    distinct?: SubQuesitosScalarFieldEnum | SubQuesitosScalarFieldEnum[]
  }

  /**
   * SubQuesitos findFirstOrThrow
   */
  export type SubQuesitosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubQuesitos
     */
    select?: SubQuesitosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubQuesitos
     */
    omit?: SubQuesitosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubQuesitosInclude<ExtArgs> | null
    /**
     * Filter, which SubQuesitos to fetch.
     */
    where?: SubQuesitosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubQuesitos to fetch.
     */
    orderBy?: SubQuesitosOrderByWithRelationInput | SubQuesitosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubQuesitos.
     */
    cursor?: SubQuesitosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubQuesitos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubQuesitos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubQuesitos.
     */
    distinct?: SubQuesitosScalarFieldEnum | SubQuesitosScalarFieldEnum[]
  }

  /**
   * SubQuesitos findMany
   */
  export type SubQuesitosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubQuesitos
     */
    select?: SubQuesitosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubQuesitos
     */
    omit?: SubQuesitosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubQuesitosInclude<ExtArgs> | null
    /**
     * Filter, which SubQuesitos to fetch.
     */
    where?: SubQuesitosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubQuesitos to fetch.
     */
    orderBy?: SubQuesitosOrderByWithRelationInput | SubQuesitosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubQuesitos.
     */
    cursor?: SubQuesitosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubQuesitos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubQuesitos.
     */
    skip?: number
    distinct?: SubQuesitosScalarFieldEnum | SubQuesitosScalarFieldEnum[]
  }

  /**
   * SubQuesitos create
   */
  export type SubQuesitosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubQuesitos
     */
    select?: SubQuesitosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubQuesitos
     */
    omit?: SubQuesitosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubQuesitosInclude<ExtArgs> | null
    /**
     * The data needed to create a SubQuesitos.
     */
    data: XOR<SubQuesitosCreateInput, SubQuesitosUncheckedCreateInput>
  }

  /**
   * SubQuesitos createMany
   */
  export type SubQuesitosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubQuesitos.
     */
    data: SubQuesitosCreateManyInput | SubQuesitosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubQuesitos createManyAndReturn
   */
  export type SubQuesitosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubQuesitos
     */
    select?: SubQuesitosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubQuesitos
     */
    omit?: SubQuesitosOmit<ExtArgs> | null
    /**
     * The data used to create many SubQuesitos.
     */
    data: SubQuesitosCreateManyInput | SubQuesitosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubQuesitosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubQuesitos update
   */
  export type SubQuesitosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubQuesitos
     */
    select?: SubQuesitosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubQuesitos
     */
    omit?: SubQuesitosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubQuesitosInclude<ExtArgs> | null
    /**
     * The data needed to update a SubQuesitos.
     */
    data: XOR<SubQuesitosUpdateInput, SubQuesitosUncheckedUpdateInput>
    /**
     * Choose, which SubQuesitos to update.
     */
    where: SubQuesitosWhereUniqueInput
  }

  /**
   * SubQuesitos updateMany
   */
  export type SubQuesitosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubQuesitos.
     */
    data: XOR<SubQuesitosUpdateManyMutationInput, SubQuesitosUncheckedUpdateManyInput>
    /**
     * Filter which SubQuesitos to update
     */
    where?: SubQuesitosWhereInput
    /**
     * Limit how many SubQuesitos to update.
     */
    limit?: number
  }

  /**
   * SubQuesitos updateManyAndReturn
   */
  export type SubQuesitosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubQuesitos
     */
    select?: SubQuesitosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubQuesitos
     */
    omit?: SubQuesitosOmit<ExtArgs> | null
    /**
     * The data used to update SubQuesitos.
     */
    data: XOR<SubQuesitosUpdateManyMutationInput, SubQuesitosUncheckedUpdateManyInput>
    /**
     * Filter which SubQuesitos to update
     */
    where?: SubQuesitosWhereInput
    /**
     * Limit how many SubQuesitos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubQuesitosIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubQuesitos upsert
   */
  export type SubQuesitosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubQuesitos
     */
    select?: SubQuesitosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubQuesitos
     */
    omit?: SubQuesitosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubQuesitosInclude<ExtArgs> | null
    /**
     * The filter to search for the SubQuesitos to update in case it exists.
     */
    where: SubQuesitosWhereUniqueInput
    /**
     * In case the SubQuesitos found by the `where` argument doesn't exist, create a new SubQuesitos with this data.
     */
    create: XOR<SubQuesitosCreateInput, SubQuesitosUncheckedCreateInput>
    /**
     * In case the SubQuesitos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubQuesitosUpdateInput, SubQuesitosUncheckedUpdateInput>
  }

  /**
   * SubQuesitos delete
   */
  export type SubQuesitosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubQuesitos
     */
    select?: SubQuesitosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubQuesitos
     */
    omit?: SubQuesitosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubQuesitosInclude<ExtArgs> | null
    /**
     * Filter which SubQuesitos to delete.
     */
    where: SubQuesitosWhereUniqueInput
  }

  /**
   * SubQuesitos deleteMany
   */
  export type SubQuesitosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubQuesitos to delete
     */
    where?: SubQuesitosWhereInput
    /**
     * Limit how many SubQuesitos to delete.
     */
    limit?: number
  }

  /**
   * SubQuesitos.subequesitosFilhos
   */
  export type SubQuesitos$subequesitosFilhosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubQuesitos
     */
    select?: SubQuesitosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubQuesitos
     */
    omit?: SubQuesitosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubQuesitosInclude<ExtArgs> | null
    where?: SubQuesitosWhereInput
    orderBy?: SubQuesitosOrderByWithRelationInput | SubQuesitosOrderByWithRelationInput[]
    cursor?: SubQuesitosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubQuesitosScalarFieldEnum | SubQuesitosScalarFieldEnum[]
  }

  /**
   * SubQuesitos.subequesitosPai
   */
  export type SubQuesitos$subequesitosPaiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubQuesitos
     */
    select?: SubQuesitosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubQuesitos
     */
    omit?: SubQuesitosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubQuesitosInclude<ExtArgs> | null
    where?: SubQuesitosWhereInput
    orderBy?: SubQuesitosOrderByWithRelationInput | SubQuesitosOrderByWithRelationInput[]
    cursor?: SubQuesitosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubQuesitosScalarFieldEnum | SubQuesitosScalarFieldEnum[]
  }

  /**
   * SubQuesitos without action
   */
  export type SubQuesitosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubQuesitos
     */
    select?: SubQuesitosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubQuesitos
     */
    omit?: SubQuesitosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubQuesitosInclude<ExtArgs> | null
  }


  /**
   * Model Recurso
   */

  export type AggregateRecurso = {
    _count: RecursoCountAggregateOutputType | null
    _avg: RecursoAvgAggregateOutputType | null
    _sum: RecursoSumAggregateOutputType | null
    _min: RecursoMinAggregateOutputType | null
    _max: RecursoMaxAggregateOutputType | null
  }

  export type RecursoAvgAggregateOutputType = {
    idRecurso: number | null
    candidato: number | null
    avaliador: number | null
    quesitoRecurso: number | null
    provaTeoricaIdprovaTeorica: number | null
    provaPraticaIdProvaPratica: number | null
    provaIdProva: number | null
  }

  export type RecursoSumAggregateOutputType = {
    idRecurso: number | null
    candidato: number | null
    avaliador: number | null
    quesitoRecurso: number | null
    provaTeoricaIdprovaTeorica: number | null
    provaPraticaIdProvaPratica: number | null
    provaIdProva: number | null
  }

  export type RecursoMinAggregateOutputType = {
    idRecurso: number | null
    nomeRecurso: string | null
    justificativa: string | null
    status: boolean | null
    dataRecurso: Date | null
    arquivos: Bytes | null
    candidato: number | null
    avaliador: number | null
    quesitoRecurso: number | null
    provaTeoricaIdprovaTeorica: number | null
    provaPraticaIdProvaPratica: number | null
    provaIdProva: number | null
  }

  export type RecursoMaxAggregateOutputType = {
    idRecurso: number | null
    nomeRecurso: string | null
    justificativa: string | null
    status: boolean | null
    dataRecurso: Date | null
    arquivos: Bytes | null
    candidato: number | null
    avaliador: number | null
    quesitoRecurso: number | null
    provaTeoricaIdprovaTeorica: number | null
    provaPraticaIdProvaPratica: number | null
    provaIdProva: number | null
  }

  export type RecursoCountAggregateOutputType = {
    idRecurso: number
    nomeRecurso: number
    justificativa: number
    status: number
    dataRecurso: number
    arquivos: number
    candidato: number
    avaliador: number
    quesitoRecurso: number
    provaTeoricaIdprovaTeorica: number
    provaPraticaIdProvaPratica: number
    provaIdProva: number
    _all: number
  }


  export type RecursoAvgAggregateInputType = {
    idRecurso?: true
    candidato?: true
    avaliador?: true
    quesitoRecurso?: true
    provaTeoricaIdprovaTeorica?: true
    provaPraticaIdProvaPratica?: true
    provaIdProva?: true
  }

  export type RecursoSumAggregateInputType = {
    idRecurso?: true
    candidato?: true
    avaliador?: true
    quesitoRecurso?: true
    provaTeoricaIdprovaTeorica?: true
    provaPraticaIdProvaPratica?: true
    provaIdProva?: true
  }

  export type RecursoMinAggregateInputType = {
    idRecurso?: true
    nomeRecurso?: true
    justificativa?: true
    status?: true
    dataRecurso?: true
    arquivos?: true
    candidato?: true
    avaliador?: true
    quesitoRecurso?: true
    provaTeoricaIdprovaTeorica?: true
    provaPraticaIdProvaPratica?: true
    provaIdProva?: true
  }

  export type RecursoMaxAggregateInputType = {
    idRecurso?: true
    nomeRecurso?: true
    justificativa?: true
    status?: true
    dataRecurso?: true
    arquivos?: true
    candidato?: true
    avaliador?: true
    quesitoRecurso?: true
    provaTeoricaIdprovaTeorica?: true
    provaPraticaIdProvaPratica?: true
    provaIdProva?: true
  }

  export type RecursoCountAggregateInputType = {
    idRecurso?: true
    nomeRecurso?: true
    justificativa?: true
    status?: true
    dataRecurso?: true
    arquivos?: true
    candidato?: true
    avaliador?: true
    quesitoRecurso?: true
    provaTeoricaIdprovaTeorica?: true
    provaPraticaIdProvaPratica?: true
    provaIdProva?: true
    _all?: true
  }

  export type RecursoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recurso to aggregate.
     */
    where?: RecursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recursos to fetch.
     */
    orderBy?: RecursoOrderByWithRelationInput | RecursoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Recursos
    **/
    _count?: true | RecursoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecursoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecursoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecursoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecursoMaxAggregateInputType
  }

  export type GetRecursoAggregateType<T extends RecursoAggregateArgs> = {
        [P in keyof T & keyof AggregateRecurso]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecurso[P]>
      : GetScalarType<T[P], AggregateRecurso[P]>
  }




  export type RecursoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecursoWhereInput
    orderBy?: RecursoOrderByWithAggregationInput | RecursoOrderByWithAggregationInput[]
    by: RecursoScalarFieldEnum[] | RecursoScalarFieldEnum
    having?: RecursoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecursoCountAggregateInputType | true
    _avg?: RecursoAvgAggregateInputType
    _sum?: RecursoSumAggregateInputType
    _min?: RecursoMinAggregateInputType
    _max?: RecursoMaxAggregateInputType
  }

  export type RecursoGroupByOutputType = {
    idRecurso: number
    nomeRecurso: string
    justificativa: string
    status: boolean
    dataRecurso: Date
    arquivos: Bytes
    candidato: number
    avaliador: number
    quesitoRecurso: number
    provaTeoricaIdprovaTeorica: number | null
    provaPraticaIdProvaPratica: number | null
    provaIdProva: number | null
    _count: RecursoCountAggregateOutputType | null
    _avg: RecursoAvgAggregateOutputType | null
    _sum: RecursoSumAggregateOutputType | null
    _min: RecursoMinAggregateOutputType | null
    _max: RecursoMaxAggregateOutputType | null
  }

  type GetRecursoGroupByPayload<T extends RecursoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecursoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecursoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecursoGroupByOutputType[P]>
            : GetScalarType<T[P], RecursoGroupByOutputType[P]>
        }
      >
    >


  export type RecursoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idRecurso?: boolean
    nomeRecurso?: boolean
    justificativa?: boolean
    status?: boolean
    dataRecurso?: boolean
    arquivos?: boolean
    candidato?: boolean
    avaliador?: boolean
    quesitoRecurso?: boolean
    provaTeoricaIdprovaTeorica?: boolean
    provaPraticaIdProvaPratica?: boolean
    provaIdProva?: boolean
    Candidato?: boolean | CandidatoDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    Quesito?: boolean | QuesitosDefaultArgs<ExtArgs>
    ProvaTeorica?: boolean | Recurso$ProvaTeoricaArgs<ExtArgs>
    ProvaPratica?: boolean | Recurso$ProvaPraticaArgs<ExtArgs>
    Prova?: boolean | Recurso$ProvaArgs<ExtArgs>
  }, ExtArgs["result"]["recurso"]>

  export type RecursoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idRecurso?: boolean
    nomeRecurso?: boolean
    justificativa?: boolean
    status?: boolean
    dataRecurso?: boolean
    arquivos?: boolean
    candidato?: boolean
    avaliador?: boolean
    quesitoRecurso?: boolean
    provaTeoricaIdprovaTeorica?: boolean
    provaPraticaIdProvaPratica?: boolean
    provaIdProva?: boolean
    Candidato?: boolean | CandidatoDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    Quesito?: boolean | QuesitosDefaultArgs<ExtArgs>
    ProvaTeorica?: boolean | Recurso$ProvaTeoricaArgs<ExtArgs>
    ProvaPratica?: boolean | Recurso$ProvaPraticaArgs<ExtArgs>
    Prova?: boolean | Recurso$ProvaArgs<ExtArgs>
  }, ExtArgs["result"]["recurso"]>

  export type RecursoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idRecurso?: boolean
    nomeRecurso?: boolean
    justificativa?: boolean
    status?: boolean
    dataRecurso?: boolean
    arquivos?: boolean
    candidato?: boolean
    avaliador?: boolean
    quesitoRecurso?: boolean
    provaTeoricaIdprovaTeorica?: boolean
    provaPraticaIdProvaPratica?: boolean
    provaIdProva?: boolean
    Candidato?: boolean | CandidatoDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    Quesito?: boolean | QuesitosDefaultArgs<ExtArgs>
    ProvaTeorica?: boolean | Recurso$ProvaTeoricaArgs<ExtArgs>
    ProvaPratica?: boolean | Recurso$ProvaPraticaArgs<ExtArgs>
    Prova?: boolean | Recurso$ProvaArgs<ExtArgs>
  }, ExtArgs["result"]["recurso"]>

  export type RecursoSelectScalar = {
    idRecurso?: boolean
    nomeRecurso?: boolean
    justificativa?: boolean
    status?: boolean
    dataRecurso?: boolean
    arquivos?: boolean
    candidato?: boolean
    avaliador?: boolean
    quesitoRecurso?: boolean
    provaTeoricaIdprovaTeorica?: boolean
    provaPraticaIdProvaPratica?: boolean
    provaIdProva?: boolean
  }

  export type RecursoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idRecurso" | "nomeRecurso" | "justificativa" | "status" | "dataRecurso" | "arquivos" | "candidato" | "avaliador" | "quesitoRecurso" | "provaTeoricaIdprovaTeorica" | "provaPraticaIdProvaPratica" | "provaIdProva", ExtArgs["result"]["recurso"]>
  export type RecursoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Candidato?: boolean | CandidatoDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    Quesito?: boolean | QuesitosDefaultArgs<ExtArgs>
    ProvaTeorica?: boolean | Recurso$ProvaTeoricaArgs<ExtArgs>
    ProvaPratica?: boolean | Recurso$ProvaPraticaArgs<ExtArgs>
    Prova?: boolean | Recurso$ProvaArgs<ExtArgs>
  }
  export type RecursoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Candidato?: boolean | CandidatoDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    Quesito?: boolean | QuesitosDefaultArgs<ExtArgs>
    ProvaTeorica?: boolean | Recurso$ProvaTeoricaArgs<ExtArgs>
    ProvaPratica?: boolean | Recurso$ProvaPraticaArgs<ExtArgs>
    Prova?: boolean | Recurso$ProvaArgs<ExtArgs>
  }
  export type RecursoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Candidato?: boolean | CandidatoDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    Quesito?: boolean | QuesitosDefaultArgs<ExtArgs>
    ProvaTeorica?: boolean | Recurso$ProvaTeoricaArgs<ExtArgs>
    ProvaPratica?: boolean | Recurso$ProvaPraticaArgs<ExtArgs>
    Prova?: boolean | Recurso$ProvaArgs<ExtArgs>
  }

  export type $RecursoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Recurso"
    objects: {
      Candidato: Prisma.$CandidatoPayload<ExtArgs>
      Usuario: Prisma.$UsuarioPayload<ExtArgs>
      Quesito: Prisma.$QuesitosPayload<ExtArgs>
      ProvaTeorica: Prisma.$ProvaTeoricaPayload<ExtArgs> | null
      ProvaPratica: Prisma.$ProvaPraticaPayload<ExtArgs> | null
      Prova: Prisma.$ProvaPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      idRecurso: number
      nomeRecurso: string
      justificativa: string
      status: boolean
      dataRecurso: Date
      arquivos: Prisma.Bytes
      candidato: number
      avaliador: number
      quesitoRecurso: number
      provaTeoricaIdprovaTeorica: number | null
      provaPraticaIdProvaPratica: number | null
      provaIdProva: number | null
    }, ExtArgs["result"]["recurso"]>
    composites: {}
  }

  type RecursoGetPayload<S extends boolean | null | undefined | RecursoDefaultArgs> = $Result.GetResult<Prisma.$RecursoPayload, S>

  type RecursoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecursoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecursoCountAggregateInputType | true
    }

  export interface RecursoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Recurso'], meta: { name: 'Recurso' } }
    /**
     * Find zero or one Recurso that matches the filter.
     * @param {RecursoFindUniqueArgs} args - Arguments to find a Recurso
     * @example
     * // Get one Recurso
     * const recurso = await prisma.recurso.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecursoFindUniqueArgs>(args: SelectSubset<T, RecursoFindUniqueArgs<ExtArgs>>): Prisma__RecursoClient<$Result.GetResult<Prisma.$RecursoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Recurso that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecursoFindUniqueOrThrowArgs} args - Arguments to find a Recurso
     * @example
     * // Get one Recurso
     * const recurso = await prisma.recurso.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecursoFindUniqueOrThrowArgs>(args: SelectSubset<T, RecursoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecursoClient<$Result.GetResult<Prisma.$RecursoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Recurso that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecursoFindFirstArgs} args - Arguments to find a Recurso
     * @example
     * // Get one Recurso
     * const recurso = await prisma.recurso.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecursoFindFirstArgs>(args?: SelectSubset<T, RecursoFindFirstArgs<ExtArgs>>): Prisma__RecursoClient<$Result.GetResult<Prisma.$RecursoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Recurso that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecursoFindFirstOrThrowArgs} args - Arguments to find a Recurso
     * @example
     * // Get one Recurso
     * const recurso = await prisma.recurso.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecursoFindFirstOrThrowArgs>(args?: SelectSubset<T, RecursoFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecursoClient<$Result.GetResult<Prisma.$RecursoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Recursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecursoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recursos
     * const recursos = await prisma.recurso.findMany()
     * 
     * // Get first 10 Recursos
     * const recursos = await prisma.recurso.findMany({ take: 10 })
     * 
     * // Only select the `idRecurso`
     * const recursoWithIdRecursoOnly = await prisma.recurso.findMany({ select: { idRecurso: true } })
     * 
     */
    findMany<T extends RecursoFindManyArgs>(args?: SelectSubset<T, RecursoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecursoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Recurso.
     * @param {RecursoCreateArgs} args - Arguments to create a Recurso.
     * @example
     * // Create one Recurso
     * const Recurso = await prisma.recurso.create({
     *   data: {
     *     // ... data to create a Recurso
     *   }
     * })
     * 
     */
    create<T extends RecursoCreateArgs>(args: SelectSubset<T, RecursoCreateArgs<ExtArgs>>): Prisma__RecursoClient<$Result.GetResult<Prisma.$RecursoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Recursos.
     * @param {RecursoCreateManyArgs} args - Arguments to create many Recursos.
     * @example
     * // Create many Recursos
     * const recurso = await prisma.recurso.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecursoCreateManyArgs>(args?: SelectSubset<T, RecursoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Recursos and returns the data saved in the database.
     * @param {RecursoCreateManyAndReturnArgs} args - Arguments to create many Recursos.
     * @example
     * // Create many Recursos
     * const recurso = await prisma.recurso.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Recursos and only return the `idRecurso`
     * const recursoWithIdRecursoOnly = await prisma.recurso.createManyAndReturn({
     *   select: { idRecurso: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecursoCreateManyAndReturnArgs>(args?: SelectSubset<T, RecursoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecursoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Recurso.
     * @param {RecursoDeleteArgs} args - Arguments to delete one Recurso.
     * @example
     * // Delete one Recurso
     * const Recurso = await prisma.recurso.delete({
     *   where: {
     *     // ... filter to delete one Recurso
     *   }
     * })
     * 
     */
    delete<T extends RecursoDeleteArgs>(args: SelectSubset<T, RecursoDeleteArgs<ExtArgs>>): Prisma__RecursoClient<$Result.GetResult<Prisma.$RecursoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Recurso.
     * @param {RecursoUpdateArgs} args - Arguments to update one Recurso.
     * @example
     * // Update one Recurso
     * const recurso = await prisma.recurso.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecursoUpdateArgs>(args: SelectSubset<T, RecursoUpdateArgs<ExtArgs>>): Prisma__RecursoClient<$Result.GetResult<Prisma.$RecursoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Recursos.
     * @param {RecursoDeleteManyArgs} args - Arguments to filter Recursos to delete.
     * @example
     * // Delete a few Recursos
     * const { count } = await prisma.recurso.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecursoDeleteManyArgs>(args?: SelectSubset<T, RecursoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecursoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recursos
     * const recurso = await prisma.recurso.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecursoUpdateManyArgs>(args: SelectSubset<T, RecursoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recursos and returns the data updated in the database.
     * @param {RecursoUpdateManyAndReturnArgs} args - Arguments to update many Recursos.
     * @example
     * // Update many Recursos
     * const recurso = await prisma.recurso.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Recursos and only return the `idRecurso`
     * const recursoWithIdRecursoOnly = await prisma.recurso.updateManyAndReturn({
     *   select: { idRecurso: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RecursoUpdateManyAndReturnArgs>(args: SelectSubset<T, RecursoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecursoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Recurso.
     * @param {RecursoUpsertArgs} args - Arguments to update or create a Recurso.
     * @example
     * // Update or create a Recurso
     * const recurso = await prisma.recurso.upsert({
     *   create: {
     *     // ... data to create a Recurso
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Recurso we want to update
     *   }
     * })
     */
    upsert<T extends RecursoUpsertArgs>(args: SelectSubset<T, RecursoUpsertArgs<ExtArgs>>): Prisma__RecursoClient<$Result.GetResult<Prisma.$RecursoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Recursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecursoCountArgs} args - Arguments to filter Recursos to count.
     * @example
     * // Count the number of Recursos
     * const count = await prisma.recurso.count({
     *   where: {
     *     // ... the filter for the Recursos we want to count
     *   }
     * })
    **/
    count<T extends RecursoCountArgs>(
      args?: Subset<T, RecursoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecursoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Recurso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecursoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecursoAggregateArgs>(args: Subset<T, RecursoAggregateArgs>): Prisma.PrismaPromise<GetRecursoAggregateType<T>>

    /**
     * Group by Recurso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecursoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecursoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecursoGroupByArgs['orderBy'] }
        : { orderBy?: RecursoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecursoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecursoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Recurso model
   */
  readonly fields: RecursoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Recurso.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecursoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Candidato<T extends CandidatoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CandidatoDefaultArgs<ExtArgs>>): Prisma__CandidatoClient<$Result.GetResult<Prisma.$CandidatoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Quesito<T extends QuesitosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuesitosDefaultArgs<ExtArgs>>): Prisma__QuesitosClient<$Result.GetResult<Prisma.$QuesitosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ProvaTeorica<T extends Recurso$ProvaTeoricaArgs<ExtArgs> = {}>(args?: Subset<T, Recurso$ProvaTeoricaArgs<ExtArgs>>): Prisma__ProvaTeoricaClient<$Result.GetResult<Prisma.$ProvaTeoricaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ProvaPratica<T extends Recurso$ProvaPraticaArgs<ExtArgs> = {}>(args?: Subset<T, Recurso$ProvaPraticaArgs<ExtArgs>>): Prisma__ProvaPraticaClient<$Result.GetResult<Prisma.$ProvaPraticaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Prova<T extends Recurso$ProvaArgs<ExtArgs> = {}>(args?: Subset<T, Recurso$ProvaArgs<ExtArgs>>): Prisma__ProvaClient<$Result.GetResult<Prisma.$ProvaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Recurso model
   */
  interface RecursoFieldRefs {
    readonly idRecurso: FieldRef<"Recurso", 'Int'>
    readonly nomeRecurso: FieldRef<"Recurso", 'String'>
    readonly justificativa: FieldRef<"Recurso", 'String'>
    readonly status: FieldRef<"Recurso", 'Boolean'>
    readonly dataRecurso: FieldRef<"Recurso", 'DateTime'>
    readonly arquivos: FieldRef<"Recurso", 'Bytes'>
    readonly candidato: FieldRef<"Recurso", 'Int'>
    readonly avaliador: FieldRef<"Recurso", 'Int'>
    readonly quesitoRecurso: FieldRef<"Recurso", 'Int'>
    readonly provaTeoricaIdprovaTeorica: FieldRef<"Recurso", 'Int'>
    readonly provaPraticaIdProvaPratica: FieldRef<"Recurso", 'Int'>
    readonly provaIdProva: FieldRef<"Recurso", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Recurso findUnique
   */
  export type RecursoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recurso
     */
    select?: RecursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recurso
     */
    omit?: RecursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecursoInclude<ExtArgs> | null
    /**
     * Filter, which Recurso to fetch.
     */
    where: RecursoWhereUniqueInput
  }

  /**
   * Recurso findUniqueOrThrow
   */
  export type RecursoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recurso
     */
    select?: RecursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recurso
     */
    omit?: RecursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecursoInclude<ExtArgs> | null
    /**
     * Filter, which Recurso to fetch.
     */
    where: RecursoWhereUniqueInput
  }

  /**
   * Recurso findFirst
   */
  export type RecursoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recurso
     */
    select?: RecursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recurso
     */
    omit?: RecursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecursoInclude<ExtArgs> | null
    /**
     * Filter, which Recurso to fetch.
     */
    where?: RecursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recursos to fetch.
     */
    orderBy?: RecursoOrderByWithRelationInput | RecursoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recursos.
     */
    cursor?: RecursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recursos.
     */
    distinct?: RecursoScalarFieldEnum | RecursoScalarFieldEnum[]
  }

  /**
   * Recurso findFirstOrThrow
   */
  export type RecursoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recurso
     */
    select?: RecursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recurso
     */
    omit?: RecursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecursoInclude<ExtArgs> | null
    /**
     * Filter, which Recurso to fetch.
     */
    where?: RecursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recursos to fetch.
     */
    orderBy?: RecursoOrderByWithRelationInput | RecursoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recursos.
     */
    cursor?: RecursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recursos.
     */
    distinct?: RecursoScalarFieldEnum | RecursoScalarFieldEnum[]
  }

  /**
   * Recurso findMany
   */
  export type RecursoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recurso
     */
    select?: RecursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recurso
     */
    omit?: RecursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecursoInclude<ExtArgs> | null
    /**
     * Filter, which Recursos to fetch.
     */
    where?: RecursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recursos to fetch.
     */
    orderBy?: RecursoOrderByWithRelationInput | RecursoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Recursos.
     */
    cursor?: RecursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recursos.
     */
    skip?: number
    distinct?: RecursoScalarFieldEnum | RecursoScalarFieldEnum[]
  }

  /**
   * Recurso create
   */
  export type RecursoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recurso
     */
    select?: RecursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recurso
     */
    omit?: RecursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecursoInclude<ExtArgs> | null
    /**
     * The data needed to create a Recurso.
     */
    data: XOR<RecursoCreateInput, RecursoUncheckedCreateInput>
  }

  /**
   * Recurso createMany
   */
  export type RecursoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Recursos.
     */
    data: RecursoCreateManyInput | RecursoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Recurso createManyAndReturn
   */
  export type RecursoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recurso
     */
    select?: RecursoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Recurso
     */
    omit?: RecursoOmit<ExtArgs> | null
    /**
     * The data used to create many Recursos.
     */
    data: RecursoCreateManyInput | RecursoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecursoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Recurso update
   */
  export type RecursoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recurso
     */
    select?: RecursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recurso
     */
    omit?: RecursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecursoInclude<ExtArgs> | null
    /**
     * The data needed to update a Recurso.
     */
    data: XOR<RecursoUpdateInput, RecursoUncheckedUpdateInput>
    /**
     * Choose, which Recurso to update.
     */
    where: RecursoWhereUniqueInput
  }

  /**
   * Recurso updateMany
   */
  export type RecursoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Recursos.
     */
    data: XOR<RecursoUpdateManyMutationInput, RecursoUncheckedUpdateManyInput>
    /**
     * Filter which Recursos to update
     */
    where?: RecursoWhereInput
    /**
     * Limit how many Recursos to update.
     */
    limit?: number
  }

  /**
   * Recurso updateManyAndReturn
   */
  export type RecursoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recurso
     */
    select?: RecursoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Recurso
     */
    omit?: RecursoOmit<ExtArgs> | null
    /**
     * The data used to update Recursos.
     */
    data: XOR<RecursoUpdateManyMutationInput, RecursoUncheckedUpdateManyInput>
    /**
     * Filter which Recursos to update
     */
    where?: RecursoWhereInput
    /**
     * Limit how many Recursos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecursoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Recurso upsert
   */
  export type RecursoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recurso
     */
    select?: RecursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recurso
     */
    omit?: RecursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecursoInclude<ExtArgs> | null
    /**
     * The filter to search for the Recurso to update in case it exists.
     */
    where: RecursoWhereUniqueInput
    /**
     * In case the Recurso found by the `where` argument doesn't exist, create a new Recurso with this data.
     */
    create: XOR<RecursoCreateInput, RecursoUncheckedCreateInput>
    /**
     * In case the Recurso was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecursoUpdateInput, RecursoUncheckedUpdateInput>
  }

  /**
   * Recurso delete
   */
  export type RecursoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recurso
     */
    select?: RecursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recurso
     */
    omit?: RecursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecursoInclude<ExtArgs> | null
    /**
     * Filter which Recurso to delete.
     */
    where: RecursoWhereUniqueInput
  }

  /**
   * Recurso deleteMany
   */
  export type RecursoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recursos to delete
     */
    where?: RecursoWhereInput
    /**
     * Limit how many Recursos to delete.
     */
    limit?: number
  }

  /**
   * Recurso.ProvaTeorica
   */
  export type Recurso$ProvaTeoricaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvaTeorica
     */
    select?: ProvaTeoricaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProvaTeorica
     */
    omit?: ProvaTeoricaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaTeoricaInclude<ExtArgs> | null
    where?: ProvaTeoricaWhereInput
  }

  /**
   * Recurso.ProvaPratica
   */
  export type Recurso$ProvaPraticaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvaPratica
     */
    select?: ProvaPraticaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProvaPratica
     */
    omit?: ProvaPraticaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaPraticaInclude<ExtArgs> | null
    where?: ProvaPraticaWhereInput
  }

  /**
   * Recurso.Prova
   */
  export type Recurso$ProvaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prova
     */
    select?: ProvaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prova
     */
    omit?: ProvaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvaInclude<ExtArgs> | null
    where?: ProvaWhereInput
  }

  /**
   * Recurso without action
   */
  export type RecursoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recurso
     */
    select?: RecursoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recurso
     */
    omit?: RecursoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecursoInclude<ExtArgs> | null
  }


  /**
   * Model SorteioDanca
   */

  export type AggregateSorteioDanca = {
    _count: SorteioDancaCountAggregateOutputType | null
    _avg: SorteioDancaAvgAggregateOutputType | null
    _sum: SorteioDancaSumAggregateOutputType | null
    _min: SorteioDancaMinAggregateOutputType | null
    _max: SorteioDancaMaxAggregateOutputType | null
  }

  export type SorteioDancaAvgAggregateOutputType = {
    idSorteio: number | null
    resultadoSorteio: number | null
    candidatoId: number | null
    usuarioId: number | null
  }

  export type SorteioDancaSumAggregateOutputType = {
    idSorteio: number | null
    resultadoSorteio: number | null
    candidatoId: number | null
    usuarioId: number | null
  }

  export type SorteioDancaMinAggregateOutputType = {
    idSorteio: number | null
    resultadoSorteio: number | null
    dataSorteio: Date | null
    tipoDanca: $Enums.DancaSalaoTradicional | null
    candidatoId: number | null
    usuarioId: number | null
  }

  export type SorteioDancaMaxAggregateOutputType = {
    idSorteio: number | null
    resultadoSorteio: number | null
    dataSorteio: Date | null
    tipoDanca: $Enums.DancaSalaoTradicional | null
    candidatoId: number | null
    usuarioId: number | null
  }

  export type SorteioDancaCountAggregateOutputType = {
    idSorteio: number
    resultadoSorteio: number
    dataSorteio: number
    tipoDanca: number
    candidatoId: number
    usuarioId: number
    _all: number
  }


  export type SorteioDancaAvgAggregateInputType = {
    idSorteio?: true
    resultadoSorteio?: true
    candidatoId?: true
    usuarioId?: true
  }

  export type SorteioDancaSumAggregateInputType = {
    idSorteio?: true
    resultadoSorteio?: true
    candidatoId?: true
    usuarioId?: true
  }

  export type SorteioDancaMinAggregateInputType = {
    idSorteio?: true
    resultadoSorteio?: true
    dataSorteio?: true
    tipoDanca?: true
    candidatoId?: true
    usuarioId?: true
  }

  export type SorteioDancaMaxAggregateInputType = {
    idSorteio?: true
    resultadoSorteio?: true
    dataSorteio?: true
    tipoDanca?: true
    candidatoId?: true
    usuarioId?: true
  }

  export type SorteioDancaCountAggregateInputType = {
    idSorteio?: true
    resultadoSorteio?: true
    dataSorteio?: true
    tipoDanca?: true
    candidatoId?: true
    usuarioId?: true
    _all?: true
  }

  export type SorteioDancaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SorteioDanca to aggregate.
     */
    where?: SorteioDancaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SorteioDancas to fetch.
     */
    orderBy?: SorteioDancaOrderByWithRelationInput | SorteioDancaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SorteioDancaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SorteioDancas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SorteioDancas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SorteioDancas
    **/
    _count?: true | SorteioDancaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SorteioDancaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SorteioDancaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SorteioDancaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SorteioDancaMaxAggregateInputType
  }

  export type GetSorteioDancaAggregateType<T extends SorteioDancaAggregateArgs> = {
        [P in keyof T & keyof AggregateSorteioDanca]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSorteioDanca[P]>
      : GetScalarType<T[P], AggregateSorteioDanca[P]>
  }




  export type SorteioDancaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SorteioDancaWhereInput
    orderBy?: SorteioDancaOrderByWithAggregationInput | SorteioDancaOrderByWithAggregationInput[]
    by: SorteioDancaScalarFieldEnum[] | SorteioDancaScalarFieldEnum
    having?: SorteioDancaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SorteioDancaCountAggregateInputType | true
    _avg?: SorteioDancaAvgAggregateInputType
    _sum?: SorteioDancaSumAggregateInputType
    _min?: SorteioDancaMinAggregateInputType
    _max?: SorteioDancaMaxAggregateInputType
  }

  export type SorteioDancaGroupByOutputType = {
    idSorteio: number
    resultadoSorteio: number
    dataSorteio: Date
    tipoDanca: $Enums.DancaSalaoTradicional
    candidatoId: number
    usuarioId: number
    _count: SorteioDancaCountAggregateOutputType | null
    _avg: SorteioDancaAvgAggregateOutputType | null
    _sum: SorteioDancaSumAggregateOutputType | null
    _min: SorteioDancaMinAggregateOutputType | null
    _max: SorteioDancaMaxAggregateOutputType | null
  }

  type GetSorteioDancaGroupByPayload<T extends SorteioDancaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SorteioDancaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SorteioDancaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SorteioDancaGroupByOutputType[P]>
            : GetScalarType<T[P], SorteioDancaGroupByOutputType[P]>
        }
      >
    >


  export type SorteioDancaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idSorteio?: boolean
    resultadoSorteio?: boolean
    dataSorteio?: boolean
    tipoDanca?: boolean
    candidatoId?: boolean
    usuarioId?: boolean
    preferenciaSorteioDancaIds?: boolean | SorteioDanca$preferenciaSorteioDancaIdsArgs<ExtArgs>
    Candidato?: boolean | CandidatoDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    _count?: boolean | SorteioDancaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sorteioDanca"]>

  export type SorteioDancaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idSorteio?: boolean
    resultadoSorteio?: boolean
    dataSorteio?: boolean
    tipoDanca?: boolean
    candidatoId?: boolean
    usuarioId?: boolean
    Candidato?: boolean | CandidatoDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sorteioDanca"]>

  export type SorteioDancaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idSorteio?: boolean
    resultadoSorteio?: boolean
    dataSorteio?: boolean
    tipoDanca?: boolean
    candidatoId?: boolean
    usuarioId?: boolean
    Candidato?: boolean | CandidatoDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sorteioDanca"]>

  export type SorteioDancaSelectScalar = {
    idSorteio?: boolean
    resultadoSorteio?: boolean
    dataSorteio?: boolean
    tipoDanca?: boolean
    candidatoId?: boolean
    usuarioId?: boolean
  }

  export type SorteioDancaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idSorteio" | "resultadoSorteio" | "dataSorteio" | "tipoDanca" | "candidatoId" | "usuarioId", ExtArgs["result"]["sorteioDanca"]>
  export type SorteioDancaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    preferenciaSorteioDancaIds?: boolean | SorteioDanca$preferenciaSorteioDancaIdsArgs<ExtArgs>
    Candidato?: boolean | CandidatoDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    _count?: boolean | SorteioDancaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SorteioDancaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Candidato?: boolean | CandidatoDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type SorteioDancaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Candidato?: boolean | CandidatoDefaultArgs<ExtArgs>
    Usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $SorteioDancaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SorteioDanca"
    objects: {
      preferenciaSorteioDancaIds: Prisma.$PreferenciaSorteioDancaPayload<ExtArgs>[]
      Candidato: Prisma.$CandidatoPayload<ExtArgs>
      Usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idSorteio: number
      resultadoSorteio: number
      dataSorteio: Date
      tipoDanca: $Enums.DancaSalaoTradicional
      candidatoId: number
      usuarioId: number
    }, ExtArgs["result"]["sorteioDanca"]>
    composites: {}
  }

  type SorteioDancaGetPayload<S extends boolean | null | undefined | SorteioDancaDefaultArgs> = $Result.GetResult<Prisma.$SorteioDancaPayload, S>

  type SorteioDancaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SorteioDancaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SorteioDancaCountAggregateInputType | true
    }

  export interface SorteioDancaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SorteioDanca'], meta: { name: 'SorteioDanca' } }
    /**
     * Find zero or one SorteioDanca that matches the filter.
     * @param {SorteioDancaFindUniqueArgs} args - Arguments to find a SorteioDanca
     * @example
     * // Get one SorteioDanca
     * const sorteioDanca = await prisma.sorteioDanca.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SorteioDancaFindUniqueArgs>(args: SelectSubset<T, SorteioDancaFindUniqueArgs<ExtArgs>>): Prisma__SorteioDancaClient<$Result.GetResult<Prisma.$SorteioDancaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SorteioDanca that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SorteioDancaFindUniqueOrThrowArgs} args - Arguments to find a SorteioDanca
     * @example
     * // Get one SorteioDanca
     * const sorteioDanca = await prisma.sorteioDanca.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SorteioDancaFindUniqueOrThrowArgs>(args: SelectSubset<T, SorteioDancaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SorteioDancaClient<$Result.GetResult<Prisma.$SorteioDancaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SorteioDanca that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SorteioDancaFindFirstArgs} args - Arguments to find a SorteioDanca
     * @example
     * // Get one SorteioDanca
     * const sorteioDanca = await prisma.sorteioDanca.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SorteioDancaFindFirstArgs>(args?: SelectSubset<T, SorteioDancaFindFirstArgs<ExtArgs>>): Prisma__SorteioDancaClient<$Result.GetResult<Prisma.$SorteioDancaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SorteioDanca that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SorteioDancaFindFirstOrThrowArgs} args - Arguments to find a SorteioDanca
     * @example
     * // Get one SorteioDanca
     * const sorteioDanca = await prisma.sorteioDanca.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SorteioDancaFindFirstOrThrowArgs>(args?: SelectSubset<T, SorteioDancaFindFirstOrThrowArgs<ExtArgs>>): Prisma__SorteioDancaClient<$Result.GetResult<Prisma.$SorteioDancaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SorteioDancas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SorteioDancaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SorteioDancas
     * const sorteioDancas = await prisma.sorteioDanca.findMany()
     * 
     * // Get first 10 SorteioDancas
     * const sorteioDancas = await prisma.sorteioDanca.findMany({ take: 10 })
     * 
     * // Only select the `idSorteio`
     * const sorteioDancaWithIdSorteioOnly = await prisma.sorteioDanca.findMany({ select: { idSorteio: true } })
     * 
     */
    findMany<T extends SorteioDancaFindManyArgs>(args?: SelectSubset<T, SorteioDancaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SorteioDancaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SorteioDanca.
     * @param {SorteioDancaCreateArgs} args - Arguments to create a SorteioDanca.
     * @example
     * // Create one SorteioDanca
     * const SorteioDanca = await prisma.sorteioDanca.create({
     *   data: {
     *     // ... data to create a SorteioDanca
     *   }
     * })
     * 
     */
    create<T extends SorteioDancaCreateArgs>(args: SelectSubset<T, SorteioDancaCreateArgs<ExtArgs>>): Prisma__SorteioDancaClient<$Result.GetResult<Prisma.$SorteioDancaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SorteioDancas.
     * @param {SorteioDancaCreateManyArgs} args - Arguments to create many SorteioDancas.
     * @example
     * // Create many SorteioDancas
     * const sorteioDanca = await prisma.sorteioDanca.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SorteioDancaCreateManyArgs>(args?: SelectSubset<T, SorteioDancaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SorteioDancas and returns the data saved in the database.
     * @param {SorteioDancaCreateManyAndReturnArgs} args - Arguments to create many SorteioDancas.
     * @example
     * // Create many SorteioDancas
     * const sorteioDanca = await prisma.sorteioDanca.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SorteioDancas and only return the `idSorteio`
     * const sorteioDancaWithIdSorteioOnly = await prisma.sorteioDanca.createManyAndReturn({
     *   select: { idSorteio: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SorteioDancaCreateManyAndReturnArgs>(args?: SelectSubset<T, SorteioDancaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SorteioDancaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SorteioDanca.
     * @param {SorteioDancaDeleteArgs} args - Arguments to delete one SorteioDanca.
     * @example
     * // Delete one SorteioDanca
     * const SorteioDanca = await prisma.sorteioDanca.delete({
     *   where: {
     *     // ... filter to delete one SorteioDanca
     *   }
     * })
     * 
     */
    delete<T extends SorteioDancaDeleteArgs>(args: SelectSubset<T, SorteioDancaDeleteArgs<ExtArgs>>): Prisma__SorteioDancaClient<$Result.GetResult<Prisma.$SorteioDancaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SorteioDanca.
     * @param {SorteioDancaUpdateArgs} args - Arguments to update one SorteioDanca.
     * @example
     * // Update one SorteioDanca
     * const sorteioDanca = await prisma.sorteioDanca.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SorteioDancaUpdateArgs>(args: SelectSubset<T, SorteioDancaUpdateArgs<ExtArgs>>): Prisma__SorteioDancaClient<$Result.GetResult<Prisma.$SorteioDancaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SorteioDancas.
     * @param {SorteioDancaDeleteManyArgs} args - Arguments to filter SorteioDancas to delete.
     * @example
     * // Delete a few SorteioDancas
     * const { count } = await prisma.sorteioDanca.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SorteioDancaDeleteManyArgs>(args?: SelectSubset<T, SorteioDancaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SorteioDancas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SorteioDancaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SorteioDancas
     * const sorteioDanca = await prisma.sorteioDanca.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SorteioDancaUpdateManyArgs>(args: SelectSubset<T, SorteioDancaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SorteioDancas and returns the data updated in the database.
     * @param {SorteioDancaUpdateManyAndReturnArgs} args - Arguments to update many SorteioDancas.
     * @example
     * // Update many SorteioDancas
     * const sorteioDanca = await prisma.sorteioDanca.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SorteioDancas and only return the `idSorteio`
     * const sorteioDancaWithIdSorteioOnly = await prisma.sorteioDanca.updateManyAndReturn({
     *   select: { idSorteio: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SorteioDancaUpdateManyAndReturnArgs>(args: SelectSubset<T, SorteioDancaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SorteioDancaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SorteioDanca.
     * @param {SorteioDancaUpsertArgs} args - Arguments to update or create a SorteioDanca.
     * @example
     * // Update or create a SorteioDanca
     * const sorteioDanca = await prisma.sorteioDanca.upsert({
     *   create: {
     *     // ... data to create a SorteioDanca
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SorteioDanca we want to update
     *   }
     * })
     */
    upsert<T extends SorteioDancaUpsertArgs>(args: SelectSubset<T, SorteioDancaUpsertArgs<ExtArgs>>): Prisma__SorteioDancaClient<$Result.GetResult<Prisma.$SorteioDancaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SorteioDancas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SorteioDancaCountArgs} args - Arguments to filter SorteioDancas to count.
     * @example
     * // Count the number of SorteioDancas
     * const count = await prisma.sorteioDanca.count({
     *   where: {
     *     // ... the filter for the SorteioDancas we want to count
     *   }
     * })
    **/
    count<T extends SorteioDancaCountArgs>(
      args?: Subset<T, SorteioDancaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SorteioDancaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SorteioDanca.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SorteioDancaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SorteioDancaAggregateArgs>(args: Subset<T, SorteioDancaAggregateArgs>): Prisma.PrismaPromise<GetSorteioDancaAggregateType<T>>

    /**
     * Group by SorteioDanca.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SorteioDancaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SorteioDancaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SorteioDancaGroupByArgs['orderBy'] }
        : { orderBy?: SorteioDancaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SorteioDancaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSorteioDancaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SorteioDanca model
   */
  readonly fields: SorteioDancaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SorteioDanca.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SorteioDancaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    preferenciaSorteioDancaIds<T extends SorteioDanca$preferenciaSorteioDancaIdsArgs<ExtArgs> = {}>(args?: Subset<T, SorteioDanca$preferenciaSorteioDancaIdsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreferenciaSorteioDancaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Candidato<T extends CandidatoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CandidatoDefaultArgs<ExtArgs>>): Prisma__CandidatoClient<$Result.GetResult<Prisma.$CandidatoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SorteioDanca model
   */
  interface SorteioDancaFieldRefs {
    readonly idSorteio: FieldRef<"SorteioDanca", 'Int'>
    readonly resultadoSorteio: FieldRef<"SorteioDanca", 'Int'>
    readonly dataSorteio: FieldRef<"SorteioDanca", 'DateTime'>
    readonly tipoDanca: FieldRef<"SorteioDanca", 'DancaSalaoTradicional'>
    readonly candidatoId: FieldRef<"SorteioDanca", 'Int'>
    readonly usuarioId: FieldRef<"SorteioDanca", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SorteioDanca findUnique
   */
  export type SorteioDancaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SorteioDanca
     */
    select?: SorteioDancaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SorteioDanca
     */
    omit?: SorteioDancaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SorteioDancaInclude<ExtArgs> | null
    /**
     * Filter, which SorteioDanca to fetch.
     */
    where: SorteioDancaWhereUniqueInput
  }

  /**
   * SorteioDanca findUniqueOrThrow
   */
  export type SorteioDancaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SorteioDanca
     */
    select?: SorteioDancaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SorteioDanca
     */
    omit?: SorteioDancaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SorteioDancaInclude<ExtArgs> | null
    /**
     * Filter, which SorteioDanca to fetch.
     */
    where: SorteioDancaWhereUniqueInput
  }

  /**
   * SorteioDanca findFirst
   */
  export type SorteioDancaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SorteioDanca
     */
    select?: SorteioDancaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SorteioDanca
     */
    omit?: SorteioDancaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SorteioDancaInclude<ExtArgs> | null
    /**
     * Filter, which SorteioDanca to fetch.
     */
    where?: SorteioDancaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SorteioDancas to fetch.
     */
    orderBy?: SorteioDancaOrderByWithRelationInput | SorteioDancaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SorteioDancas.
     */
    cursor?: SorteioDancaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SorteioDancas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SorteioDancas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SorteioDancas.
     */
    distinct?: SorteioDancaScalarFieldEnum | SorteioDancaScalarFieldEnum[]
  }

  /**
   * SorteioDanca findFirstOrThrow
   */
  export type SorteioDancaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SorteioDanca
     */
    select?: SorteioDancaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SorteioDanca
     */
    omit?: SorteioDancaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SorteioDancaInclude<ExtArgs> | null
    /**
     * Filter, which SorteioDanca to fetch.
     */
    where?: SorteioDancaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SorteioDancas to fetch.
     */
    orderBy?: SorteioDancaOrderByWithRelationInput | SorteioDancaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SorteioDancas.
     */
    cursor?: SorteioDancaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SorteioDancas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SorteioDancas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SorteioDancas.
     */
    distinct?: SorteioDancaScalarFieldEnum | SorteioDancaScalarFieldEnum[]
  }

  /**
   * SorteioDanca findMany
   */
  export type SorteioDancaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SorteioDanca
     */
    select?: SorteioDancaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SorteioDanca
     */
    omit?: SorteioDancaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SorteioDancaInclude<ExtArgs> | null
    /**
     * Filter, which SorteioDancas to fetch.
     */
    where?: SorteioDancaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SorteioDancas to fetch.
     */
    orderBy?: SorteioDancaOrderByWithRelationInput | SorteioDancaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SorteioDancas.
     */
    cursor?: SorteioDancaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SorteioDancas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SorteioDancas.
     */
    skip?: number
    distinct?: SorteioDancaScalarFieldEnum | SorteioDancaScalarFieldEnum[]
  }

  /**
   * SorteioDanca create
   */
  export type SorteioDancaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SorteioDanca
     */
    select?: SorteioDancaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SorteioDanca
     */
    omit?: SorteioDancaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SorteioDancaInclude<ExtArgs> | null
    /**
     * The data needed to create a SorteioDanca.
     */
    data: XOR<SorteioDancaCreateInput, SorteioDancaUncheckedCreateInput>
  }

  /**
   * SorteioDanca createMany
   */
  export type SorteioDancaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SorteioDancas.
     */
    data: SorteioDancaCreateManyInput | SorteioDancaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SorteioDanca createManyAndReturn
   */
  export type SorteioDancaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SorteioDanca
     */
    select?: SorteioDancaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SorteioDanca
     */
    omit?: SorteioDancaOmit<ExtArgs> | null
    /**
     * The data used to create many SorteioDancas.
     */
    data: SorteioDancaCreateManyInput | SorteioDancaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SorteioDancaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SorteioDanca update
   */
  export type SorteioDancaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SorteioDanca
     */
    select?: SorteioDancaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SorteioDanca
     */
    omit?: SorteioDancaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SorteioDancaInclude<ExtArgs> | null
    /**
     * The data needed to update a SorteioDanca.
     */
    data: XOR<SorteioDancaUpdateInput, SorteioDancaUncheckedUpdateInput>
    /**
     * Choose, which SorteioDanca to update.
     */
    where: SorteioDancaWhereUniqueInput
  }

  /**
   * SorteioDanca updateMany
   */
  export type SorteioDancaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SorteioDancas.
     */
    data: XOR<SorteioDancaUpdateManyMutationInput, SorteioDancaUncheckedUpdateManyInput>
    /**
     * Filter which SorteioDancas to update
     */
    where?: SorteioDancaWhereInput
    /**
     * Limit how many SorteioDancas to update.
     */
    limit?: number
  }

  /**
   * SorteioDanca updateManyAndReturn
   */
  export type SorteioDancaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SorteioDanca
     */
    select?: SorteioDancaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SorteioDanca
     */
    omit?: SorteioDancaOmit<ExtArgs> | null
    /**
     * The data used to update SorteioDancas.
     */
    data: XOR<SorteioDancaUpdateManyMutationInput, SorteioDancaUncheckedUpdateManyInput>
    /**
     * Filter which SorteioDancas to update
     */
    where?: SorteioDancaWhereInput
    /**
     * Limit how many SorteioDancas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SorteioDancaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SorteioDanca upsert
   */
  export type SorteioDancaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SorteioDanca
     */
    select?: SorteioDancaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SorteioDanca
     */
    omit?: SorteioDancaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SorteioDancaInclude<ExtArgs> | null
    /**
     * The filter to search for the SorteioDanca to update in case it exists.
     */
    where: SorteioDancaWhereUniqueInput
    /**
     * In case the SorteioDanca found by the `where` argument doesn't exist, create a new SorteioDanca with this data.
     */
    create: XOR<SorteioDancaCreateInput, SorteioDancaUncheckedCreateInput>
    /**
     * In case the SorteioDanca was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SorteioDancaUpdateInput, SorteioDancaUncheckedUpdateInput>
  }

  /**
   * SorteioDanca delete
   */
  export type SorteioDancaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SorteioDanca
     */
    select?: SorteioDancaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SorteioDanca
     */
    omit?: SorteioDancaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SorteioDancaInclude<ExtArgs> | null
    /**
     * Filter which SorteioDanca to delete.
     */
    where: SorteioDancaWhereUniqueInput
  }

  /**
   * SorteioDanca deleteMany
   */
  export type SorteioDancaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SorteioDancas to delete
     */
    where?: SorteioDancaWhereInput
    /**
     * Limit how many SorteioDancas to delete.
     */
    limit?: number
  }

  /**
   * SorteioDanca.preferenciaSorteioDancaIds
   */
  export type SorteioDanca$preferenciaSorteioDancaIdsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreferenciaSorteioDanca
     */
    select?: PreferenciaSorteioDancaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PreferenciaSorteioDanca
     */
    omit?: PreferenciaSorteioDancaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreferenciaSorteioDancaInclude<ExtArgs> | null
    where?: PreferenciaSorteioDancaWhereInput
    orderBy?: PreferenciaSorteioDancaOrderByWithRelationInput | PreferenciaSorteioDancaOrderByWithRelationInput[]
    cursor?: PreferenciaSorteioDancaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PreferenciaSorteioDancaScalarFieldEnum | PreferenciaSorteioDancaScalarFieldEnum[]
  }

  /**
   * SorteioDanca without action
   */
  export type SorteioDancaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SorteioDanca
     */
    select?: SorteioDancaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SorteioDanca
     */
    omit?: SorteioDancaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SorteioDancaInclude<ExtArgs> | null
  }


  /**
   * Model FichaCandidato
   */

  export type AggregateFichaCandidato = {
    _count: FichaCandidatoCountAggregateOutputType | null
    _avg: FichaCandidatoAvgAggregateOutputType | null
    _sum: FichaCandidatoSumAggregateOutputType | null
    _min: FichaCandidatoMinAggregateOutputType | null
    _max: FichaCandidatoMaxAggregateOutputType | null
  }

  export type FichaCandidatoAvgAggregateOutputType = {
    idFicha: number | null
    candidatoId: number | null
    notaCandidato: number | null
    provaId: number | null
    concursoId: number | null
    categoriaId: number | null
    numAcertosProvaTeorica: number | null
    notaRedacao: number | null
  }

  export type FichaCandidatoSumAggregateOutputType = {
    idFicha: number | null
    candidatoId: number | null
    notaCandidato: number | null
    provaId: number | null
    concursoId: number | null
    categoriaId: number | null
    numAcertosProvaTeorica: number | null
    notaRedacao: number | null
  }

  export type FichaCandidatoMinAggregateOutputType = {
    idFicha: number | null
    candidatoId: number | null
    notaCandidato: number | null
    provaId: number | null
    concursoId: number | null
    categoriaId: number | null
    anexoTermodeCiencia: Bytes | null
    dataTermo: Date | null
    numAcertosProvaTeorica: number | null
    anexoGabarito: Bytes | null
    notaRedacao: number | null
    anexoRedacao: Bytes | null
    anexoProvaPratica: Bytes | null
  }

  export type FichaCandidatoMaxAggregateOutputType = {
    idFicha: number | null
    candidatoId: number | null
    notaCandidato: number | null
    provaId: number | null
    concursoId: number | null
    categoriaId: number | null
    anexoTermodeCiencia: Bytes | null
    dataTermo: Date | null
    numAcertosProvaTeorica: number | null
    anexoGabarito: Bytes | null
    notaRedacao: number | null
    anexoRedacao: Bytes | null
    anexoProvaPratica: Bytes | null
  }

  export type FichaCandidatoCountAggregateOutputType = {
    idFicha: number
    candidatoId: number
    notaCandidato: number
    provaId: number
    concursoId: number
    categoriaId: number
    anexoTermodeCiencia: number
    dataTermo: number
    numAcertosProvaTeorica: number
    anexoGabarito: number
    notaRedacao: number
    anexoRedacao: number
    anexoProvaPratica: number
    _all: number
  }


  export type FichaCandidatoAvgAggregateInputType = {
    idFicha?: true
    candidatoId?: true
    notaCandidato?: true
    provaId?: true
    concursoId?: true
    categoriaId?: true
    numAcertosProvaTeorica?: true
    notaRedacao?: true
  }

  export type FichaCandidatoSumAggregateInputType = {
    idFicha?: true
    candidatoId?: true
    notaCandidato?: true
    provaId?: true
    concursoId?: true
    categoriaId?: true
    numAcertosProvaTeorica?: true
    notaRedacao?: true
  }

  export type FichaCandidatoMinAggregateInputType = {
    idFicha?: true
    candidatoId?: true
    notaCandidato?: true
    provaId?: true
    concursoId?: true
    categoriaId?: true
    anexoTermodeCiencia?: true
    dataTermo?: true
    numAcertosProvaTeorica?: true
    anexoGabarito?: true
    notaRedacao?: true
    anexoRedacao?: true
    anexoProvaPratica?: true
  }

  export type FichaCandidatoMaxAggregateInputType = {
    idFicha?: true
    candidatoId?: true
    notaCandidato?: true
    provaId?: true
    concursoId?: true
    categoriaId?: true
    anexoTermodeCiencia?: true
    dataTermo?: true
    numAcertosProvaTeorica?: true
    anexoGabarito?: true
    notaRedacao?: true
    anexoRedacao?: true
    anexoProvaPratica?: true
  }

  export type FichaCandidatoCountAggregateInputType = {
    idFicha?: true
    candidatoId?: true
    notaCandidato?: true
    provaId?: true
    concursoId?: true
    categoriaId?: true
    anexoTermodeCiencia?: true
    dataTermo?: true
    numAcertosProvaTeorica?: true
    anexoGabarito?: true
    notaRedacao?: true
    anexoRedacao?: true
    anexoProvaPratica?: true
    _all?: true
  }

  export type FichaCandidatoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FichaCandidato to aggregate.
     */
    where?: FichaCandidatoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FichaCandidatoes to fetch.
     */
    orderBy?: FichaCandidatoOrderByWithRelationInput | FichaCandidatoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FichaCandidatoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FichaCandidatoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FichaCandidatoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FichaCandidatoes
    **/
    _count?: true | FichaCandidatoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FichaCandidatoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FichaCandidatoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FichaCandidatoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FichaCandidatoMaxAggregateInputType
  }

  export type GetFichaCandidatoAggregateType<T extends FichaCandidatoAggregateArgs> = {
        [P in keyof T & keyof AggregateFichaCandidato]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFichaCandidato[P]>
      : GetScalarType<T[P], AggregateFichaCandidato[P]>
  }




  export type FichaCandidatoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FichaCandidatoWhereInput
    orderBy?: FichaCandidatoOrderByWithAggregationInput | FichaCandidatoOrderByWithAggregationInput[]
    by: FichaCandidatoScalarFieldEnum[] | FichaCandidatoScalarFieldEnum
    having?: FichaCandidatoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FichaCandidatoCountAggregateInputType | true
    _avg?: FichaCandidatoAvgAggregateInputType
    _sum?: FichaCandidatoSumAggregateInputType
    _min?: FichaCandidatoMinAggregateInputType
    _max?: FichaCandidatoMaxAggregateInputType
  }

  export type FichaCandidatoGroupByOutputType = {
    idFicha: number
    candidatoId: number
    notaCandidato: number
    provaId: number
    concursoId: number
    categoriaId: number
    anexoTermodeCiencia: Bytes
    dataTermo: Date
    numAcertosProvaTeorica: number
    anexoGabarito: Bytes
    notaRedacao: number
    anexoRedacao: Bytes
    anexoProvaPratica: Bytes
    _count: FichaCandidatoCountAggregateOutputType | null
    _avg: FichaCandidatoAvgAggregateOutputType | null
    _sum: FichaCandidatoSumAggregateOutputType | null
    _min: FichaCandidatoMinAggregateOutputType | null
    _max: FichaCandidatoMaxAggregateOutputType | null
  }

  type GetFichaCandidatoGroupByPayload<T extends FichaCandidatoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FichaCandidatoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FichaCandidatoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FichaCandidatoGroupByOutputType[P]>
            : GetScalarType<T[P], FichaCandidatoGroupByOutputType[P]>
        }
      >
    >


  export type FichaCandidatoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idFicha?: boolean
    candidatoId?: boolean
    notaCandidato?: boolean
    provaId?: boolean
    concursoId?: boolean
    categoriaId?: boolean
    anexoTermodeCiencia?: boolean
    dataTermo?: boolean
    numAcertosProvaTeorica?: boolean
    anexoGabarito?: boolean
    notaRedacao?: boolean
    anexoRedacao?: boolean
    anexoProvaPratica?: boolean
    avaliacoes?: boolean | FichaCandidato$avaliacoesArgs<ExtArgs>
    _count?: boolean | FichaCandidatoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fichaCandidato"]>

  export type FichaCandidatoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idFicha?: boolean
    candidatoId?: boolean
    notaCandidato?: boolean
    provaId?: boolean
    concursoId?: boolean
    categoriaId?: boolean
    anexoTermodeCiencia?: boolean
    dataTermo?: boolean
    numAcertosProvaTeorica?: boolean
    anexoGabarito?: boolean
    notaRedacao?: boolean
    anexoRedacao?: boolean
    anexoProvaPratica?: boolean
  }, ExtArgs["result"]["fichaCandidato"]>

  export type FichaCandidatoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idFicha?: boolean
    candidatoId?: boolean
    notaCandidato?: boolean
    provaId?: boolean
    concursoId?: boolean
    categoriaId?: boolean
    anexoTermodeCiencia?: boolean
    dataTermo?: boolean
    numAcertosProvaTeorica?: boolean
    anexoGabarito?: boolean
    notaRedacao?: boolean
    anexoRedacao?: boolean
    anexoProvaPratica?: boolean
  }, ExtArgs["result"]["fichaCandidato"]>

  export type FichaCandidatoSelectScalar = {
    idFicha?: boolean
    candidatoId?: boolean
    notaCandidato?: boolean
    provaId?: boolean
    concursoId?: boolean
    categoriaId?: boolean
    anexoTermodeCiencia?: boolean
    dataTermo?: boolean
    numAcertosProvaTeorica?: boolean
    anexoGabarito?: boolean
    notaRedacao?: boolean
    anexoRedacao?: boolean
    anexoProvaPratica?: boolean
  }

  export type FichaCandidatoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idFicha" | "candidatoId" | "notaCandidato" | "provaId" | "concursoId" | "categoriaId" | "anexoTermodeCiencia" | "dataTermo" | "numAcertosProvaTeorica" | "anexoGabarito" | "notaRedacao" | "anexoRedacao" | "anexoProvaPratica", ExtArgs["result"]["fichaCandidato"]>
  export type FichaCandidatoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    avaliacoes?: boolean | FichaCandidato$avaliacoesArgs<ExtArgs>
    _count?: boolean | FichaCandidatoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FichaCandidatoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FichaCandidatoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FichaCandidatoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FichaCandidato"
    objects: {
      avaliacoes: Prisma.$AvaliacaoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idFicha: number
      candidatoId: number
      notaCandidato: number
      provaId: number
      concursoId: number
      categoriaId: number
      anexoTermodeCiencia: Prisma.Bytes
      dataTermo: Date
      numAcertosProvaTeorica: number
      anexoGabarito: Prisma.Bytes
      notaRedacao: number
      anexoRedacao: Prisma.Bytes
      anexoProvaPratica: Prisma.Bytes
    }, ExtArgs["result"]["fichaCandidato"]>
    composites: {}
  }

  type FichaCandidatoGetPayload<S extends boolean | null | undefined | FichaCandidatoDefaultArgs> = $Result.GetResult<Prisma.$FichaCandidatoPayload, S>

  type FichaCandidatoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FichaCandidatoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FichaCandidatoCountAggregateInputType | true
    }

  export interface FichaCandidatoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FichaCandidato'], meta: { name: 'FichaCandidato' } }
    /**
     * Find zero or one FichaCandidato that matches the filter.
     * @param {FichaCandidatoFindUniqueArgs} args - Arguments to find a FichaCandidato
     * @example
     * // Get one FichaCandidato
     * const fichaCandidato = await prisma.fichaCandidato.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FichaCandidatoFindUniqueArgs>(args: SelectSubset<T, FichaCandidatoFindUniqueArgs<ExtArgs>>): Prisma__FichaCandidatoClient<$Result.GetResult<Prisma.$FichaCandidatoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FichaCandidato that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FichaCandidatoFindUniqueOrThrowArgs} args - Arguments to find a FichaCandidato
     * @example
     * // Get one FichaCandidato
     * const fichaCandidato = await prisma.fichaCandidato.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FichaCandidatoFindUniqueOrThrowArgs>(args: SelectSubset<T, FichaCandidatoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FichaCandidatoClient<$Result.GetResult<Prisma.$FichaCandidatoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FichaCandidato that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FichaCandidatoFindFirstArgs} args - Arguments to find a FichaCandidato
     * @example
     * // Get one FichaCandidato
     * const fichaCandidato = await prisma.fichaCandidato.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FichaCandidatoFindFirstArgs>(args?: SelectSubset<T, FichaCandidatoFindFirstArgs<ExtArgs>>): Prisma__FichaCandidatoClient<$Result.GetResult<Prisma.$FichaCandidatoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FichaCandidato that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FichaCandidatoFindFirstOrThrowArgs} args - Arguments to find a FichaCandidato
     * @example
     * // Get one FichaCandidato
     * const fichaCandidato = await prisma.fichaCandidato.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FichaCandidatoFindFirstOrThrowArgs>(args?: SelectSubset<T, FichaCandidatoFindFirstOrThrowArgs<ExtArgs>>): Prisma__FichaCandidatoClient<$Result.GetResult<Prisma.$FichaCandidatoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FichaCandidatoes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FichaCandidatoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FichaCandidatoes
     * const fichaCandidatoes = await prisma.fichaCandidato.findMany()
     * 
     * // Get first 10 FichaCandidatoes
     * const fichaCandidatoes = await prisma.fichaCandidato.findMany({ take: 10 })
     * 
     * // Only select the `idFicha`
     * const fichaCandidatoWithIdFichaOnly = await prisma.fichaCandidato.findMany({ select: { idFicha: true } })
     * 
     */
    findMany<T extends FichaCandidatoFindManyArgs>(args?: SelectSubset<T, FichaCandidatoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FichaCandidatoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FichaCandidato.
     * @param {FichaCandidatoCreateArgs} args - Arguments to create a FichaCandidato.
     * @example
     * // Create one FichaCandidato
     * const FichaCandidato = await prisma.fichaCandidato.create({
     *   data: {
     *     // ... data to create a FichaCandidato
     *   }
     * })
     * 
     */
    create<T extends FichaCandidatoCreateArgs>(args: SelectSubset<T, FichaCandidatoCreateArgs<ExtArgs>>): Prisma__FichaCandidatoClient<$Result.GetResult<Prisma.$FichaCandidatoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FichaCandidatoes.
     * @param {FichaCandidatoCreateManyArgs} args - Arguments to create many FichaCandidatoes.
     * @example
     * // Create many FichaCandidatoes
     * const fichaCandidato = await prisma.fichaCandidato.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FichaCandidatoCreateManyArgs>(args?: SelectSubset<T, FichaCandidatoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FichaCandidatoes and returns the data saved in the database.
     * @param {FichaCandidatoCreateManyAndReturnArgs} args - Arguments to create many FichaCandidatoes.
     * @example
     * // Create many FichaCandidatoes
     * const fichaCandidato = await prisma.fichaCandidato.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FichaCandidatoes and only return the `idFicha`
     * const fichaCandidatoWithIdFichaOnly = await prisma.fichaCandidato.createManyAndReturn({
     *   select: { idFicha: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FichaCandidatoCreateManyAndReturnArgs>(args?: SelectSubset<T, FichaCandidatoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FichaCandidatoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FichaCandidato.
     * @param {FichaCandidatoDeleteArgs} args - Arguments to delete one FichaCandidato.
     * @example
     * // Delete one FichaCandidato
     * const FichaCandidato = await prisma.fichaCandidato.delete({
     *   where: {
     *     // ... filter to delete one FichaCandidato
     *   }
     * })
     * 
     */
    delete<T extends FichaCandidatoDeleteArgs>(args: SelectSubset<T, FichaCandidatoDeleteArgs<ExtArgs>>): Prisma__FichaCandidatoClient<$Result.GetResult<Prisma.$FichaCandidatoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FichaCandidato.
     * @param {FichaCandidatoUpdateArgs} args - Arguments to update one FichaCandidato.
     * @example
     * // Update one FichaCandidato
     * const fichaCandidato = await prisma.fichaCandidato.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FichaCandidatoUpdateArgs>(args: SelectSubset<T, FichaCandidatoUpdateArgs<ExtArgs>>): Prisma__FichaCandidatoClient<$Result.GetResult<Prisma.$FichaCandidatoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FichaCandidatoes.
     * @param {FichaCandidatoDeleteManyArgs} args - Arguments to filter FichaCandidatoes to delete.
     * @example
     * // Delete a few FichaCandidatoes
     * const { count } = await prisma.fichaCandidato.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FichaCandidatoDeleteManyArgs>(args?: SelectSubset<T, FichaCandidatoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FichaCandidatoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FichaCandidatoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FichaCandidatoes
     * const fichaCandidato = await prisma.fichaCandidato.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FichaCandidatoUpdateManyArgs>(args: SelectSubset<T, FichaCandidatoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FichaCandidatoes and returns the data updated in the database.
     * @param {FichaCandidatoUpdateManyAndReturnArgs} args - Arguments to update many FichaCandidatoes.
     * @example
     * // Update many FichaCandidatoes
     * const fichaCandidato = await prisma.fichaCandidato.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FichaCandidatoes and only return the `idFicha`
     * const fichaCandidatoWithIdFichaOnly = await prisma.fichaCandidato.updateManyAndReturn({
     *   select: { idFicha: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FichaCandidatoUpdateManyAndReturnArgs>(args: SelectSubset<T, FichaCandidatoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FichaCandidatoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FichaCandidato.
     * @param {FichaCandidatoUpsertArgs} args - Arguments to update or create a FichaCandidato.
     * @example
     * // Update or create a FichaCandidato
     * const fichaCandidato = await prisma.fichaCandidato.upsert({
     *   create: {
     *     // ... data to create a FichaCandidato
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FichaCandidato we want to update
     *   }
     * })
     */
    upsert<T extends FichaCandidatoUpsertArgs>(args: SelectSubset<T, FichaCandidatoUpsertArgs<ExtArgs>>): Prisma__FichaCandidatoClient<$Result.GetResult<Prisma.$FichaCandidatoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FichaCandidatoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FichaCandidatoCountArgs} args - Arguments to filter FichaCandidatoes to count.
     * @example
     * // Count the number of FichaCandidatoes
     * const count = await prisma.fichaCandidato.count({
     *   where: {
     *     // ... the filter for the FichaCandidatoes we want to count
     *   }
     * })
    **/
    count<T extends FichaCandidatoCountArgs>(
      args?: Subset<T, FichaCandidatoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FichaCandidatoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FichaCandidato.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FichaCandidatoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FichaCandidatoAggregateArgs>(args: Subset<T, FichaCandidatoAggregateArgs>): Prisma.PrismaPromise<GetFichaCandidatoAggregateType<T>>

    /**
     * Group by FichaCandidato.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FichaCandidatoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FichaCandidatoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FichaCandidatoGroupByArgs['orderBy'] }
        : { orderBy?: FichaCandidatoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FichaCandidatoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFichaCandidatoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FichaCandidato model
   */
  readonly fields: FichaCandidatoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FichaCandidato.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FichaCandidatoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    avaliacoes<T extends FichaCandidato$avaliacoesArgs<ExtArgs> = {}>(args?: Subset<T, FichaCandidato$avaliacoesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FichaCandidato model
   */
  interface FichaCandidatoFieldRefs {
    readonly idFicha: FieldRef<"FichaCandidato", 'Int'>
    readonly candidatoId: FieldRef<"FichaCandidato", 'Int'>
    readonly notaCandidato: FieldRef<"FichaCandidato", 'Float'>
    readonly provaId: FieldRef<"FichaCandidato", 'Int'>
    readonly concursoId: FieldRef<"FichaCandidato", 'Int'>
    readonly categoriaId: FieldRef<"FichaCandidato", 'Int'>
    readonly anexoTermodeCiencia: FieldRef<"FichaCandidato", 'Bytes'>
    readonly dataTermo: FieldRef<"FichaCandidato", 'DateTime'>
    readonly numAcertosProvaTeorica: FieldRef<"FichaCandidato", 'Int'>
    readonly anexoGabarito: FieldRef<"FichaCandidato", 'Bytes'>
    readonly notaRedacao: FieldRef<"FichaCandidato", 'Float'>
    readonly anexoRedacao: FieldRef<"FichaCandidato", 'Bytes'>
    readonly anexoProvaPratica: FieldRef<"FichaCandidato", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * FichaCandidato findUnique
   */
  export type FichaCandidatoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FichaCandidato
     */
    select?: FichaCandidatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FichaCandidato
     */
    omit?: FichaCandidatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FichaCandidatoInclude<ExtArgs> | null
    /**
     * Filter, which FichaCandidato to fetch.
     */
    where: FichaCandidatoWhereUniqueInput
  }

  /**
   * FichaCandidato findUniqueOrThrow
   */
  export type FichaCandidatoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FichaCandidato
     */
    select?: FichaCandidatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FichaCandidato
     */
    omit?: FichaCandidatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FichaCandidatoInclude<ExtArgs> | null
    /**
     * Filter, which FichaCandidato to fetch.
     */
    where: FichaCandidatoWhereUniqueInput
  }

  /**
   * FichaCandidato findFirst
   */
  export type FichaCandidatoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FichaCandidato
     */
    select?: FichaCandidatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FichaCandidato
     */
    omit?: FichaCandidatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FichaCandidatoInclude<ExtArgs> | null
    /**
     * Filter, which FichaCandidato to fetch.
     */
    where?: FichaCandidatoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FichaCandidatoes to fetch.
     */
    orderBy?: FichaCandidatoOrderByWithRelationInput | FichaCandidatoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FichaCandidatoes.
     */
    cursor?: FichaCandidatoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FichaCandidatoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FichaCandidatoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FichaCandidatoes.
     */
    distinct?: FichaCandidatoScalarFieldEnum | FichaCandidatoScalarFieldEnum[]
  }

  /**
   * FichaCandidato findFirstOrThrow
   */
  export type FichaCandidatoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FichaCandidato
     */
    select?: FichaCandidatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FichaCandidato
     */
    omit?: FichaCandidatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FichaCandidatoInclude<ExtArgs> | null
    /**
     * Filter, which FichaCandidato to fetch.
     */
    where?: FichaCandidatoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FichaCandidatoes to fetch.
     */
    orderBy?: FichaCandidatoOrderByWithRelationInput | FichaCandidatoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FichaCandidatoes.
     */
    cursor?: FichaCandidatoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FichaCandidatoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FichaCandidatoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FichaCandidatoes.
     */
    distinct?: FichaCandidatoScalarFieldEnum | FichaCandidatoScalarFieldEnum[]
  }

  /**
   * FichaCandidato findMany
   */
  export type FichaCandidatoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FichaCandidato
     */
    select?: FichaCandidatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FichaCandidato
     */
    omit?: FichaCandidatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FichaCandidatoInclude<ExtArgs> | null
    /**
     * Filter, which FichaCandidatoes to fetch.
     */
    where?: FichaCandidatoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FichaCandidatoes to fetch.
     */
    orderBy?: FichaCandidatoOrderByWithRelationInput | FichaCandidatoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FichaCandidatoes.
     */
    cursor?: FichaCandidatoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FichaCandidatoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FichaCandidatoes.
     */
    skip?: number
    distinct?: FichaCandidatoScalarFieldEnum | FichaCandidatoScalarFieldEnum[]
  }

  /**
   * FichaCandidato create
   */
  export type FichaCandidatoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FichaCandidato
     */
    select?: FichaCandidatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FichaCandidato
     */
    omit?: FichaCandidatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FichaCandidatoInclude<ExtArgs> | null
    /**
     * The data needed to create a FichaCandidato.
     */
    data: XOR<FichaCandidatoCreateInput, FichaCandidatoUncheckedCreateInput>
  }

  /**
   * FichaCandidato createMany
   */
  export type FichaCandidatoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FichaCandidatoes.
     */
    data: FichaCandidatoCreateManyInput | FichaCandidatoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FichaCandidato createManyAndReturn
   */
  export type FichaCandidatoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FichaCandidato
     */
    select?: FichaCandidatoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FichaCandidato
     */
    omit?: FichaCandidatoOmit<ExtArgs> | null
    /**
     * The data used to create many FichaCandidatoes.
     */
    data: FichaCandidatoCreateManyInput | FichaCandidatoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FichaCandidato update
   */
  export type FichaCandidatoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FichaCandidato
     */
    select?: FichaCandidatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FichaCandidato
     */
    omit?: FichaCandidatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FichaCandidatoInclude<ExtArgs> | null
    /**
     * The data needed to update a FichaCandidato.
     */
    data: XOR<FichaCandidatoUpdateInput, FichaCandidatoUncheckedUpdateInput>
    /**
     * Choose, which FichaCandidato to update.
     */
    where: FichaCandidatoWhereUniqueInput
  }

  /**
   * FichaCandidato updateMany
   */
  export type FichaCandidatoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FichaCandidatoes.
     */
    data: XOR<FichaCandidatoUpdateManyMutationInput, FichaCandidatoUncheckedUpdateManyInput>
    /**
     * Filter which FichaCandidatoes to update
     */
    where?: FichaCandidatoWhereInput
    /**
     * Limit how many FichaCandidatoes to update.
     */
    limit?: number
  }

  /**
   * FichaCandidato updateManyAndReturn
   */
  export type FichaCandidatoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FichaCandidato
     */
    select?: FichaCandidatoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FichaCandidato
     */
    omit?: FichaCandidatoOmit<ExtArgs> | null
    /**
     * The data used to update FichaCandidatoes.
     */
    data: XOR<FichaCandidatoUpdateManyMutationInput, FichaCandidatoUncheckedUpdateManyInput>
    /**
     * Filter which FichaCandidatoes to update
     */
    where?: FichaCandidatoWhereInput
    /**
     * Limit how many FichaCandidatoes to update.
     */
    limit?: number
  }

  /**
   * FichaCandidato upsert
   */
  export type FichaCandidatoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FichaCandidato
     */
    select?: FichaCandidatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FichaCandidato
     */
    omit?: FichaCandidatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FichaCandidatoInclude<ExtArgs> | null
    /**
     * The filter to search for the FichaCandidato to update in case it exists.
     */
    where: FichaCandidatoWhereUniqueInput
    /**
     * In case the FichaCandidato found by the `where` argument doesn't exist, create a new FichaCandidato with this data.
     */
    create: XOR<FichaCandidatoCreateInput, FichaCandidatoUncheckedCreateInput>
    /**
     * In case the FichaCandidato was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FichaCandidatoUpdateInput, FichaCandidatoUncheckedUpdateInput>
  }

  /**
   * FichaCandidato delete
   */
  export type FichaCandidatoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FichaCandidato
     */
    select?: FichaCandidatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FichaCandidato
     */
    omit?: FichaCandidatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FichaCandidatoInclude<ExtArgs> | null
    /**
     * Filter which FichaCandidato to delete.
     */
    where: FichaCandidatoWhereUniqueInput
  }

  /**
   * FichaCandidato deleteMany
   */
  export type FichaCandidatoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FichaCandidatoes to delete
     */
    where?: FichaCandidatoWhereInput
    /**
     * Limit how many FichaCandidatoes to delete.
     */
    limit?: number
  }

  /**
   * FichaCandidato.avaliacoes
   */
  export type FichaCandidato$avaliacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Avaliacao
     */
    omit?: AvaliacaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    where?: AvaliacaoWhereInput
    orderBy?: AvaliacaoOrderByWithRelationInput | AvaliacaoOrderByWithRelationInput[]
    cursor?: AvaliacaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AvaliacaoScalarFieldEnum | AvaliacaoScalarFieldEnum[]
  }

  /**
   * FichaCandidato without action
   */
  export type FichaCandidatoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FichaCandidato
     */
    select?: FichaCandidatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FichaCandidato
     */
    omit?: FichaCandidatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FichaCandidatoInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CandidatoScalarFieldEnum: {
    idCandidato: 'idCandidato',
    nomeCompleto: 'nomeCompleto',
    cidade: 'cidade',
    estado: 'estado',
    CTGId: 'CTGId',
    numCarteirinha: 'numCarteirinha',
    CPF: 'CPF',
    RG: 'RG',
    endereco: 'endereco',
    numEndereco: 'numEndereco',
    bairro: 'bairro',
    escolaridade: 'escolaridade',
    filiacao: 'filiacao',
    ProvaCampeiraEsportiva: 'ProvaCampeiraEsportiva',
    anexoDocumento: 'anexoDocumento',
    anexoCarteirinha: 'anexoCarteirinha',
    anexoEscolaridade: 'anexoEscolaridade',
    anexoResidencia: 'anexoResidencia',
    anexoAtaConcurso: 'anexoAtaConcurso',
    fichaInscricao: 'fichaInscricao',
    anexoTermoCandidato: 'anexoTermoCandidato',
    anexoRelatorioVivencia: 'anexoRelatorioVivencia',
    anexoResponsavel: 'anexoResponsavel',
    anexoProvaEsportivaCampeira: 'anexoProvaEsportivaCampeira',
    categoriaId: 'categoriaId',
    concursoIdConcurso: 'concursoIdConcurso'
  };

  export type CandidatoScalarFieldEnum = (typeof CandidatoScalarFieldEnum)[keyof typeof CandidatoScalarFieldEnum]


  export const UsuarioScalarFieldEnum: {
    idUsuario: 'idUsuario',
    nomeCompleto: 'nomeCompleto',
    cidade: 'cidade',
    estado: 'estado',
    CTGId: 'CTGId',
    numCarteirinha: 'numCarteirinha',
    login: 'login',
    senha: 'senha',
    funcao: 'funcao',
    credenciamento: 'credenciamento',
    numCredenciamento: 'numCredenciamento',
    comissaoUsuarioId: 'comissaoUsuarioId'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const CTGScalarFieldEnum: {
    idCTG: 'idCTG',
    nomeCTG: 'nomeCTG',
    RTid: 'RTid'
  };

  export type CTGScalarFieldEnum = (typeof CTGScalarFieldEnum)[keyof typeof CTGScalarFieldEnum]


  export const RTScalarFieldEnum: {
    idRT: 'idRT',
    nomeRT: 'nomeRT',
    numeroRT: 'numeroRT'
  };

  export type RTScalarFieldEnum = (typeof RTScalarFieldEnum)[keyof typeof RTScalarFieldEnum]


  export const PreferenciaSorteioDancaScalarFieldEnum: {
    idPreferencia: 'idPreferencia',
    nomeSorteioDanca: 'nomeSorteioDanca',
    candidatoId: 'candidatoId',
    sorteioDancaId: 'sorteioDancaId'
  };

  export type PreferenciaSorteioDancaScalarFieldEnum = (typeof PreferenciaSorteioDancaScalarFieldEnum)[keyof typeof PreferenciaSorteioDancaScalarFieldEnum]


  export const ConcursoScalarFieldEnum: {
    idConcurso: 'idConcurso',
    nomeConcurso: 'nomeConcurso',
    lancamentoEdital: 'lancamentoEdital',
    inscricoesInicio: 'inscricoesInicio',
    inscricoesFinal: 'inscricoesFinal',
    dataProvaEscrita: 'dataProvaEscrita',
    dataProvasPraticas: 'dataProvasPraticas',
    dataResultado: 'dataResultado',
    local: 'local',
    anexoEdital: 'anexoEdital'
  };

  export type ConcursoScalarFieldEnum = (typeof ConcursoScalarFieldEnum)[keyof typeof ConcursoScalarFieldEnum]


  export const ComissaoScalarFieldEnum: {
    idComissao: 'idComissao',
    nomeComissao: 'nomeComissao',
    concursoId: 'concursoId'
  };

  export type ComissaoScalarFieldEnum = (typeof ComissaoScalarFieldEnum)[keyof typeof ComissaoScalarFieldEnum]


  export const ComissaoUsuarioScalarFieldEnum: {
    idComissaoUsuario: 'idComissaoUsuario',
    comissaoId: 'comissaoId',
    usuarioId: 'usuarioId'
  };

  export type ComissaoUsuarioScalarFieldEnum = (typeof ComissaoUsuarioScalarFieldEnum)[keyof typeof ComissaoUsuarioScalarFieldEnum]


  export const CategoriaScalarFieldEnum: {
    idCategoria: 'idCategoria',
    nomeCategoria: 'nomeCategoria',
    escolaridade: 'escolaridade',
    sorteioDanca: 'sorteioDanca',
    idadeInicial: 'idadeInicial',
    idadeLimite: 'idadeLimite',
    provaId: 'provaId',
    provaTeoricaId: 'provaTeoricaId',
    provaPraticaId: 'provaPraticaId'
  };

  export type CategoriaScalarFieldEnum = (typeof CategoriaScalarFieldEnum)[keyof typeof CategoriaScalarFieldEnum]


  export const AvaliacaoScalarFieldEnum: {
    idAvalicao: 'idAvalicao',
    dataAvaliacao: 'dataAvaliacao',
    comissaoId: 'comissaoId',
    avaliadorId: 'avaliadorId',
    provaId: 'provaId',
    blocoProvaId: 'blocoProvaId',
    nota: 'nota',
    candidatoId: 'candidatoId',
    fichaCandidatoIdFicha: 'fichaCandidatoIdFicha'
  };

  export type AvaliacaoScalarFieldEnum = (typeof AvaliacaoScalarFieldEnum)[keyof typeof AvaliacaoScalarFieldEnum]


  export const ProvaScalarFieldEnum: {
    idProva: 'idProva',
    nomeProva: 'nomeProva',
    notaMaxima: 'notaMaxima'
  };

  export type ProvaScalarFieldEnum = (typeof ProvaScalarFieldEnum)[keyof typeof ProvaScalarFieldEnum]


  export const ProvaTeoricaScalarFieldEnum: {
    idprovaTeorica: 'idprovaTeorica',
    provaId: 'provaId',
    gabaritoOficinal: 'gabaritoOficinal',
    numQuestao: 'numQuestao'
  };

  export type ProvaTeoricaScalarFieldEnum = (typeof ProvaTeoricaScalarFieldEnum)[keyof typeof ProvaTeoricaScalarFieldEnum]


  export const ProvaPraticaScalarFieldEnum: {
    idProvaPratica: 'idProvaPratica',
    provaId: 'provaId'
  };

  export type ProvaPraticaScalarFieldEnum = (typeof ProvaPraticaScalarFieldEnum)[keyof typeof ProvaPraticaScalarFieldEnum]


  export const BlocoProvaScalarFieldEnum: {
    idBloco: 'idBloco',
    nomeBloco: 'nomeBloco',
    notaMaximaBloco: 'notaMaximaBloco',
    provaPraticaId: 'provaPraticaId'
  };

  export type BlocoProvaScalarFieldEnum = (typeof BlocoProvaScalarFieldEnum)[keyof typeof BlocoProvaScalarFieldEnum]


  export const QuesitosScalarFieldEnum: {
    idQuesito: 'idQuesito',
    nomeQuesito: 'nomeQuesito',
    notaMaximaQuesito: 'notaMaximaQuesito',
    danca: 'danca',
    dancaSalaoTradicional: 'dancaSalaoTradicional',
    blocoProvaIdBloco: 'blocoProvaIdBloco',
    provaTeoricaIdprovaTeorica: 'provaTeoricaIdprovaTeorica',
    preferenciaSorteioDancaId: 'preferenciaSorteioDancaId',
    avaliacaoIdAvalicao: 'avaliacaoIdAvalicao'
  };

  export type QuesitosScalarFieldEnum = (typeof QuesitosScalarFieldEnum)[keyof typeof QuesitosScalarFieldEnum]


  export const SubQuesitosScalarFieldEnum: {
    idSubequestios: 'idSubequestios',
    nomeSubquesito: 'nomeSubquesito',
    notaSubequesito: 'notaSubequesito',
    quesitoId: 'quesitoId'
  };

  export type SubQuesitosScalarFieldEnum = (typeof SubQuesitosScalarFieldEnum)[keyof typeof SubQuesitosScalarFieldEnum]


  export const RecursoScalarFieldEnum: {
    idRecurso: 'idRecurso',
    nomeRecurso: 'nomeRecurso',
    justificativa: 'justificativa',
    status: 'status',
    dataRecurso: 'dataRecurso',
    arquivos: 'arquivos',
    candidato: 'candidato',
    avaliador: 'avaliador',
    quesitoRecurso: 'quesitoRecurso',
    provaTeoricaIdprovaTeorica: 'provaTeoricaIdprovaTeorica',
    provaPraticaIdProvaPratica: 'provaPraticaIdProvaPratica',
    provaIdProva: 'provaIdProva'
  };

  export type RecursoScalarFieldEnum = (typeof RecursoScalarFieldEnum)[keyof typeof RecursoScalarFieldEnum]


  export const SorteioDancaScalarFieldEnum: {
    idSorteio: 'idSorteio',
    resultadoSorteio: 'resultadoSorteio',
    dataSorteio: 'dataSorteio',
    tipoDanca: 'tipoDanca',
    candidatoId: 'candidatoId',
    usuarioId: 'usuarioId'
  };

  export type SorteioDancaScalarFieldEnum = (typeof SorteioDancaScalarFieldEnum)[keyof typeof SorteioDancaScalarFieldEnum]


  export const FichaCandidatoScalarFieldEnum: {
    idFicha: 'idFicha',
    candidatoId: 'candidatoId',
    notaCandidato: 'notaCandidato',
    provaId: 'provaId',
    concursoId: 'concursoId',
    categoriaId: 'categoriaId',
    anexoTermodeCiencia: 'anexoTermodeCiencia',
    dataTermo: 'dataTermo',
    numAcertosProvaTeorica: 'numAcertosProvaTeorica',
    anexoGabarito: 'anexoGabarito',
    notaRedacao: 'notaRedacao',
    anexoRedacao: 'anexoRedacao',
    anexoProvaPratica: 'anexoProvaPratica'
  };

  export type FichaCandidatoScalarFieldEnum = (typeof FichaCandidatoScalarFieldEnum)[keyof typeof FichaCandidatoScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'ProvaCampeiraEsportiva'
   */
  export type EnumProvaCampeiraEsportivaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProvaCampeiraEsportiva'>
    


  /**
   * Reference to a field of type 'ProvaCampeiraEsportiva[]'
   */
  export type ListEnumProvaCampeiraEsportivaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProvaCampeiraEsportiva[]'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Bytes[]'
   */
  export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes[]'>
    


  /**
   * Reference to a field of type 'Funcao'
   */
  export type EnumFuncaoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Funcao'>
    


  /**
   * Reference to a field of type 'Funcao[]'
   */
  export type ListEnumFuncaoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Funcao[]'>
    


  /**
   * Reference to a field of type 'Credenciamento'
   */
  export type EnumCredenciamentoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Credenciamento'>
    


  /**
   * Reference to a field of type 'Credenciamento[]'
   */
  export type ListEnumCredenciamentoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Credenciamento[]'>
    


  /**
   * Reference to a field of type 'DancaSalaoTradicional'
   */
  export type EnumDancaSalaoTradicionalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DancaSalaoTradicional'>
    


  /**
   * Reference to a field of type 'DancaSalaoTradicional[]'
   */
  export type ListEnumDancaSalaoTradicionalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DancaSalaoTradicional[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type CandidatoWhereInput = {
    AND?: CandidatoWhereInput | CandidatoWhereInput[]
    OR?: CandidatoWhereInput[]
    NOT?: CandidatoWhereInput | CandidatoWhereInput[]
    idCandidato?: IntFilter<"Candidato"> | number
    nomeCompleto?: StringFilter<"Candidato"> | string
    cidade?: StringFilter<"Candidato"> | string
    estado?: StringFilter<"Candidato"> | string
    CTGId?: IntFilter<"Candidato"> | number
    numCarteirinha?: StringFilter<"Candidato"> | string
    CPF?: StringFilter<"Candidato"> | string
    RG?: StringFilter<"Candidato"> | string
    endereco?: StringFilter<"Candidato"> | string
    numEndereco?: IntFilter<"Candidato"> | number
    bairro?: StringFilter<"Candidato"> | string
    escolaridade?: StringFilter<"Candidato"> | string
    filiacao?: StringFilter<"Candidato"> | string
    ProvaCampeiraEsportiva?: EnumProvaCampeiraEsportivaNullableFilter<"Candidato"> | $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: BytesNullableFilter<"Candidato"> | Bytes | null
    anexoCarteirinha?: BytesNullableFilter<"Candidato"> | Bytes | null
    anexoEscolaridade?: BytesNullableFilter<"Candidato"> | Bytes | null
    anexoResidencia?: BytesNullableFilter<"Candidato"> | Bytes | null
    anexoAtaConcurso?: BytesNullableFilter<"Candidato"> | Bytes | null
    fichaInscricao?: BytesNullableFilter<"Candidato"> | Bytes | null
    anexoTermoCandidato?: BytesNullableFilter<"Candidato"> | Bytes | null
    anexoRelatorioVivencia?: BytesNullableFilter<"Candidato"> | Bytes | null
    anexoResponsavel?: BytesNullableFilter<"Candidato"> | Bytes | null
    anexoProvaEsportivaCampeira?: BytesNullableFilter<"Candidato"> | Bytes | null
    categoriaId?: IntFilter<"Candidato"> | number
    concursoIdConcurso?: IntNullableFilter<"Candidato"> | number | null
    CTG?: XOR<CTGScalarRelationFilter, CTGWhereInput>
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaListRelationFilter
    Categoria?: XOR<CategoriaScalarRelationFilter, CategoriaWhereInput>
    avalicoes?: AvaliacaoListRelationFilter
    sorteioDanca?: SorteioDancaListRelationFilter
    Recurso?: RecursoListRelationFilter
    Concurso?: XOR<ConcursoNullableScalarRelationFilter, ConcursoWhereInput> | null
  }

  export type CandidatoOrderByWithRelationInput = {
    idCandidato?: SortOrder
    nomeCompleto?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
    CTGId?: SortOrder
    numCarteirinha?: SortOrder
    CPF?: SortOrder
    RG?: SortOrder
    endereco?: SortOrder
    numEndereco?: SortOrder
    bairro?: SortOrder
    escolaridade?: SortOrder
    filiacao?: SortOrder
    ProvaCampeiraEsportiva?: SortOrderInput | SortOrder
    anexoDocumento?: SortOrderInput | SortOrder
    anexoCarteirinha?: SortOrderInput | SortOrder
    anexoEscolaridade?: SortOrderInput | SortOrder
    anexoResidencia?: SortOrderInput | SortOrder
    anexoAtaConcurso?: SortOrderInput | SortOrder
    fichaInscricao?: SortOrderInput | SortOrder
    anexoTermoCandidato?: SortOrderInput | SortOrder
    anexoRelatorioVivencia?: SortOrderInput | SortOrder
    anexoResponsavel?: SortOrderInput | SortOrder
    anexoProvaEsportivaCampeira?: SortOrderInput | SortOrder
    categoriaId?: SortOrder
    concursoIdConcurso?: SortOrderInput | SortOrder
    CTG?: CTGOrderByWithRelationInput
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaOrderByRelationAggregateInput
    Categoria?: CategoriaOrderByWithRelationInput
    avalicoes?: AvaliacaoOrderByRelationAggregateInput
    sorteioDanca?: SorteioDancaOrderByRelationAggregateInput
    Recurso?: RecursoOrderByRelationAggregateInput
    Concurso?: ConcursoOrderByWithRelationInput
  }

  export type CandidatoWhereUniqueInput = Prisma.AtLeast<{
    idCandidato?: number
    AND?: CandidatoWhereInput | CandidatoWhereInput[]
    OR?: CandidatoWhereInput[]
    NOT?: CandidatoWhereInput | CandidatoWhereInput[]
    nomeCompleto?: StringFilter<"Candidato"> | string
    cidade?: StringFilter<"Candidato"> | string
    estado?: StringFilter<"Candidato"> | string
    CTGId?: IntFilter<"Candidato"> | number
    numCarteirinha?: StringFilter<"Candidato"> | string
    CPF?: StringFilter<"Candidato"> | string
    RG?: StringFilter<"Candidato"> | string
    endereco?: StringFilter<"Candidato"> | string
    numEndereco?: IntFilter<"Candidato"> | number
    bairro?: StringFilter<"Candidato"> | string
    escolaridade?: StringFilter<"Candidato"> | string
    filiacao?: StringFilter<"Candidato"> | string
    ProvaCampeiraEsportiva?: EnumProvaCampeiraEsportivaNullableFilter<"Candidato"> | $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: BytesNullableFilter<"Candidato"> | Bytes | null
    anexoCarteirinha?: BytesNullableFilter<"Candidato"> | Bytes | null
    anexoEscolaridade?: BytesNullableFilter<"Candidato"> | Bytes | null
    anexoResidencia?: BytesNullableFilter<"Candidato"> | Bytes | null
    anexoAtaConcurso?: BytesNullableFilter<"Candidato"> | Bytes | null
    fichaInscricao?: BytesNullableFilter<"Candidato"> | Bytes | null
    anexoTermoCandidato?: BytesNullableFilter<"Candidato"> | Bytes | null
    anexoRelatorioVivencia?: BytesNullableFilter<"Candidato"> | Bytes | null
    anexoResponsavel?: BytesNullableFilter<"Candidato"> | Bytes | null
    anexoProvaEsportivaCampeira?: BytesNullableFilter<"Candidato"> | Bytes | null
    categoriaId?: IntFilter<"Candidato"> | number
    concursoIdConcurso?: IntNullableFilter<"Candidato"> | number | null
    CTG?: XOR<CTGScalarRelationFilter, CTGWhereInput>
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaListRelationFilter
    Categoria?: XOR<CategoriaScalarRelationFilter, CategoriaWhereInput>
    avalicoes?: AvaliacaoListRelationFilter
    sorteioDanca?: SorteioDancaListRelationFilter
    Recurso?: RecursoListRelationFilter
    Concurso?: XOR<ConcursoNullableScalarRelationFilter, ConcursoWhereInput> | null
  }, "idCandidato">

  export type CandidatoOrderByWithAggregationInput = {
    idCandidato?: SortOrder
    nomeCompleto?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
    CTGId?: SortOrder
    numCarteirinha?: SortOrder
    CPF?: SortOrder
    RG?: SortOrder
    endereco?: SortOrder
    numEndereco?: SortOrder
    bairro?: SortOrder
    escolaridade?: SortOrder
    filiacao?: SortOrder
    ProvaCampeiraEsportiva?: SortOrderInput | SortOrder
    anexoDocumento?: SortOrderInput | SortOrder
    anexoCarteirinha?: SortOrderInput | SortOrder
    anexoEscolaridade?: SortOrderInput | SortOrder
    anexoResidencia?: SortOrderInput | SortOrder
    anexoAtaConcurso?: SortOrderInput | SortOrder
    fichaInscricao?: SortOrderInput | SortOrder
    anexoTermoCandidato?: SortOrderInput | SortOrder
    anexoRelatorioVivencia?: SortOrderInput | SortOrder
    anexoResponsavel?: SortOrderInput | SortOrder
    anexoProvaEsportivaCampeira?: SortOrderInput | SortOrder
    categoriaId?: SortOrder
    concursoIdConcurso?: SortOrderInput | SortOrder
    _count?: CandidatoCountOrderByAggregateInput
    _avg?: CandidatoAvgOrderByAggregateInput
    _max?: CandidatoMaxOrderByAggregateInput
    _min?: CandidatoMinOrderByAggregateInput
    _sum?: CandidatoSumOrderByAggregateInput
  }

  export type CandidatoScalarWhereWithAggregatesInput = {
    AND?: CandidatoScalarWhereWithAggregatesInput | CandidatoScalarWhereWithAggregatesInput[]
    OR?: CandidatoScalarWhereWithAggregatesInput[]
    NOT?: CandidatoScalarWhereWithAggregatesInput | CandidatoScalarWhereWithAggregatesInput[]
    idCandidato?: IntWithAggregatesFilter<"Candidato"> | number
    nomeCompleto?: StringWithAggregatesFilter<"Candidato"> | string
    cidade?: StringWithAggregatesFilter<"Candidato"> | string
    estado?: StringWithAggregatesFilter<"Candidato"> | string
    CTGId?: IntWithAggregatesFilter<"Candidato"> | number
    numCarteirinha?: StringWithAggregatesFilter<"Candidato"> | string
    CPF?: StringWithAggregatesFilter<"Candidato"> | string
    RG?: StringWithAggregatesFilter<"Candidato"> | string
    endereco?: StringWithAggregatesFilter<"Candidato"> | string
    numEndereco?: IntWithAggregatesFilter<"Candidato"> | number
    bairro?: StringWithAggregatesFilter<"Candidato"> | string
    escolaridade?: StringWithAggregatesFilter<"Candidato"> | string
    filiacao?: StringWithAggregatesFilter<"Candidato"> | string
    ProvaCampeiraEsportiva?: EnumProvaCampeiraEsportivaNullableWithAggregatesFilter<"Candidato"> | $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: BytesNullableWithAggregatesFilter<"Candidato"> | Bytes | null
    anexoCarteirinha?: BytesNullableWithAggregatesFilter<"Candidato"> | Bytes | null
    anexoEscolaridade?: BytesNullableWithAggregatesFilter<"Candidato"> | Bytes | null
    anexoResidencia?: BytesNullableWithAggregatesFilter<"Candidato"> | Bytes | null
    anexoAtaConcurso?: BytesNullableWithAggregatesFilter<"Candidato"> | Bytes | null
    fichaInscricao?: BytesNullableWithAggregatesFilter<"Candidato"> | Bytes | null
    anexoTermoCandidato?: BytesNullableWithAggregatesFilter<"Candidato"> | Bytes | null
    anexoRelatorioVivencia?: BytesNullableWithAggregatesFilter<"Candidato"> | Bytes | null
    anexoResponsavel?: BytesNullableWithAggregatesFilter<"Candidato"> | Bytes | null
    anexoProvaEsportivaCampeira?: BytesNullableWithAggregatesFilter<"Candidato"> | Bytes | null
    categoriaId?: IntWithAggregatesFilter<"Candidato"> | number
    concursoIdConcurso?: IntNullableWithAggregatesFilter<"Candidato"> | number | null
  }

  export type UsuarioWhereInput = {
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    idUsuario?: IntFilter<"Usuario"> | number
    nomeCompleto?: StringFilter<"Usuario"> | string
    cidade?: StringFilter<"Usuario"> | string
    estado?: StringFilter<"Usuario"> | string
    CTGId?: IntFilter<"Usuario"> | number
    numCarteirinha?: StringFilter<"Usuario"> | string
    login?: StringFilter<"Usuario"> | string
    senha?: StringFilter<"Usuario"> | string
    funcao?: EnumFuncaoFilter<"Usuario"> | $Enums.Funcao
    credenciamento?: EnumCredenciamentoFilter<"Usuario"> | $Enums.Credenciamento
    numCredenciamento?: IntNullableFilter<"Usuario"> | number | null
    comissaoUsuarioId?: IntNullableFilter<"Usuario"> | number | null
    CTG?: XOR<CTGScalarRelationFilter, CTGWhereInput>
    ComissaoUsuario?: XOR<ComissaoUsuarioNullableScalarRelationFilter, ComissaoUsuarioWhereInput> | null
    avalicoes?: AvaliacaoListRelationFilter
    recursos?: RecursoListRelationFilter
    sorteioDanca?: SorteioDancaListRelationFilter
  }

  export type UsuarioOrderByWithRelationInput = {
    idUsuario?: SortOrder
    nomeCompleto?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
    CTGId?: SortOrder
    numCarteirinha?: SortOrder
    login?: SortOrder
    senha?: SortOrder
    funcao?: SortOrder
    credenciamento?: SortOrder
    numCredenciamento?: SortOrderInput | SortOrder
    comissaoUsuarioId?: SortOrderInput | SortOrder
    CTG?: CTGOrderByWithRelationInput
    ComissaoUsuario?: ComissaoUsuarioOrderByWithRelationInput
    avalicoes?: AvaliacaoOrderByRelationAggregateInput
    recursos?: RecursoOrderByRelationAggregateInput
    sorteioDanca?: SorteioDancaOrderByRelationAggregateInput
  }

  export type UsuarioWhereUniqueInput = Prisma.AtLeast<{
    idUsuario?: number
    login?: string
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    nomeCompleto?: StringFilter<"Usuario"> | string
    cidade?: StringFilter<"Usuario"> | string
    estado?: StringFilter<"Usuario"> | string
    CTGId?: IntFilter<"Usuario"> | number
    numCarteirinha?: StringFilter<"Usuario"> | string
    senha?: StringFilter<"Usuario"> | string
    funcao?: EnumFuncaoFilter<"Usuario"> | $Enums.Funcao
    credenciamento?: EnumCredenciamentoFilter<"Usuario"> | $Enums.Credenciamento
    numCredenciamento?: IntNullableFilter<"Usuario"> | number | null
    comissaoUsuarioId?: IntNullableFilter<"Usuario"> | number | null
    CTG?: XOR<CTGScalarRelationFilter, CTGWhereInput>
    ComissaoUsuario?: XOR<ComissaoUsuarioNullableScalarRelationFilter, ComissaoUsuarioWhereInput> | null
    avalicoes?: AvaliacaoListRelationFilter
    recursos?: RecursoListRelationFilter
    sorteioDanca?: SorteioDancaListRelationFilter
  }, "idUsuario" | "login">

  export type UsuarioOrderByWithAggregationInput = {
    idUsuario?: SortOrder
    nomeCompleto?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
    CTGId?: SortOrder
    numCarteirinha?: SortOrder
    login?: SortOrder
    senha?: SortOrder
    funcao?: SortOrder
    credenciamento?: SortOrder
    numCredenciamento?: SortOrderInput | SortOrder
    comissaoUsuarioId?: SortOrderInput | SortOrder
    _count?: UsuarioCountOrderByAggregateInput
    _avg?: UsuarioAvgOrderByAggregateInput
    _max?: UsuarioMaxOrderByAggregateInput
    _min?: UsuarioMinOrderByAggregateInput
    _sum?: UsuarioSumOrderByAggregateInput
  }

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    OR?: UsuarioScalarWhereWithAggregatesInput[]
    NOT?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    idUsuario?: IntWithAggregatesFilter<"Usuario"> | number
    nomeCompleto?: StringWithAggregatesFilter<"Usuario"> | string
    cidade?: StringWithAggregatesFilter<"Usuario"> | string
    estado?: StringWithAggregatesFilter<"Usuario"> | string
    CTGId?: IntWithAggregatesFilter<"Usuario"> | number
    numCarteirinha?: StringWithAggregatesFilter<"Usuario"> | string
    login?: StringWithAggregatesFilter<"Usuario"> | string
    senha?: StringWithAggregatesFilter<"Usuario"> | string
    funcao?: EnumFuncaoWithAggregatesFilter<"Usuario"> | $Enums.Funcao
    credenciamento?: EnumCredenciamentoWithAggregatesFilter<"Usuario"> | $Enums.Credenciamento
    numCredenciamento?: IntNullableWithAggregatesFilter<"Usuario"> | number | null
    comissaoUsuarioId?: IntNullableWithAggregatesFilter<"Usuario"> | number | null
  }

  export type CTGWhereInput = {
    AND?: CTGWhereInput | CTGWhereInput[]
    OR?: CTGWhereInput[]
    NOT?: CTGWhereInput | CTGWhereInput[]
    idCTG?: IntFilter<"CTG"> | number
    nomeCTG?: StringFilter<"CTG"> | string
    RTid?: IntFilter<"CTG"> | number
    RT?: XOR<RTScalarRelationFilter, RTWhereInput>
    Usuario?: UsuarioListRelationFilter
    Candidato?: CandidatoListRelationFilter
  }

  export type CTGOrderByWithRelationInput = {
    idCTG?: SortOrder
    nomeCTG?: SortOrder
    RTid?: SortOrder
    RT?: RTOrderByWithRelationInput
    Usuario?: UsuarioOrderByRelationAggregateInput
    Candidato?: CandidatoOrderByRelationAggregateInput
  }

  export type CTGWhereUniqueInput = Prisma.AtLeast<{
    idCTG?: number
    AND?: CTGWhereInput | CTGWhereInput[]
    OR?: CTGWhereInput[]
    NOT?: CTGWhereInput | CTGWhereInput[]
    nomeCTG?: StringFilter<"CTG"> | string
    RTid?: IntFilter<"CTG"> | number
    RT?: XOR<RTScalarRelationFilter, RTWhereInput>
    Usuario?: UsuarioListRelationFilter
    Candidato?: CandidatoListRelationFilter
  }, "idCTG">

  export type CTGOrderByWithAggregationInput = {
    idCTG?: SortOrder
    nomeCTG?: SortOrder
    RTid?: SortOrder
    _count?: CTGCountOrderByAggregateInput
    _avg?: CTGAvgOrderByAggregateInput
    _max?: CTGMaxOrderByAggregateInput
    _min?: CTGMinOrderByAggregateInput
    _sum?: CTGSumOrderByAggregateInput
  }

  export type CTGScalarWhereWithAggregatesInput = {
    AND?: CTGScalarWhereWithAggregatesInput | CTGScalarWhereWithAggregatesInput[]
    OR?: CTGScalarWhereWithAggregatesInput[]
    NOT?: CTGScalarWhereWithAggregatesInput | CTGScalarWhereWithAggregatesInput[]
    idCTG?: IntWithAggregatesFilter<"CTG"> | number
    nomeCTG?: StringWithAggregatesFilter<"CTG"> | string
    RTid?: IntWithAggregatesFilter<"CTG"> | number
  }

  export type RTWhereInput = {
    AND?: RTWhereInput | RTWhereInput[]
    OR?: RTWhereInput[]
    NOT?: RTWhereInput | RTWhereInput[]
    idRT?: IntFilter<"RT"> | number
    nomeRT?: StringFilter<"RT"> | string
    numeroRT?: IntNullableFilter<"RT"> | number | null
    CTGs?: CTGListRelationFilter
  }

  export type RTOrderByWithRelationInput = {
    idRT?: SortOrder
    nomeRT?: SortOrder
    numeroRT?: SortOrderInput | SortOrder
    CTGs?: CTGOrderByRelationAggregateInput
  }

  export type RTWhereUniqueInput = Prisma.AtLeast<{
    idRT?: number
    AND?: RTWhereInput | RTWhereInput[]
    OR?: RTWhereInput[]
    NOT?: RTWhereInput | RTWhereInput[]
    nomeRT?: StringFilter<"RT"> | string
    numeroRT?: IntNullableFilter<"RT"> | number | null
    CTGs?: CTGListRelationFilter
  }, "idRT">

  export type RTOrderByWithAggregationInput = {
    idRT?: SortOrder
    nomeRT?: SortOrder
    numeroRT?: SortOrderInput | SortOrder
    _count?: RTCountOrderByAggregateInput
    _avg?: RTAvgOrderByAggregateInput
    _max?: RTMaxOrderByAggregateInput
    _min?: RTMinOrderByAggregateInput
    _sum?: RTSumOrderByAggregateInput
  }

  export type RTScalarWhereWithAggregatesInput = {
    AND?: RTScalarWhereWithAggregatesInput | RTScalarWhereWithAggregatesInput[]
    OR?: RTScalarWhereWithAggregatesInput[]
    NOT?: RTScalarWhereWithAggregatesInput | RTScalarWhereWithAggregatesInput[]
    idRT?: IntWithAggregatesFilter<"RT"> | number
    nomeRT?: StringWithAggregatesFilter<"RT"> | string
    numeroRT?: IntNullableWithAggregatesFilter<"RT"> | number | null
  }

  export type PreferenciaSorteioDancaWhereInput = {
    AND?: PreferenciaSorteioDancaWhereInput | PreferenciaSorteioDancaWhereInput[]
    OR?: PreferenciaSorteioDancaWhereInput[]
    NOT?: PreferenciaSorteioDancaWhereInput | PreferenciaSorteioDancaWhereInput[]
    idPreferencia?: IntFilter<"PreferenciaSorteioDanca"> | number
    nomeSorteioDanca?: EnumDancaSalaoTradicionalFilter<"PreferenciaSorteioDanca"> | $Enums.DancaSalaoTradicional
    candidatoId?: IntFilter<"PreferenciaSorteioDanca"> | number
    sorteioDancaId?: IntNullableFilter<"PreferenciaSorteioDanca"> | number | null
    Candidato?: XOR<CandidatoScalarRelationFilter, CandidatoWhereInput>
    SorteioDanca?: XOR<SorteioDancaNullableScalarRelationFilter, SorteioDancaWhereInput> | null
    quesitos?: QuesitosListRelationFilter
  }

  export type PreferenciaSorteioDancaOrderByWithRelationInput = {
    idPreferencia?: SortOrder
    nomeSorteioDanca?: SortOrder
    candidatoId?: SortOrder
    sorteioDancaId?: SortOrderInput | SortOrder
    Candidato?: CandidatoOrderByWithRelationInput
    SorteioDanca?: SorteioDancaOrderByWithRelationInput
    quesitos?: QuesitosOrderByRelationAggregateInput
  }

  export type PreferenciaSorteioDancaWhereUniqueInput = Prisma.AtLeast<{
    idPreferencia?: number
    AND?: PreferenciaSorteioDancaWhereInput | PreferenciaSorteioDancaWhereInput[]
    OR?: PreferenciaSorteioDancaWhereInput[]
    NOT?: PreferenciaSorteioDancaWhereInput | PreferenciaSorteioDancaWhereInput[]
    nomeSorteioDanca?: EnumDancaSalaoTradicionalFilter<"PreferenciaSorteioDanca"> | $Enums.DancaSalaoTradicional
    candidatoId?: IntFilter<"PreferenciaSorteioDanca"> | number
    sorteioDancaId?: IntNullableFilter<"PreferenciaSorteioDanca"> | number | null
    Candidato?: XOR<CandidatoScalarRelationFilter, CandidatoWhereInput>
    SorteioDanca?: XOR<SorteioDancaNullableScalarRelationFilter, SorteioDancaWhereInput> | null
    quesitos?: QuesitosListRelationFilter
  }, "idPreferencia">

  export type PreferenciaSorteioDancaOrderByWithAggregationInput = {
    idPreferencia?: SortOrder
    nomeSorteioDanca?: SortOrder
    candidatoId?: SortOrder
    sorteioDancaId?: SortOrderInput | SortOrder
    _count?: PreferenciaSorteioDancaCountOrderByAggregateInput
    _avg?: PreferenciaSorteioDancaAvgOrderByAggregateInput
    _max?: PreferenciaSorteioDancaMaxOrderByAggregateInput
    _min?: PreferenciaSorteioDancaMinOrderByAggregateInput
    _sum?: PreferenciaSorteioDancaSumOrderByAggregateInput
  }

  export type PreferenciaSorteioDancaScalarWhereWithAggregatesInput = {
    AND?: PreferenciaSorteioDancaScalarWhereWithAggregatesInput | PreferenciaSorteioDancaScalarWhereWithAggregatesInput[]
    OR?: PreferenciaSorteioDancaScalarWhereWithAggregatesInput[]
    NOT?: PreferenciaSorteioDancaScalarWhereWithAggregatesInput | PreferenciaSorteioDancaScalarWhereWithAggregatesInput[]
    idPreferencia?: IntWithAggregatesFilter<"PreferenciaSorteioDanca"> | number
    nomeSorteioDanca?: EnumDancaSalaoTradicionalWithAggregatesFilter<"PreferenciaSorteioDanca"> | $Enums.DancaSalaoTradicional
    candidatoId?: IntWithAggregatesFilter<"PreferenciaSorteioDanca"> | number
    sorteioDancaId?: IntNullableWithAggregatesFilter<"PreferenciaSorteioDanca"> | number | null
  }

  export type ConcursoWhereInput = {
    AND?: ConcursoWhereInput | ConcursoWhereInput[]
    OR?: ConcursoWhereInput[]
    NOT?: ConcursoWhereInput | ConcursoWhereInput[]
    idConcurso?: IntFilter<"Concurso"> | number
    nomeConcurso?: StringFilter<"Concurso"> | string
    lancamentoEdital?: DateTimeFilter<"Concurso"> | Date | string
    inscricoesInicio?: DateTimeFilter<"Concurso"> | Date | string
    inscricoesFinal?: DateTimeFilter<"Concurso"> | Date | string
    dataProvaEscrita?: DateTimeFilter<"Concurso"> | Date | string
    dataProvasPraticas?: DateTimeFilter<"Concurso"> | Date | string
    dataResultado?: DateTimeFilter<"Concurso"> | Date | string
    local?: StringFilter<"Concurso"> | string
    anexoEdital?: BytesNullableFilter<"Concurso"> | Bytes | null
    candidatos?: CandidatoListRelationFilter
    comissoes?: ComissaoListRelationFilter
  }

  export type ConcursoOrderByWithRelationInput = {
    idConcurso?: SortOrder
    nomeConcurso?: SortOrder
    lancamentoEdital?: SortOrder
    inscricoesInicio?: SortOrder
    inscricoesFinal?: SortOrder
    dataProvaEscrita?: SortOrder
    dataProvasPraticas?: SortOrder
    dataResultado?: SortOrder
    local?: SortOrder
    anexoEdital?: SortOrderInput | SortOrder
    candidatos?: CandidatoOrderByRelationAggregateInput
    comissoes?: ComissaoOrderByRelationAggregateInput
  }

  export type ConcursoWhereUniqueInput = Prisma.AtLeast<{
    idConcurso?: number
    AND?: ConcursoWhereInput | ConcursoWhereInput[]
    OR?: ConcursoWhereInput[]
    NOT?: ConcursoWhereInput | ConcursoWhereInput[]
    nomeConcurso?: StringFilter<"Concurso"> | string
    lancamentoEdital?: DateTimeFilter<"Concurso"> | Date | string
    inscricoesInicio?: DateTimeFilter<"Concurso"> | Date | string
    inscricoesFinal?: DateTimeFilter<"Concurso"> | Date | string
    dataProvaEscrita?: DateTimeFilter<"Concurso"> | Date | string
    dataProvasPraticas?: DateTimeFilter<"Concurso"> | Date | string
    dataResultado?: DateTimeFilter<"Concurso"> | Date | string
    local?: StringFilter<"Concurso"> | string
    anexoEdital?: BytesNullableFilter<"Concurso"> | Bytes | null
    candidatos?: CandidatoListRelationFilter
    comissoes?: ComissaoListRelationFilter
  }, "idConcurso">

  export type ConcursoOrderByWithAggregationInput = {
    idConcurso?: SortOrder
    nomeConcurso?: SortOrder
    lancamentoEdital?: SortOrder
    inscricoesInicio?: SortOrder
    inscricoesFinal?: SortOrder
    dataProvaEscrita?: SortOrder
    dataProvasPraticas?: SortOrder
    dataResultado?: SortOrder
    local?: SortOrder
    anexoEdital?: SortOrderInput | SortOrder
    _count?: ConcursoCountOrderByAggregateInput
    _avg?: ConcursoAvgOrderByAggregateInput
    _max?: ConcursoMaxOrderByAggregateInput
    _min?: ConcursoMinOrderByAggregateInput
    _sum?: ConcursoSumOrderByAggregateInput
  }

  export type ConcursoScalarWhereWithAggregatesInput = {
    AND?: ConcursoScalarWhereWithAggregatesInput | ConcursoScalarWhereWithAggregatesInput[]
    OR?: ConcursoScalarWhereWithAggregatesInput[]
    NOT?: ConcursoScalarWhereWithAggregatesInput | ConcursoScalarWhereWithAggregatesInput[]
    idConcurso?: IntWithAggregatesFilter<"Concurso"> | number
    nomeConcurso?: StringWithAggregatesFilter<"Concurso"> | string
    lancamentoEdital?: DateTimeWithAggregatesFilter<"Concurso"> | Date | string
    inscricoesInicio?: DateTimeWithAggregatesFilter<"Concurso"> | Date | string
    inscricoesFinal?: DateTimeWithAggregatesFilter<"Concurso"> | Date | string
    dataProvaEscrita?: DateTimeWithAggregatesFilter<"Concurso"> | Date | string
    dataProvasPraticas?: DateTimeWithAggregatesFilter<"Concurso"> | Date | string
    dataResultado?: DateTimeWithAggregatesFilter<"Concurso"> | Date | string
    local?: StringWithAggregatesFilter<"Concurso"> | string
    anexoEdital?: BytesNullableWithAggregatesFilter<"Concurso"> | Bytes | null
  }

  export type ComissaoWhereInput = {
    AND?: ComissaoWhereInput | ComissaoWhereInput[]
    OR?: ComissaoWhereInput[]
    NOT?: ComissaoWhereInput | ComissaoWhereInput[]
    idComissao?: IntFilter<"Comissao"> | number
    nomeComissao?: StringFilter<"Comissao"> | string
    concursoId?: IntFilter<"Comissao"> | number
    concurso?: XOR<ConcursoScalarRelationFilter, ConcursoWhereInput>
    avalicao?: AvaliacaoListRelationFilter
    usuarios?: ComissaoUsuarioListRelationFilter
  }

  export type ComissaoOrderByWithRelationInput = {
    idComissao?: SortOrder
    nomeComissao?: SortOrder
    concursoId?: SortOrder
    concurso?: ConcursoOrderByWithRelationInput
    avalicao?: AvaliacaoOrderByRelationAggregateInput
    usuarios?: ComissaoUsuarioOrderByRelationAggregateInput
  }

  export type ComissaoWhereUniqueInput = Prisma.AtLeast<{
    idComissao?: number
    AND?: ComissaoWhereInput | ComissaoWhereInput[]
    OR?: ComissaoWhereInput[]
    NOT?: ComissaoWhereInput | ComissaoWhereInput[]
    nomeComissao?: StringFilter<"Comissao"> | string
    concursoId?: IntFilter<"Comissao"> | number
    concurso?: XOR<ConcursoScalarRelationFilter, ConcursoWhereInput>
    avalicao?: AvaliacaoListRelationFilter
    usuarios?: ComissaoUsuarioListRelationFilter
  }, "idComissao">

  export type ComissaoOrderByWithAggregationInput = {
    idComissao?: SortOrder
    nomeComissao?: SortOrder
    concursoId?: SortOrder
    _count?: ComissaoCountOrderByAggregateInput
    _avg?: ComissaoAvgOrderByAggregateInput
    _max?: ComissaoMaxOrderByAggregateInput
    _min?: ComissaoMinOrderByAggregateInput
    _sum?: ComissaoSumOrderByAggregateInput
  }

  export type ComissaoScalarWhereWithAggregatesInput = {
    AND?: ComissaoScalarWhereWithAggregatesInput | ComissaoScalarWhereWithAggregatesInput[]
    OR?: ComissaoScalarWhereWithAggregatesInput[]
    NOT?: ComissaoScalarWhereWithAggregatesInput | ComissaoScalarWhereWithAggregatesInput[]
    idComissao?: IntWithAggregatesFilter<"Comissao"> | number
    nomeComissao?: StringWithAggregatesFilter<"Comissao"> | string
    concursoId?: IntWithAggregatesFilter<"Comissao"> | number
  }

  export type ComissaoUsuarioWhereInput = {
    AND?: ComissaoUsuarioWhereInput | ComissaoUsuarioWhereInput[]
    OR?: ComissaoUsuarioWhereInput[]
    NOT?: ComissaoUsuarioWhereInput | ComissaoUsuarioWhereInput[]
    idComissaoUsuario?: IntFilter<"ComissaoUsuario"> | number
    comissaoId?: IntFilter<"ComissaoUsuario"> | number
    usuarioId?: IntFilter<"ComissaoUsuario"> | number
    Comissao?: XOR<ComissaoScalarRelationFilter, ComissaoWhereInput>
    Usuarios?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }

  export type ComissaoUsuarioOrderByWithRelationInput = {
    idComissaoUsuario?: SortOrder
    comissaoId?: SortOrder
    usuarioId?: SortOrder
    Comissao?: ComissaoOrderByWithRelationInput
    Usuarios?: UsuarioOrderByWithRelationInput
  }

  export type ComissaoUsuarioWhereUniqueInput = Prisma.AtLeast<{
    idComissaoUsuario?: number
    usuarioId?: number
    comissaoId_usuarioId?: ComissaoUsuarioComissaoIdUsuarioIdCompoundUniqueInput
    AND?: ComissaoUsuarioWhereInput | ComissaoUsuarioWhereInput[]
    OR?: ComissaoUsuarioWhereInput[]
    NOT?: ComissaoUsuarioWhereInput | ComissaoUsuarioWhereInput[]
    comissaoId?: IntFilter<"ComissaoUsuario"> | number
    Comissao?: XOR<ComissaoScalarRelationFilter, ComissaoWhereInput>
    Usuarios?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }, "idComissaoUsuario" | "usuarioId" | "comissaoId_usuarioId">

  export type ComissaoUsuarioOrderByWithAggregationInput = {
    idComissaoUsuario?: SortOrder
    comissaoId?: SortOrder
    usuarioId?: SortOrder
    _count?: ComissaoUsuarioCountOrderByAggregateInput
    _avg?: ComissaoUsuarioAvgOrderByAggregateInput
    _max?: ComissaoUsuarioMaxOrderByAggregateInput
    _min?: ComissaoUsuarioMinOrderByAggregateInput
    _sum?: ComissaoUsuarioSumOrderByAggregateInput
  }

  export type ComissaoUsuarioScalarWhereWithAggregatesInput = {
    AND?: ComissaoUsuarioScalarWhereWithAggregatesInput | ComissaoUsuarioScalarWhereWithAggregatesInput[]
    OR?: ComissaoUsuarioScalarWhereWithAggregatesInput[]
    NOT?: ComissaoUsuarioScalarWhereWithAggregatesInput | ComissaoUsuarioScalarWhereWithAggregatesInput[]
    idComissaoUsuario?: IntWithAggregatesFilter<"ComissaoUsuario"> | number
    comissaoId?: IntWithAggregatesFilter<"ComissaoUsuario"> | number
    usuarioId?: IntWithAggregatesFilter<"ComissaoUsuario"> | number
  }

  export type CategoriaWhereInput = {
    AND?: CategoriaWhereInput | CategoriaWhereInput[]
    OR?: CategoriaWhereInput[]
    NOT?: CategoriaWhereInput | CategoriaWhereInput[]
    idCategoria?: IntFilter<"Categoria"> | number
    nomeCategoria?: StringFilter<"Categoria"> | string
    escolaridade?: StringFilter<"Categoria"> | string
    sorteioDanca?: IntFilter<"Categoria"> | number
    idadeInicial?: IntFilter<"Categoria"> | number
    idadeLimite?: IntNullableFilter<"Categoria"> | number | null
    provaId?: IntNullableFilter<"Categoria"> | number | null
    provaTeoricaId?: IntNullableFilter<"Categoria"> | number | null
    provaPraticaId?: IntNullableFilter<"Categoria"> | number | null
    candidatos?: CandidatoListRelationFilter
    Prova?: XOR<ProvaNullableScalarRelationFilter, ProvaWhereInput> | null
    ProvaTeorica?: XOR<ProvaTeoricaNullableScalarRelationFilter, ProvaTeoricaWhereInput> | null
    ProvaPratica?: XOR<ProvaPraticaNullableScalarRelationFilter, ProvaPraticaWhereInput> | null
  }

  export type CategoriaOrderByWithRelationInput = {
    idCategoria?: SortOrder
    nomeCategoria?: SortOrder
    escolaridade?: SortOrder
    sorteioDanca?: SortOrder
    idadeInicial?: SortOrder
    idadeLimite?: SortOrderInput | SortOrder
    provaId?: SortOrderInput | SortOrder
    provaTeoricaId?: SortOrderInput | SortOrder
    provaPraticaId?: SortOrderInput | SortOrder
    candidatos?: CandidatoOrderByRelationAggregateInput
    Prova?: ProvaOrderByWithRelationInput
    ProvaTeorica?: ProvaTeoricaOrderByWithRelationInput
    ProvaPratica?: ProvaPraticaOrderByWithRelationInput
  }

  export type CategoriaWhereUniqueInput = Prisma.AtLeast<{
    idCategoria?: number
    AND?: CategoriaWhereInput | CategoriaWhereInput[]
    OR?: CategoriaWhereInput[]
    NOT?: CategoriaWhereInput | CategoriaWhereInput[]
    nomeCategoria?: StringFilter<"Categoria"> | string
    escolaridade?: StringFilter<"Categoria"> | string
    sorteioDanca?: IntFilter<"Categoria"> | number
    idadeInicial?: IntFilter<"Categoria"> | number
    idadeLimite?: IntNullableFilter<"Categoria"> | number | null
    provaId?: IntNullableFilter<"Categoria"> | number | null
    provaTeoricaId?: IntNullableFilter<"Categoria"> | number | null
    provaPraticaId?: IntNullableFilter<"Categoria"> | number | null
    candidatos?: CandidatoListRelationFilter
    Prova?: XOR<ProvaNullableScalarRelationFilter, ProvaWhereInput> | null
    ProvaTeorica?: XOR<ProvaTeoricaNullableScalarRelationFilter, ProvaTeoricaWhereInput> | null
    ProvaPratica?: XOR<ProvaPraticaNullableScalarRelationFilter, ProvaPraticaWhereInput> | null
  }, "idCategoria">

  export type CategoriaOrderByWithAggregationInput = {
    idCategoria?: SortOrder
    nomeCategoria?: SortOrder
    escolaridade?: SortOrder
    sorteioDanca?: SortOrder
    idadeInicial?: SortOrder
    idadeLimite?: SortOrderInput | SortOrder
    provaId?: SortOrderInput | SortOrder
    provaTeoricaId?: SortOrderInput | SortOrder
    provaPraticaId?: SortOrderInput | SortOrder
    _count?: CategoriaCountOrderByAggregateInput
    _avg?: CategoriaAvgOrderByAggregateInput
    _max?: CategoriaMaxOrderByAggregateInput
    _min?: CategoriaMinOrderByAggregateInput
    _sum?: CategoriaSumOrderByAggregateInput
  }

  export type CategoriaScalarWhereWithAggregatesInput = {
    AND?: CategoriaScalarWhereWithAggregatesInput | CategoriaScalarWhereWithAggregatesInput[]
    OR?: CategoriaScalarWhereWithAggregatesInput[]
    NOT?: CategoriaScalarWhereWithAggregatesInput | CategoriaScalarWhereWithAggregatesInput[]
    idCategoria?: IntWithAggregatesFilter<"Categoria"> | number
    nomeCategoria?: StringWithAggregatesFilter<"Categoria"> | string
    escolaridade?: StringWithAggregatesFilter<"Categoria"> | string
    sorteioDanca?: IntWithAggregatesFilter<"Categoria"> | number
    idadeInicial?: IntWithAggregatesFilter<"Categoria"> | number
    idadeLimite?: IntNullableWithAggregatesFilter<"Categoria"> | number | null
    provaId?: IntNullableWithAggregatesFilter<"Categoria"> | number | null
    provaTeoricaId?: IntNullableWithAggregatesFilter<"Categoria"> | number | null
    provaPraticaId?: IntNullableWithAggregatesFilter<"Categoria"> | number | null
  }

  export type AvaliacaoWhereInput = {
    AND?: AvaliacaoWhereInput | AvaliacaoWhereInput[]
    OR?: AvaliacaoWhereInput[]
    NOT?: AvaliacaoWhereInput | AvaliacaoWhereInput[]
    idAvalicao?: IntFilter<"Avaliacao"> | number
    dataAvaliacao?: DateTimeFilter<"Avaliacao"> | Date | string
    comissaoId?: IntFilter<"Avaliacao"> | number
    avaliadorId?: IntFilter<"Avaliacao"> | number
    provaId?: IntFilter<"Avaliacao"> | number
    blocoProvaId?: IntNullableFilter<"Avaliacao"> | number | null
    nota?: FloatFilter<"Avaliacao"> | number
    candidatoId?: IntFilter<"Avaliacao"> | number
    fichaCandidatoIdFicha?: IntNullableFilter<"Avaliacao"> | number | null
    Comissao?: XOR<ComissaoScalarRelationFilter, ComissaoWhereInput>
    Usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
    Prova?: XOR<ProvaNullableScalarRelationFilter, ProvaWhereInput> | null
    BlocoProva?: XOR<BlocoProvaNullableScalarRelationFilter, BlocoProvaWhereInput> | null
    quesitos?: QuesitosListRelationFilter
    Candidato?: XOR<CandidatoScalarRelationFilter, CandidatoWhereInput>
    FichaCandidato?: XOR<FichaCandidatoNullableScalarRelationFilter, FichaCandidatoWhereInput> | null
  }

  export type AvaliacaoOrderByWithRelationInput = {
    idAvalicao?: SortOrder
    dataAvaliacao?: SortOrder
    comissaoId?: SortOrder
    avaliadorId?: SortOrder
    provaId?: SortOrder
    blocoProvaId?: SortOrderInput | SortOrder
    nota?: SortOrder
    candidatoId?: SortOrder
    fichaCandidatoIdFicha?: SortOrderInput | SortOrder
    Comissao?: ComissaoOrderByWithRelationInput
    Usuario?: UsuarioOrderByWithRelationInput
    Prova?: ProvaOrderByWithRelationInput
    BlocoProva?: BlocoProvaOrderByWithRelationInput
    quesitos?: QuesitosOrderByRelationAggregateInput
    Candidato?: CandidatoOrderByWithRelationInput
    FichaCandidato?: FichaCandidatoOrderByWithRelationInput
  }

  export type AvaliacaoWhereUniqueInput = Prisma.AtLeast<{
    idAvalicao?: number
    AND?: AvaliacaoWhereInput | AvaliacaoWhereInput[]
    OR?: AvaliacaoWhereInput[]
    NOT?: AvaliacaoWhereInput | AvaliacaoWhereInput[]
    dataAvaliacao?: DateTimeFilter<"Avaliacao"> | Date | string
    comissaoId?: IntFilter<"Avaliacao"> | number
    avaliadorId?: IntFilter<"Avaliacao"> | number
    provaId?: IntFilter<"Avaliacao"> | number
    blocoProvaId?: IntNullableFilter<"Avaliacao"> | number | null
    nota?: FloatFilter<"Avaliacao"> | number
    candidatoId?: IntFilter<"Avaliacao"> | number
    fichaCandidatoIdFicha?: IntNullableFilter<"Avaliacao"> | number | null
    Comissao?: XOR<ComissaoScalarRelationFilter, ComissaoWhereInput>
    Usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
    Prova?: XOR<ProvaNullableScalarRelationFilter, ProvaWhereInput> | null
    BlocoProva?: XOR<BlocoProvaNullableScalarRelationFilter, BlocoProvaWhereInput> | null
    quesitos?: QuesitosListRelationFilter
    Candidato?: XOR<CandidatoScalarRelationFilter, CandidatoWhereInput>
    FichaCandidato?: XOR<FichaCandidatoNullableScalarRelationFilter, FichaCandidatoWhereInput> | null
  }, "idAvalicao">

  export type AvaliacaoOrderByWithAggregationInput = {
    idAvalicao?: SortOrder
    dataAvaliacao?: SortOrder
    comissaoId?: SortOrder
    avaliadorId?: SortOrder
    provaId?: SortOrder
    blocoProvaId?: SortOrderInput | SortOrder
    nota?: SortOrder
    candidatoId?: SortOrder
    fichaCandidatoIdFicha?: SortOrderInput | SortOrder
    _count?: AvaliacaoCountOrderByAggregateInput
    _avg?: AvaliacaoAvgOrderByAggregateInput
    _max?: AvaliacaoMaxOrderByAggregateInput
    _min?: AvaliacaoMinOrderByAggregateInput
    _sum?: AvaliacaoSumOrderByAggregateInput
  }

  export type AvaliacaoScalarWhereWithAggregatesInput = {
    AND?: AvaliacaoScalarWhereWithAggregatesInput | AvaliacaoScalarWhereWithAggregatesInput[]
    OR?: AvaliacaoScalarWhereWithAggregatesInput[]
    NOT?: AvaliacaoScalarWhereWithAggregatesInput | AvaliacaoScalarWhereWithAggregatesInput[]
    idAvalicao?: IntWithAggregatesFilter<"Avaliacao"> | number
    dataAvaliacao?: DateTimeWithAggregatesFilter<"Avaliacao"> | Date | string
    comissaoId?: IntWithAggregatesFilter<"Avaliacao"> | number
    avaliadorId?: IntWithAggregatesFilter<"Avaliacao"> | number
    provaId?: IntWithAggregatesFilter<"Avaliacao"> | number
    blocoProvaId?: IntNullableWithAggregatesFilter<"Avaliacao"> | number | null
    nota?: FloatWithAggregatesFilter<"Avaliacao"> | number
    candidatoId?: IntWithAggregatesFilter<"Avaliacao"> | number
    fichaCandidatoIdFicha?: IntNullableWithAggregatesFilter<"Avaliacao"> | number | null
  }

  export type ProvaWhereInput = {
    AND?: ProvaWhereInput | ProvaWhereInput[]
    OR?: ProvaWhereInput[]
    NOT?: ProvaWhereInput | ProvaWhereInput[]
    idProva?: IntFilter<"Prova"> | number
    nomeProva?: StringFilter<"Prova"> | string
    notaMaxima?: FloatFilter<"Prova"> | number
    categorias?: CategoriaListRelationFilter
    ProvaTeorica?: ProvaTeoricaListRelationFilter
    ProvaPratica?: ProvaPraticaListRelationFilter
    recursos?: RecursoListRelationFilter
    Avaliacao?: AvaliacaoListRelationFilter
  }

  export type ProvaOrderByWithRelationInput = {
    idProva?: SortOrder
    nomeProva?: SortOrder
    notaMaxima?: SortOrder
    categorias?: CategoriaOrderByRelationAggregateInput
    ProvaTeorica?: ProvaTeoricaOrderByRelationAggregateInput
    ProvaPratica?: ProvaPraticaOrderByRelationAggregateInput
    recursos?: RecursoOrderByRelationAggregateInput
    Avaliacao?: AvaliacaoOrderByRelationAggregateInput
  }

  export type ProvaWhereUniqueInput = Prisma.AtLeast<{
    idProva?: number
    AND?: ProvaWhereInput | ProvaWhereInput[]
    OR?: ProvaWhereInput[]
    NOT?: ProvaWhereInput | ProvaWhereInput[]
    nomeProva?: StringFilter<"Prova"> | string
    notaMaxima?: FloatFilter<"Prova"> | number
    categorias?: CategoriaListRelationFilter
    ProvaTeorica?: ProvaTeoricaListRelationFilter
    ProvaPratica?: ProvaPraticaListRelationFilter
    recursos?: RecursoListRelationFilter
    Avaliacao?: AvaliacaoListRelationFilter
  }, "idProva">

  export type ProvaOrderByWithAggregationInput = {
    idProva?: SortOrder
    nomeProva?: SortOrder
    notaMaxima?: SortOrder
    _count?: ProvaCountOrderByAggregateInput
    _avg?: ProvaAvgOrderByAggregateInput
    _max?: ProvaMaxOrderByAggregateInput
    _min?: ProvaMinOrderByAggregateInput
    _sum?: ProvaSumOrderByAggregateInput
  }

  export type ProvaScalarWhereWithAggregatesInput = {
    AND?: ProvaScalarWhereWithAggregatesInput | ProvaScalarWhereWithAggregatesInput[]
    OR?: ProvaScalarWhereWithAggregatesInput[]
    NOT?: ProvaScalarWhereWithAggregatesInput | ProvaScalarWhereWithAggregatesInput[]
    idProva?: IntWithAggregatesFilter<"Prova"> | number
    nomeProva?: StringWithAggregatesFilter<"Prova"> | string
    notaMaxima?: FloatWithAggregatesFilter<"Prova"> | number
  }

  export type ProvaTeoricaWhereInput = {
    AND?: ProvaTeoricaWhereInput | ProvaTeoricaWhereInput[]
    OR?: ProvaTeoricaWhereInput[]
    NOT?: ProvaTeoricaWhereInput | ProvaTeoricaWhereInput[]
    idprovaTeorica?: IntFilter<"ProvaTeorica"> | number
    provaId?: IntNullableFilter<"ProvaTeorica"> | number | null
    gabaritoOficinal?: BytesFilter<"ProvaTeorica"> | Bytes
    numQuestao?: IntFilter<"ProvaTeorica"> | number
    Prova?: XOR<ProvaNullableScalarRelationFilter, ProvaWhereInput> | null
    quesitos?: QuesitosListRelationFilter
    Categoria?: CategoriaListRelationFilter
    Recurso?: RecursoListRelationFilter
  }

  export type ProvaTeoricaOrderByWithRelationInput = {
    idprovaTeorica?: SortOrder
    provaId?: SortOrderInput | SortOrder
    gabaritoOficinal?: SortOrder
    numQuestao?: SortOrder
    Prova?: ProvaOrderByWithRelationInput
    quesitos?: QuesitosOrderByRelationAggregateInput
    Categoria?: CategoriaOrderByRelationAggregateInput
    Recurso?: RecursoOrderByRelationAggregateInput
  }

  export type ProvaTeoricaWhereUniqueInput = Prisma.AtLeast<{
    idprovaTeorica?: number
    AND?: ProvaTeoricaWhereInput | ProvaTeoricaWhereInput[]
    OR?: ProvaTeoricaWhereInput[]
    NOT?: ProvaTeoricaWhereInput | ProvaTeoricaWhereInput[]
    provaId?: IntNullableFilter<"ProvaTeorica"> | number | null
    gabaritoOficinal?: BytesFilter<"ProvaTeorica"> | Bytes
    numQuestao?: IntFilter<"ProvaTeorica"> | number
    Prova?: XOR<ProvaNullableScalarRelationFilter, ProvaWhereInput> | null
    quesitos?: QuesitosListRelationFilter
    Categoria?: CategoriaListRelationFilter
    Recurso?: RecursoListRelationFilter
  }, "idprovaTeorica">

  export type ProvaTeoricaOrderByWithAggregationInput = {
    idprovaTeorica?: SortOrder
    provaId?: SortOrderInput | SortOrder
    gabaritoOficinal?: SortOrder
    numQuestao?: SortOrder
    _count?: ProvaTeoricaCountOrderByAggregateInput
    _avg?: ProvaTeoricaAvgOrderByAggregateInput
    _max?: ProvaTeoricaMaxOrderByAggregateInput
    _min?: ProvaTeoricaMinOrderByAggregateInput
    _sum?: ProvaTeoricaSumOrderByAggregateInput
  }

  export type ProvaTeoricaScalarWhereWithAggregatesInput = {
    AND?: ProvaTeoricaScalarWhereWithAggregatesInput | ProvaTeoricaScalarWhereWithAggregatesInput[]
    OR?: ProvaTeoricaScalarWhereWithAggregatesInput[]
    NOT?: ProvaTeoricaScalarWhereWithAggregatesInput | ProvaTeoricaScalarWhereWithAggregatesInput[]
    idprovaTeorica?: IntWithAggregatesFilter<"ProvaTeorica"> | number
    provaId?: IntNullableWithAggregatesFilter<"ProvaTeorica"> | number | null
    gabaritoOficinal?: BytesWithAggregatesFilter<"ProvaTeorica"> | Bytes
    numQuestao?: IntWithAggregatesFilter<"ProvaTeorica"> | number
  }

  export type ProvaPraticaWhereInput = {
    AND?: ProvaPraticaWhereInput | ProvaPraticaWhereInput[]
    OR?: ProvaPraticaWhereInput[]
    NOT?: ProvaPraticaWhereInput | ProvaPraticaWhereInput[]
    idProvaPratica?: IntFilter<"ProvaPratica"> | number
    provaId?: IntNullableFilter<"ProvaPratica"> | number | null
    prova?: XOR<ProvaNullableScalarRelationFilter, ProvaWhereInput> | null
    blocosProvas?: BlocoProvaListRelationFilter
    Categoria?: CategoriaListRelationFilter
    Recurso?: RecursoListRelationFilter
  }

  export type ProvaPraticaOrderByWithRelationInput = {
    idProvaPratica?: SortOrder
    provaId?: SortOrderInput | SortOrder
    prova?: ProvaOrderByWithRelationInput
    blocosProvas?: BlocoProvaOrderByRelationAggregateInput
    Categoria?: CategoriaOrderByRelationAggregateInput
    Recurso?: RecursoOrderByRelationAggregateInput
  }

  export type ProvaPraticaWhereUniqueInput = Prisma.AtLeast<{
    idProvaPratica?: number
    AND?: ProvaPraticaWhereInput | ProvaPraticaWhereInput[]
    OR?: ProvaPraticaWhereInput[]
    NOT?: ProvaPraticaWhereInput | ProvaPraticaWhereInput[]
    provaId?: IntNullableFilter<"ProvaPratica"> | number | null
    prova?: XOR<ProvaNullableScalarRelationFilter, ProvaWhereInput> | null
    blocosProvas?: BlocoProvaListRelationFilter
    Categoria?: CategoriaListRelationFilter
    Recurso?: RecursoListRelationFilter
  }, "idProvaPratica">

  export type ProvaPraticaOrderByWithAggregationInput = {
    idProvaPratica?: SortOrder
    provaId?: SortOrderInput | SortOrder
    _count?: ProvaPraticaCountOrderByAggregateInput
    _avg?: ProvaPraticaAvgOrderByAggregateInput
    _max?: ProvaPraticaMaxOrderByAggregateInput
    _min?: ProvaPraticaMinOrderByAggregateInput
    _sum?: ProvaPraticaSumOrderByAggregateInput
  }

  export type ProvaPraticaScalarWhereWithAggregatesInput = {
    AND?: ProvaPraticaScalarWhereWithAggregatesInput | ProvaPraticaScalarWhereWithAggregatesInput[]
    OR?: ProvaPraticaScalarWhereWithAggregatesInput[]
    NOT?: ProvaPraticaScalarWhereWithAggregatesInput | ProvaPraticaScalarWhereWithAggregatesInput[]
    idProvaPratica?: IntWithAggregatesFilter<"ProvaPratica"> | number
    provaId?: IntNullableWithAggregatesFilter<"ProvaPratica"> | number | null
  }

  export type BlocoProvaWhereInput = {
    AND?: BlocoProvaWhereInput | BlocoProvaWhereInput[]
    OR?: BlocoProvaWhereInput[]
    NOT?: BlocoProvaWhereInput | BlocoProvaWhereInput[]
    idBloco?: IntFilter<"BlocoProva"> | number
    nomeBloco?: StringFilter<"BlocoProva"> | string
    notaMaximaBloco?: FloatFilter<"BlocoProva"> | number
    provaPraticaId?: IntNullableFilter<"BlocoProva"> | number | null
    ProvaPratica?: XOR<ProvaPraticaNullableScalarRelationFilter, ProvaPraticaWhereInput> | null
    quesitos?: QuesitosListRelationFilter
    Avaliacao?: AvaliacaoListRelationFilter
  }

  export type BlocoProvaOrderByWithRelationInput = {
    idBloco?: SortOrder
    nomeBloco?: SortOrder
    notaMaximaBloco?: SortOrder
    provaPraticaId?: SortOrderInput | SortOrder
    ProvaPratica?: ProvaPraticaOrderByWithRelationInput
    quesitos?: QuesitosOrderByRelationAggregateInput
    Avaliacao?: AvaliacaoOrderByRelationAggregateInput
  }

  export type BlocoProvaWhereUniqueInput = Prisma.AtLeast<{
    idBloco?: number
    AND?: BlocoProvaWhereInput | BlocoProvaWhereInput[]
    OR?: BlocoProvaWhereInput[]
    NOT?: BlocoProvaWhereInput | BlocoProvaWhereInput[]
    nomeBloco?: StringFilter<"BlocoProva"> | string
    notaMaximaBloco?: FloatFilter<"BlocoProva"> | number
    provaPraticaId?: IntNullableFilter<"BlocoProva"> | number | null
    ProvaPratica?: XOR<ProvaPraticaNullableScalarRelationFilter, ProvaPraticaWhereInput> | null
    quesitos?: QuesitosListRelationFilter
    Avaliacao?: AvaliacaoListRelationFilter
  }, "idBloco">

  export type BlocoProvaOrderByWithAggregationInput = {
    idBloco?: SortOrder
    nomeBloco?: SortOrder
    notaMaximaBloco?: SortOrder
    provaPraticaId?: SortOrderInput | SortOrder
    _count?: BlocoProvaCountOrderByAggregateInput
    _avg?: BlocoProvaAvgOrderByAggregateInput
    _max?: BlocoProvaMaxOrderByAggregateInput
    _min?: BlocoProvaMinOrderByAggregateInput
    _sum?: BlocoProvaSumOrderByAggregateInput
  }

  export type BlocoProvaScalarWhereWithAggregatesInput = {
    AND?: BlocoProvaScalarWhereWithAggregatesInput | BlocoProvaScalarWhereWithAggregatesInput[]
    OR?: BlocoProvaScalarWhereWithAggregatesInput[]
    NOT?: BlocoProvaScalarWhereWithAggregatesInput | BlocoProvaScalarWhereWithAggregatesInput[]
    idBloco?: IntWithAggregatesFilter<"BlocoProva"> | number
    nomeBloco?: StringWithAggregatesFilter<"BlocoProva"> | string
    notaMaximaBloco?: FloatWithAggregatesFilter<"BlocoProva"> | number
    provaPraticaId?: IntNullableWithAggregatesFilter<"BlocoProva"> | number | null
  }

  export type QuesitosWhereInput = {
    AND?: QuesitosWhereInput | QuesitosWhereInput[]
    OR?: QuesitosWhereInput[]
    NOT?: QuesitosWhereInput | QuesitosWhereInput[]
    idQuesito?: IntFilter<"Quesitos"> | number
    nomeQuesito?: StringFilter<"Quesitos"> | string
    notaMaximaQuesito?: FloatFilter<"Quesitos"> | number
    danca?: BoolFilter<"Quesitos"> | boolean
    dancaSalaoTradicional?: EnumDancaSalaoTradicionalFilter<"Quesitos"> | $Enums.DancaSalaoTradicional
    blocoProvaIdBloco?: IntNullableFilter<"Quesitos"> | number | null
    provaTeoricaIdprovaTeorica?: IntNullableFilter<"Quesitos"> | number | null
    preferenciaSorteioDancaId?: IntNullableFilter<"Quesitos"> | number | null
    avaliacaoIdAvalicao?: IntNullableFilter<"Quesitos"> | number | null
    BlocoProva?: XOR<BlocoProvaNullableScalarRelationFilter, BlocoProvaWhereInput> | null
    ProvaTeorica?: XOR<ProvaTeoricaNullableScalarRelationFilter, ProvaTeoricaWhereInput> | null
    subeQuesitos?: SubQuesitosListRelationFilter
    recursos?: RecursoListRelationFilter
    PreferenciaSorteioDanca?: XOR<PreferenciaSorteioDancaNullableScalarRelationFilter, PreferenciaSorteioDancaWhereInput> | null
    Avaliacao?: XOR<AvaliacaoNullableScalarRelationFilter, AvaliacaoWhereInput> | null
  }

  export type QuesitosOrderByWithRelationInput = {
    idQuesito?: SortOrder
    nomeQuesito?: SortOrder
    notaMaximaQuesito?: SortOrder
    danca?: SortOrder
    dancaSalaoTradicional?: SortOrder
    blocoProvaIdBloco?: SortOrderInput | SortOrder
    provaTeoricaIdprovaTeorica?: SortOrderInput | SortOrder
    preferenciaSorteioDancaId?: SortOrderInput | SortOrder
    avaliacaoIdAvalicao?: SortOrderInput | SortOrder
    BlocoProva?: BlocoProvaOrderByWithRelationInput
    ProvaTeorica?: ProvaTeoricaOrderByWithRelationInput
    subeQuesitos?: SubQuesitosOrderByRelationAggregateInput
    recursos?: RecursoOrderByRelationAggregateInput
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaOrderByWithRelationInput
    Avaliacao?: AvaliacaoOrderByWithRelationInput
  }

  export type QuesitosWhereUniqueInput = Prisma.AtLeast<{
    idQuesito?: number
    AND?: QuesitosWhereInput | QuesitosWhereInput[]
    OR?: QuesitosWhereInput[]
    NOT?: QuesitosWhereInput | QuesitosWhereInput[]
    nomeQuesito?: StringFilter<"Quesitos"> | string
    notaMaximaQuesito?: FloatFilter<"Quesitos"> | number
    danca?: BoolFilter<"Quesitos"> | boolean
    dancaSalaoTradicional?: EnumDancaSalaoTradicionalFilter<"Quesitos"> | $Enums.DancaSalaoTradicional
    blocoProvaIdBloco?: IntNullableFilter<"Quesitos"> | number | null
    provaTeoricaIdprovaTeorica?: IntNullableFilter<"Quesitos"> | number | null
    preferenciaSorteioDancaId?: IntNullableFilter<"Quesitos"> | number | null
    avaliacaoIdAvalicao?: IntNullableFilter<"Quesitos"> | number | null
    BlocoProva?: XOR<BlocoProvaNullableScalarRelationFilter, BlocoProvaWhereInput> | null
    ProvaTeorica?: XOR<ProvaTeoricaNullableScalarRelationFilter, ProvaTeoricaWhereInput> | null
    subeQuesitos?: SubQuesitosListRelationFilter
    recursos?: RecursoListRelationFilter
    PreferenciaSorteioDanca?: XOR<PreferenciaSorteioDancaNullableScalarRelationFilter, PreferenciaSorteioDancaWhereInput> | null
    Avaliacao?: XOR<AvaliacaoNullableScalarRelationFilter, AvaliacaoWhereInput> | null
  }, "idQuesito">

  export type QuesitosOrderByWithAggregationInput = {
    idQuesito?: SortOrder
    nomeQuesito?: SortOrder
    notaMaximaQuesito?: SortOrder
    danca?: SortOrder
    dancaSalaoTradicional?: SortOrder
    blocoProvaIdBloco?: SortOrderInput | SortOrder
    provaTeoricaIdprovaTeorica?: SortOrderInput | SortOrder
    preferenciaSorteioDancaId?: SortOrderInput | SortOrder
    avaliacaoIdAvalicao?: SortOrderInput | SortOrder
    _count?: QuesitosCountOrderByAggregateInput
    _avg?: QuesitosAvgOrderByAggregateInput
    _max?: QuesitosMaxOrderByAggregateInput
    _min?: QuesitosMinOrderByAggregateInput
    _sum?: QuesitosSumOrderByAggregateInput
  }

  export type QuesitosScalarWhereWithAggregatesInput = {
    AND?: QuesitosScalarWhereWithAggregatesInput | QuesitosScalarWhereWithAggregatesInput[]
    OR?: QuesitosScalarWhereWithAggregatesInput[]
    NOT?: QuesitosScalarWhereWithAggregatesInput | QuesitosScalarWhereWithAggregatesInput[]
    idQuesito?: IntWithAggregatesFilter<"Quesitos"> | number
    nomeQuesito?: StringWithAggregatesFilter<"Quesitos"> | string
    notaMaximaQuesito?: FloatWithAggregatesFilter<"Quesitos"> | number
    danca?: BoolWithAggregatesFilter<"Quesitos"> | boolean
    dancaSalaoTradicional?: EnumDancaSalaoTradicionalWithAggregatesFilter<"Quesitos"> | $Enums.DancaSalaoTradicional
    blocoProvaIdBloco?: IntNullableWithAggregatesFilter<"Quesitos"> | number | null
    provaTeoricaIdprovaTeorica?: IntNullableWithAggregatesFilter<"Quesitos"> | number | null
    preferenciaSorteioDancaId?: IntNullableWithAggregatesFilter<"Quesitos"> | number | null
    avaliacaoIdAvalicao?: IntNullableWithAggregatesFilter<"Quesitos"> | number | null
  }

  export type SubQuesitosWhereInput = {
    AND?: SubQuesitosWhereInput | SubQuesitosWhereInput[]
    OR?: SubQuesitosWhereInput[]
    NOT?: SubQuesitosWhereInput | SubQuesitosWhereInput[]
    idSubequestios?: IntFilter<"SubQuesitos"> | number
    nomeSubquesito?: StringFilter<"SubQuesitos"> | string
    notaSubequesito?: FloatFilter<"SubQuesitos"> | number
    quesitoId?: IntFilter<"SubQuesitos"> | number
    Quesito?: XOR<QuesitosScalarRelationFilter, QuesitosWhereInput>
    subequesitosFilhos?: SubQuesitosListRelationFilter
    subequesitosPai?: SubQuesitosListRelationFilter
  }

  export type SubQuesitosOrderByWithRelationInput = {
    idSubequestios?: SortOrder
    nomeSubquesito?: SortOrder
    notaSubequesito?: SortOrder
    quesitoId?: SortOrder
    Quesito?: QuesitosOrderByWithRelationInput
    subequesitosFilhos?: SubQuesitosOrderByRelationAggregateInput
    subequesitosPai?: SubQuesitosOrderByRelationAggregateInput
  }

  export type SubQuesitosWhereUniqueInput = Prisma.AtLeast<{
    idSubequestios?: number
    AND?: SubQuesitosWhereInput | SubQuesitosWhereInput[]
    OR?: SubQuesitosWhereInput[]
    NOT?: SubQuesitosWhereInput | SubQuesitosWhereInput[]
    nomeSubquesito?: StringFilter<"SubQuesitos"> | string
    notaSubequesito?: FloatFilter<"SubQuesitos"> | number
    quesitoId?: IntFilter<"SubQuesitos"> | number
    Quesito?: XOR<QuesitosScalarRelationFilter, QuesitosWhereInput>
    subequesitosFilhos?: SubQuesitosListRelationFilter
    subequesitosPai?: SubQuesitosListRelationFilter
  }, "idSubequestios">

  export type SubQuesitosOrderByWithAggregationInput = {
    idSubequestios?: SortOrder
    nomeSubquesito?: SortOrder
    notaSubequesito?: SortOrder
    quesitoId?: SortOrder
    _count?: SubQuesitosCountOrderByAggregateInput
    _avg?: SubQuesitosAvgOrderByAggregateInput
    _max?: SubQuesitosMaxOrderByAggregateInput
    _min?: SubQuesitosMinOrderByAggregateInput
    _sum?: SubQuesitosSumOrderByAggregateInput
  }

  export type SubQuesitosScalarWhereWithAggregatesInput = {
    AND?: SubQuesitosScalarWhereWithAggregatesInput | SubQuesitosScalarWhereWithAggregatesInput[]
    OR?: SubQuesitosScalarWhereWithAggregatesInput[]
    NOT?: SubQuesitosScalarWhereWithAggregatesInput | SubQuesitosScalarWhereWithAggregatesInput[]
    idSubequestios?: IntWithAggregatesFilter<"SubQuesitos"> | number
    nomeSubquesito?: StringWithAggregatesFilter<"SubQuesitos"> | string
    notaSubequesito?: FloatWithAggregatesFilter<"SubQuesitos"> | number
    quesitoId?: IntWithAggregatesFilter<"SubQuesitos"> | number
  }

  export type RecursoWhereInput = {
    AND?: RecursoWhereInput | RecursoWhereInput[]
    OR?: RecursoWhereInput[]
    NOT?: RecursoWhereInput | RecursoWhereInput[]
    idRecurso?: IntFilter<"Recurso"> | number
    nomeRecurso?: StringFilter<"Recurso"> | string
    justificativa?: StringFilter<"Recurso"> | string
    status?: BoolFilter<"Recurso"> | boolean
    dataRecurso?: DateTimeFilter<"Recurso"> | Date | string
    arquivos?: BytesFilter<"Recurso"> | Bytes
    candidato?: IntFilter<"Recurso"> | number
    avaliador?: IntFilter<"Recurso"> | number
    quesitoRecurso?: IntFilter<"Recurso"> | number
    provaTeoricaIdprovaTeorica?: IntNullableFilter<"Recurso"> | number | null
    provaPraticaIdProvaPratica?: IntNullableFilter<"Recurso"> | number | null
    provaIdProva?: IntNullableFilter<"Recurso"> | number | null
    Candidato?: XOR<CandidatoScalarRelationFilter, CandidatoWhereInput>
    Usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
    Quesito?: XOR<QuesitosScalarRelationFilter, QuesitosWhereInput>
    ProvaTeorica?: XOR<ProvaTeoricaNullableScalarRelationFilter, ProvaTeoricaWhereInput> | null
    ProvaPratica?: XOR<ProvaPraticaNullableScalarRelationFilter, ProvaPraticaWhereInput> | null
    Prova?: XOR<ProvaNullableScalarRelationFilter, ProvaWhereInput> | null
  }

  export type RecursoOrderByWithRelationInput = {
    idRecurso?: SortOrder
    nomeRecurso?: SortOrder
    justificativa?: SortOrder
    status?: SortOrder
    dataRecurso?: SortOrder
    arquivos?: SortOrder
    candidato?: SortOrder
    avaliador?: SortOrder
    quesitoRecurso?: SortOrder
    provaTeoricaIdprovaTeorica?: SortOrderInput | SortOrder
    provaPraticaIdProvaPratica?: SortOrderInput | SortOrder
    provaIdProva?: SortOrderInput | SortOrder
    Candidato?: CandidatoOrderByWithRelationInput
    Usuario?: UsuarioOrderByWithRelationInput
    Quesito?: QuesitosOrderByWithRelationInput
    ProvaTeorica?: ProvaTeoricaOrderByWithRelationInput
    ProvaPratica?: ProvaPraticaOrderByWithRelationInput
    Prova?: ProvaOrderByWithRelationInput
  }

  export type RecursoWhereUniqueInput = Prisma.AtLeast<{
    idRecurso?: number
    AND?: RecursoWhereInput | RecursoWhereInput[]
    OR?: RecursoWhereInput[]
    NOT?: RecursoWhereInput | RecursoWhereInput[]
    nomeRecurso?: StringFilter<"Recurso"> | string
    justificativa?: StringFilter<"Recurso"> | string
    status?: BoolFilter<"Recurso"> | boolean
    dataRecurso?: DateTimeFilter<"Recurso"> | Date | string
    arquivos?: BytesFilter<"Recurso"> | Bytes
    candidato?: IntFilter<"Recurso"> | number
    avaliador?: IntFilter<"Recurso"> | number
    quesitoRecurso?: IntFilter<"Recurso"> | number
    provaTeoricaIdprovaTeorica?: IntNullableFilter<"Recurso"> | number | null
    provaPraticaIdProvaPratica?: IntNullableFilter<"Recurso"> | number | null
    provaIdProva?: IntNullableFilter<"Recurso"> | number | null
    Candidato?: XOR<CandidatoScalarRelationFilter, CandidatoWhereInput>
    Usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
    Quesito?: XOR<QuesitosScalarRelationFilter, QuesitosWhereInput>
    ProvaTeorica?: XOR<ProvaTeoricaNullableScalarRelationFilter, ProvaTeoricaWhereInput> | null
    ProvaPratica?: XOR<ProvaPraticaNullableScalarRelationFilter, ProvaPraticaWhereInput> | null
    Prova?: XOR<ProvaNullableScalarRelationFilter, ProvaWhereInput> | null
  }, "idRecurso">

  export type RecursoOrderByWithAggregationInput = {
    idRecurso?: SortOrder
    nomeRecurso?: SortOrder
    justificativa?: SortOrder
    status?: SortOrder
    dataRecurso?: SortOrder
    arquivos?: SortOrder
    candidato?: SortOrder
    avaliador?: SortOrder
    quesitoRecurso?: SortOrder
    provaTeoricaIdprovaTeorica?: SortOrderInput | SortOrder
    provaPraticaIdProvaPratica?: SortOrderInput | SortOrder
    provaIdProva?: SortOrderInput | SortOrder
    _count?: RecursoCountOrderByAggregateInput
    _avg?: RecursoAvgOrderByAggregateInput
    _max?: RecursoMaxOrderByAggregateInput
    _min?: RecursoMinOrderByAggregateInput
    _sum?: RecursoSumOrderByAggregateInput
  }

  export type RecursoScalarWhereWithAggregatesInput = {
    AND?: RecursoScalarWhereWithAggregatesInput | RecursoScalarWhereWithAggregatesInput[]
    OR?: RecursoScalarWhereWithAggregatesInput[]
    NOT?: RecursoScalarWhereWithAggregatesInput | RecursoScalarWhereWithAggregatesInput[]
    idRecurso?: IntWithAggregatesFilter<"Recurso"> | number
    nomeRecurso?: StringWithAggregatesFilter<"Recurso"> | string
    justificativa?: StringWithAggregatesFilter<"Recurso"> | string
    status?: BoolWithAggregatesFilter<"Recurso"> | boolean
    dataRecurso?: DateTimeWithAggregatesFilter<"Recurso"> | Date | string
    arquivos?: BytesWithAggregatesFilter<"Recurso"> | Bytes
    candidato?: IntWithAggregatesFilter<"Recurso"> | number
    avaliador?: IntWithAggregatesFilter<"Recurso"> | number
    quesitoRecurso?: IntWithAggregatesFilter<"Recurso"> | number
    provaTeoricaIdprovaTeorica?: IntNullableWithAggregatesFilter<"Recurso"> | number | null
    provaPraticaIdProvaPratica?: IntNullableWithAggregatesFilter<"Recurso"> | number | null
    provaIdProva?: IntNullableWithAggregatesFilter<"Recurso"> | number | null
  }

  export type SorteioDancaWhereInput = {
    AND?: SorteioDancaWhereInput | SorteioDancaWhereInput[]
    OR?: SorteioDancaWhereInput[]
    NOT?: SorteioDancaWhereInput | SorteioDancaWhereInput[]
    idSorteio?: IntFilter<"SorteioDanca"> | number
    resultadoSorteio?: IntFilter<"SorteioDanca"> | number
    dataSorteio?: DateTimeFilter<"SorteioDanca"> | Date | string
    tipoDanca?: EnumDancaSalaoTradicionalFilter<"SorteioDanca"> | $Enums.DancaSalaoTradicional
    candidatoId?: IntFilter<"SorteioDanca"> | number
    usuarioId?: IntFilter<"SorteioDanca"> | number
    preferenciaSorteioDancaIds?: PreferenciaSorteioDancaListRelationFilter
    Candidato?: XOR<CandidatoScalarRelationFilter, CandidatoWhereInput>
    Usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }

  export type SorteioDancaOrderByWithRelationInput = {
    idSorteio?: SortOrder
    resultadoSorteio?: SortOrder
    dataSorteio?: SortOrder
    tipoDanca?: SortOrder
    candidatoId?: SortOrder
    usuarioId?: SortOrder
    preferenciaSorteioDancaIds?: PreferenciaSorteioDancaOrderByRelationAggregateInput
    Candidato?: CandidatoOrderByWithRelationInput
    Usuario?: UsuarioOrderByWithRelationInput
  }

  export type SorteioDancaWhereUniqueInput = Prisma.AtLeast<{
    idSorteio?: number
    AND?: SorteioDancaWhereInput | SorteioDancaWhereInput[]
    OR?: SorteioDancaWhereInput[]
    NOT?: SorteioDancaWhereInput | SorteioDancaWhereInput[]
    resultadoSorteio?: IntFilter<"SorteioDanca"> | number
    dataSorteio?: DateTimeFilter<"SorteioDanca"> | Date | string
    tipoDanca?: EnumDancaSalaoTradicionalFilter<"SorteioDanca"> | $Enums.DancaSalaoTradicional
    candidatoId?: IntFilter<"SorteioDanca"> | number
    usuarioId?: IntFilter<"SorteioDanca"> | number
    preferenciaSorteioDancaIds?: PreferenciaSorteioDancaListRelationFilter
    Candidato?: XOR<CandidatoScalarRelationFilter, CandidatoWhereInput>
    Usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }, "idSorteio">

  export type SorteioDancaOrderByWithAggregationInput = {
    idSorteio?: SortOrder
    resultadoSorteio?: SortOrder
    dataSorteio?: SortOrder
    tipoDanca?: SortOrder
    candidatoId?: SortOrder
    usuarioId?: SortOrder
    _count?: SorteioDancaCountOrderByAggregateInput
    _avg?: SorteioDancaAvgOrderByAggregateInput
    _max?: SorteioDancaMaxOrderByAggregateInput
    _min?: SorteioDancaMinOrderByAggregateInput
    _sum?: SorteioDancaSumOrderByAggregateInput
  }

  export type SorteioDancaScalarWhereWithAggregatesInput = {
    AND?: SorteioDancaScalarWhereWithAggregatesInput | SorteioDancaScalarWhereWithAggregatesInput[]
    OR?: SorteioDancaScalarWhereWithAggregatesInput[]
    NOT?: SorteioDancaScalarWhereWithAggregatesInput | SorteioDancaScalarWhereWithAggregatesInput[]
    idSorteio?: IntWithAggregatesFilter<"SorteioDanca"> | number
    resultadoSorteio?: IntWithAggregatesFilter<"SorteioDanca"> | number
    dataSorteio?: DateTimeWithAggregatesFilter<"SorteioDanca"> | Date | string
    tipoDanca?: EnumDancaSalaoTradicionalWithAggregatesFilter<"SorteioDanca"> | $Enums.DancaSalaoTradicional
    candidatoId?: IntWithAggregatesFilter<"SorteioDanca"> | number
    usuarioId?: IntWithAggregatesFilter<"SorteioDanca"> | number
  }

  export type FichaCandidatoWhereInput = {
    AND?: FichaCandidatoWhereInput | FichaCandidatoWhereInput[]
    OR?: FichaCandidatoWhereInput[]
    NOT?: FichaCandidatoWhereInput | FichaCandidatoWhereInput[]
    idFicha?: IntFilter<"FichaCandidato"> | number
    candidatoId?: IntFilter<"FichaCandidato"> | number
    notaCandidato?: FloatFilter<"FichaCandidato"> | number
    provaId?: IntFilter<"FichaCandidato"> | number
    concursoId?: IntFilter<"FichaCandidato"> | number
    categoriaId?: IntFilter<"FichaCandidato"> | number
    anexoTermodeCiencia?: BytesFilter<"FichaCandidato"> | Bytes
    dataTermo?: DateTimeFilter<"FichaCandidato"> | Date | string
    numAcertosProvaTeorica?: IntFilter<"FichaCandidato"> | number
    anexoGabarito?: BytesFilter<"FichaCandidato"> | Bytes
    notaRedacao?: FloatFilter<"FichaCandidato"> | number
    anexoRedacao?: BytesFilter<"FichaCandidato"> | Bytes
    anexoProvaPratica?: BytesFilter<"FichaCandidato"> | Bytes
    avaliacoes?: AvaliacaoListRelationFilter
  }

  export type FichaCandidatoOrderByWithRelationInput = {
    idFicha?: SortOrder
    candidatoId?: SortOrder
    notaCandidato?: SortOrder
    provaId?: SortOrder
    concursoId?: SortOrder
    categoriaId?: SortOrder
    anexoTermodeCiencia?: SortOrder
    dataTermo?: SortOrder
    numAcertosProvaTeorica?: SortOrder
    anexoGabarito?: SortOrder
    notaRedacao?: SortOrder
    anexoRedacao?: SortOrder
    anexoProvaPratica?: SortOrder
    avaliacoes?: AvaliacaoOrderByRelationAggregateInput
  }

  export type FichaCandidatoWhereUniqueInput = Prisma.AtLeast<{
    idFicha?: number
    AND?: FichaCandidatoWhereInput | FichaCandidatoWhereInput[]
    OR?: FichaCandidatoWhereInput[]
    NOT?: FichaCandidatoWhereInput | FichaCandidatoWhereInput[]
    candidatoId?: IntFilter<"FichaCandidato"> | number
    notaCandidato?: FloatFilter<"FichaCandidato"> | number
    provaId?: IntFilter<"FichaCandidato"> | number
    concursoId?: IntFilter<"FichaCandidato"> | number
    categoriaId?: IntFilter<"FichaCandidato"> | number
    anexoTermodeCiencia?: BytesFilter<"FichaCandidato"> | Bytes
    dataTermo?: DateTimeFilter<"FichaCandidato"> | Date | string
    numAcertosProvaTeorica?: IntFilter<"FichaCandidato"> | number
    anexoGabarito?: BytesFilter<"FichaCandidato"> | Bytes
    notaRedacao?: FloatFilter<"FichaCandidato"> | number
    anexoRedacao?: BytesFilter<"FichaCandidato"> | Bytes
    anexoProvaPratica?: BytesFilter<"FichaCandidato"> | Bytes
    avaliacoes?: AvaliacaoListRelationFilter
  }, "idFicha">

  export type FichaCandidatoOrderByWithAggregationInput = {
    idFicha?: SortOrder
    candidatoId?: SortOrder
    notaCandidato?: SortOrder
    provaId?: SortOrder
    concursoId?: SortOrder
    categoriaId?: SortOrder
    anexoTermodeCiencia?: SortOrder
    dataTermo?: SortOrder
    numAcertosProvaTeorica?: SortOrder
    anexoGabarito?: SortOrder
    notaRedacao?: SortOrder
    anexoRedacao?: SortOrder
    anexoProvaPratica?: SortOrder
    _count?: FichaCandidatoCountOrderByAggregateInput
    _avg?: FichaCandidatoAvgOrderByAggregateInput
    _max?: FichaCandidatoMaxOrderByAggregateInput
    _min?: FichaCandidatoMinOrderByAggregateInput
    _sum?: FichaCandidatoSumOrderByAggregateInput
  }

  export type FichaCandidatoScalarWhereWithAggregatesInput = {
    AND?: FichaCandidatoScalarWhereWithAggregatesInput | FichaCandidatoScalarWhereWithAggregatesInput[]
    OR?: FichaCandidatoScalarWhereWithAggregatesInput[]
    NOT?: FichaCandidatoScalarWhereWithAggregatesInput | FichaCandidatoScalarWhereWithAggregatesInput[]
    idFicha?: IntWithAggregatesFilter<"FichaCandidato"> | number
    candidatoId?: IntWithAggregatesFilter<"FichaCandidato"> | number
    notaCandidato?: FloatWithAggregatesFilter<"FichaCandidato"> | number
    provaId?: IntWithAggregatesFilter<"FichaCandidato"> | number
    concursoId?: IntWithAggregatesFilter<"FichaCandidato"> | number
    categoriaId?: IntWithAggregatesFilter<"FichaCandidato"> | number
    anexoTermodeCiencia?: BytesWithAggregatesFilter<"FichaCandidato"> | Bytes
    dataTermo?: DateTimeWithAggregatesFilter<"FichaCandidato"> | Date | string
    numAcertosProvaTeorica?: IntWithAggregatesFilter<"FichaCandidato"> | number
    anexoGabarito?: BytesWithAggregatesFilter<"FichaCandidato"> | Bytes
    notaRedacao?: FloatWithAggregatesFilter<"FichaCandidato"> | number
    anexoRedacao?: BytesWithAggregatesFilter<"FichaCandidato"> | Bytes
    anexoProvaPratica?: BytesWithAggregatesFilter<"FichaCandidato"> | Bytes
  }

  export type CandidatoCreateInput = {
    nomeCompleto: string
    cidade: string
    estado: string
    numCarteirinha: string
    CPF: string
    RG: string
    endereco: string
    numEndereco: number
    bairro: string
    escolaridade: string
    filiacao: string
    ProvaCampeiraEsportiva?: $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: Bytes | null
    anexoCarteirinha?: Bytes | null
    anexoEscolaridade?: Bytes | null
    anexoResidencia?: Bytes | null
    anexoAtaConcurso?: Bytes | null
    fichaInscricao?: Bytes | null
    anexoTermoCandidato?: Bytes | null
    anexoRelatorioVivencia?: Bytes | null
    anexoResponsavel?: Bytes | null
    anexoProvaEsportivaCampeira?: Bytes | null
    CTG: CTGCreateNestedOneWithoutCandidatoInput
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaCreateNestedManyWithoutCandidatoInput
    Categoria: CategoriaCreateNestedOneWithoutCandidatosInput
    avalicoes?: AvaliacaoCreateNestedManyWithoutCandidatoInput
    sorteioDanca?: SorteioDancaCreateNestedManyWithoutCandidatoInput
    Recurso?: RecursoCreateNestedManyWithoutCandidatoInput
    Concurso?: ConcursoCreateNestedOneWithoutCandidatosInput
  }

  export type CandidatoUncheckedCreateInput = {
    idCandidato?: number
    nomeCompleto: string
    cidade: string
    estado: string
    CTGId: number
    numCarteirinha: string
    CPF: string
    RG: string
    endereco: string
    numEndereco: number
    bairro: string
    escolaridade: string
    filiacao: string
    ProvaCampeiraEsportiva?: $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: Bytes | null
    anexoCarteirinha?: Bytes | null
    anexoEscolaridade?: Bytes | null
    anexoResidencia?: Bytes | null
    anexoAtaConcurso?: Bytes | null
    fichaInscricao?: Bytes | null
    anexoTermoCandidato?: Bytes | null
    anexoRelatorioVivencia?: Bytes | null
    anexoResponsavel?: Bytes | null
    anexoProvaEsportivaCampeira?: Bytes | null
    categoriaId: number
    concursoIdConcurso?: number | null
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaUncheckedCreateNestedManyWithoutCandidatoInput
    avalicoes?: AvaliacaoUncheckedCreateNestedManyWithoutCandidatoInput
    sorteioDanca?: SorteioDancaUncheckedCreateNestedManyWithoutCandidatoInput
    Recurso?: RecursoUncheckedCreateNestedManyWithoutCandidatoInput
  }

  export type CandidatoUpdateInput = {
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    numCarteirinha?: StringFieldUpdateOperationsInput | string
    CPF?: StringFieldUpdateOperationsInput | string
    RG?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    numEndereco?: IntFieldUpdateOperationsInput | number
    bairro?: StringFieldUpdateOperationsInput | string
    escolaridade?: StringFieldUpdateOperationsInput | string
    filiacao?: StringFieldUpdateOperationsInput | string
    ProvaCampeiraEsportiva?: NullableEnumProvaCampeiraEsportivaFieldUpdateOperationsInput | $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoCarteirinha?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoEscolaridade?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoResidencia?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoAtaConcurso?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    fichaInscricao?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoTermoCandidato?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoRelatorioVivencia?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoResponsavel?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoProvaEsportivaCampeira?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    CTG?: CTGUpdateOneRequiredWithoutCandidatoNestedInput
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaUpdateManyWithoutCandidatoNestedInput
    Categoria?: CategoriaUpdateOneRequiredWithoutCandidatosNestedInput
    avalicoes?: AvaliacaoUpdateManyWithoutCandidatoNestedInput
    sorteioDanca?: SorteioDancaUpdateManyWithoutCandidatoNestedInput
    Recurso?: RecursoUpdateManyWithoutCandidatoNestedInput
    Concurso?: ConcursoUpdateOneWithoutCandidatosNestedInput
  }

  export type CandidatoUncheckedUpdateInput = {
    idCandidato?: IntFieldUpdateOperationsInput | number
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    CTGId?: IntFieldUpdateOperationsInput | number
    numCarteirinha?: StringFieldUpdateOperationsInput | string
    CPF?: StringFieldUpdateOperationsInput | string
    RG?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    numEndereco?: IntFieldUpdateOperationsInput | number
    bairro?: StringFieldUpdateOperationsInput | string
    escolaridade?: StringFieldUpdateOperationsInput | string
    filiacao?: StringFieldUpdateOperationsInput | string
    ProvaCampeiraEsportiva?: NullableEnumProvaCampeiraEsportivaFieldUpdateOperationsInput | $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoCarteirinha?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoEscolaridade?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoResidencia?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoAtaConcurso?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    fichaInscricao?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoTermoCandidato?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoRelatorioVivencia?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoResponsavel?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoProvaEsportivaCampeira?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    categoriaId?: IntFieldUpdateOperationsInput | number
    concursoIdConcurso?: NullableIntFieldUpdateOperationsInput | number | null
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaUncheckedUpdateManyWithoutCandidatoNestedInput
    avalicoes?: AvaliacaoUncheckedUpdateManyWithoutCandidatoNestedInput
    sorteioDanca?: SorteioDancaUncheckedUpdateManyWithoutCandidatoNestedInput
    Recurso?: RecursoUncheckedUpdateManyWithoutCandidatoNestedInput
  }

  export type CandidatoCreateManyInput = {
    idCandidato?: number
    nomeCompleto: string
    cidade: string
    estado: string
    CTGId: number
    numCarteirinha: string
    CPF: string
    RG: string
    endereco: string
    numEndereco: number
    bairro: string
    escolaridade: string
    filiacao: string
    ProvaCampeiraEsportiva?: $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: Bytes | null
    anexoCarteirinha?: Bytes | null
    anexoEscolaridade?: Bytes | null
    anexoResidencia?: Bytes | null
    anexoAtaConcurso?: Bytes | null
    fichaInscricao?: Bytes | null
    anexoTermoCandidato?: Bytes | null
    anexoRelatorioVivencia?: Bytes | null
    anexoResponsavel?: Bytes | null
    anexoProvaEsportivaCampeira?: Bytes | null
    categoriaId: number
    concursoIdConcurso?: number | null
  }

  export type CandidatoUpdateManyMutationInput = {
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    numCarteirinha?: StringFieldUpdateOperationsInput | string
    CPF?: StringFieldUpdateOperationsInput | string
    RG?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    numEndereco?: IntFieldUpdateOperationsInput | number
    bairro?: StringFieldUpdateOperationsInput | string
    escolaridade?: StringFieldUpdateOperationsInput | string
    filiacao?: StringFieldUpdateOperationsInput | string
    ProvaCampeiraEsportiva?: NullableEnumProvaCampeiraEsportivaFieldUpdateOperationsInput | $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoCarteirinha?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoEscolaridade?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoResidencia?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoAtaConcurso?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    fichaInscricao?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoTermoCandidato?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoRelatorioVivencia?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoResponsavel?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoProvaEsportivaCampeira?: NullableBytesFieldUpdateOperationsInput | Bytes | null
  }

  export type CandidatoUncheckedUpdateManyInput = {
    idCandidato?: IntFieldUpdateOperationsInput | number
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    CTGId?: IntFieldUpdateOperationsInput | number
    numCarteirinha?: StringFieldUpdateOperationsInput | string
    CPF?: StringFieldUpdateOperationsInput | string
    RG?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    numEndereco?: IntFieldUpdateOperationsInput | number
    bairro?: StringFieldUpdateOperationsInput | string
    escolaridade?: StringFieldUpdateOperationsInput | string
    filiacao?: StringFieldUpdateOperationsInput | string
    ProvaCampeiraEsportiva?: NullableEnumProvaCampeiraEsportivaFieldUpdateOperationsInput | $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoCarteirinha?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoEscolaridade?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoResidencia?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoAtaConcurso?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    fichaInscricao?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoTermoCandidato?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoRelatorioVivencia?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoResponsavel?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoProvaEsportivaCampeira?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    categoriaId?: IntFieldUpdateOperationsInput | number
    concursoIdConcurso?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UsuarioCreateInput = {
    nomeCompleto: string
    cidade: string
    estado: string
    numCarteirinha: string
    login: string
    senha: string
    funcao: $Enums.Funcao
    credenciamento?: $Enums.Credenciamento
    numCredenciamento?: number | null
    comissaoUsuarioId?: number | null
    CTG: CTGCreateNestedOneWithoutUsuarioInput
    ComissaoUsuario?: ComissaoUsuarioCreateNestedOneWithoutUsuariosInput
    avalicoes?: AvaliacaoCreateNestedManyWithoutUsuarioInput
    recursos?: RecursoCreateNestedManyWithoutUsuarioInput
    sorteioDanca?: SorteioDancaCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateInput = {
    idUsuario?: number
    nomeCompleto: string
    cidade: string
    estado: string
    CTGId: number
    numCarteirinha: string
    login: string
    senha: string
    funcao: $Enums.Funcao
    credenciamento?: $Enums.Credenciamento
    numCredenciamento?: number | null
    comissaoUsuarioId?: number | null
    ComissaoUsuario?: ComissaoUsuarioUncheckedCreateNestedOneWithoutUsuariosInput
    avalicoes?: AvaliacaoUncheckedCreateNestedManyWithoutUsuarioInput
    recursos?: RecursoUncheckedCreateNestedManyWithoutUsuarioInput
    sorteioDanca?: SorteioDancaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUpdateInput = {
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    numCarteirinha?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    funcao?: EnumFuncaoFieldUpdateOperationsInput | $Enums.Funcao
    credenciamento?: EnumCredenciamentoFieldUpdateOperationsInput | $Enums.Credenciamento
    numCredenciamento?: NullableIntFieldUpdateOperationsInput | number | null
    comissaoUsuarioId?: NullableIntFieldUpdateOperationsInput | number | null
    CTG?: CTGUpdateOneRequiredWithoutUsuarioNestedInput
    ComissaoUsuario?: ComissaoUsuarioUpdateOneWithoutUsuariosNestedInput
    avalicoes?: AvaliacaoUpdateManyWithoutUsuarioNestedInput
    recursos?: RecursoUpdateManyWithoutUsuarioNestedInput
    sorteioDanca?: SorteioDancaUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateInput = {
    idUsuario?: IntFieldUpdateOperationsInput | number
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    CTGId?: IntFieldUpdateOperationsInput | number
    numCarteirinha?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    funcao?: EnumFuncaoFieldUpdateOperationsInput | $Enums.Funcao
    credenciamento?: EnumCredenciamentoFieldUpdateOperationsInput | $Enums.Credenciamento
    numCredenciamento?: NullableIntFieldUpdateOperationsInput | number | null
    comissaoUsuarioId?: NullableIntFieldUpdateOperationsInput | number | null
    ComissaoUsuario?: ComissaoUsuarioUncheckedUpdateOneWithoutUsuariosNestedInput
    avalicoes?: AvaliacaoUncheckedUpdateManyWithoutUsuarioNestedInput
    recursos?: RecursoUncheckedUpdateManyWithoutUsuarioNestedInput
    sorteioDanca?: SorteioDancaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioCreateManyInput = {
    idUsuario?: number
    nomeCompleto: string
    cidade: string
    estado: string
    CTGId: number
    numCarteirinha: string
    login: string
    senha: string
    funcao: $Enums.Funcao
    credenciamento?: $Enums.Credenciamento
    numCredenciamento?: number | null
    comissaoUsuarioId?: number | null
  }

  export type UsuarioUpdateManyMutationInput = {
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    numCarteirinha?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    funcao?: EnumFuncaoFieldUpdateOperationsInput | $Enums.Funcao
    credenciamento?: EnumCredenciamentoFieldUpdateOperationsInput | $Enums.Credenciamento
    numCredenciamento?: NullableIntFieldUpdateOperationsInput | number | null
    comissaoUsuarioId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UsuarioUncheckedUpdateManyInput = {
    idUsuario?: IntFieldUpdateOperationsInput | number
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    CTGId?: IntFieldUpdateOperationsInput | number
    numCarteirinha?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    funcao?: EnumFuncaoFieldUpdateOperationsInput | $Enums.Funcao
    credenciamento?: EnumCredenciamentoFieldUpdateOperationsInput | $Enums.Credenciamento
    numCredenciamento?: NullableIntFieldUpdateOperationsInput | number | null
    comissaoUsuarioId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CTGCreateInput = {
    nomeCTG: string
    RT: RTCreateNestedOneWithoutCTGsInput
    Usuario?: UsuarioCreateNestedManyWithoutCTGInput
    Candidato?: CandidatoCreateNestedManyWithoutCTGInput
  }

  export type CTGUncheckedCreateInput = {
    idCTG?: number
    nomeCTG: string
    RTid: number
    Usuario?: UsuarioUncheckedCreateNestedManyWithoutCTGInput
    Candidato?: CandidatoUncheckedCreateNestedManyWithoutCTGInput
  }

  export type CTGUpdateInput = {
    nomeCTG?: StringFieldUpdateOperationsInput | string
    RT?: RTUpdateOneRequiredWithoutCTGsNestedInput
    Usuario?: UsuarioUpdateManyWithoutCTGNestedInput
    Candidato?: CandidatoUpdateManyWithoutCTGNestedInput
  }

  export type CTGUncheckedUpdateInput = {
    idCTG?: IntFieldUpdateOperationsInput | number
    nomeCTG?: StringFieldUpdateOperationsInput | string
    RTid?: IntFieldUpdateOperationsInput | number
    Usuario?: UsuarioUncheckedUpdateManyWithoutCTGNestedInput
    Candidato?: CandidatoUncheckedUpdateManyWithoutCTGNestedInput
  }

  export type CTGCreateManyInput = {
    idCTG?: number
    nomeCTG: string
    RTid: number
  }

  export type CTGUpdateManyMutationInput = {
    nomeCTG?: StringFieldUpdateOperationsInput | string
  }

  export type CTGUncheckedUpdateManyInput = {
    idCTG?: IntFieldUpdateOperationsInput | number
    nomeCTG?: StringFieldUpdateOperationsInput | string
    RTid?: IntFieldUpdateOperationsInput | number
  }

  export type RTCreateInput = {
    nomeRT: string
    numeroRT?: number | null
    CTGs?: CTGCreateNestedManyWithoutRTInput
  }

  export type RTUncheckedCreateInput = {
    idRT?: number
    nomeRT: string
    numeroRT?: number | null
    CTGs?: CTGUncheckedCreateNestedManyWithoutRTInput
  }

  export type RTUpdateInput = {
    nomeRT?: StringFieldUpdateOperationsInput | string
    numeroRT?: NullableIntFieldUpdateOperationsInput | number | null
    CTGs?: CTGUpdateManyWithoutRTNestedInput
  }

  export type RTUncheckedUpdateInput = {
    idRT?: IntFieldUpdateOperationsInput | number
    nomeRT?: StringFieldUpdateOperationsInput | string
    numeroRT?: NullableIntFieldUpdateOperationsInput | number | null
    CTGs?: CTGUncheckedUpdateManyWithoutRTNestedInput
  }

  export type RTCreateManyInput = {
    idRT?: number
    nomeRT: string
    numeroRT?: number | null
  }

  export type RTUpdateManyMutationInput = {
    nomeRT?: StringFieldUpdateOperationsInput | string
    numeroRT?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RTUncheckedUpdateManyInput = {
    idRT?: IntFieldUpdateOperationsInput | number
    nomeRT?: StringFieldUpdateOperationsInput | string
    numeroRT?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PreferenciaSorteioDancaCreateInput = {
    nomeSorteioDanca: $Enums.DancaSalaoTradicional
    Candidato: CandidatoCreateNestedOneWithoutPreferenciaSorteioDancaInput
    SorteioDanca?: SorteioDancaCreateNestedOneWithoutPreferenciaSorteioDancaIdsInput
    quesitos?: QuesitosCreateNestedManyWithoutPreferenciaSorteioDancaInput
  }

  export type PreferenciaSorteioDancaUncheckedCreateInput = {
    idPreferencia?: number
    nomeSorteioDanca: $Enums.DancaSalaoTradicional
    candidatoId: number
    sorteioDancaId?: number | null
    quesitos?: QuesitosUncheckedCreateNestedManyWithoutPreferenciaSorteioDancaInput
  }

  export type PreferenciaSorteioDancaUpdateInput = {
    nomeSorteioDanca?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
    Candidato?: CandidatoUpdateOneRequiredWithoutPreferenciaSorteioDancaNestedInput
    SorteioDanca?: SorteioDancaUpdateOneWithoutPreferenciaSorteioDancaIdsNestedInput
    quesitos?: QuesitosUpdateManyWithoutPreferenciaSorteioDancaNestedInput
  }

  export type PreferenciaSorteioDancaUncheckedUpdateInput = {
    idPreferencia?: IntFieldUpdateOperationsInput | number
    nomeSorteioDanca?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
    candidatoId?: IntFieldUpdateOperationsInput | number
    sorteioDancaId?: NullableIntFieldUpdateOperationsInput | number | null
    quesitos?: QuesitosUncheckedUpdateManyWithoutPreferenciaSorteioDancaNestedInput
  }

  export type PreferenciaSorteioDancaCreateManyInput = {
    idPreferencia?: number
    nomeSorteioDanca: $Enums.DancaSalaoTradicional
    candidatoId: number
    sorteioDancaId?: number | null
  }

  export type PreferenciaSorteioDancaUpdateManyMutationInput = {
    nomeSorteioDanca?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
  }

  export type PreferenciaSorteioDancaUncheckedUpdateManyInput = {
    idPreferencia?: IntFieldUpdateOperationsInput | number
    nomeSorteioDanca?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
    candidatoId?: IntFieldUpdateOperationsInput | number
    sorteioDancaId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ConcursoCreateInput = {
    nomeConcurso: string
    lancamentoEdital: Date | string
    inscricoesInicio: Date | string
    inscricoesFinal: Date | string
    dataProvaEscrita: Date | string
    dataProvasPraticas: Date | string
    dataResultado: Date | string
    local: string
    anexoEdital?: Bytes | null
    candidatos?: CandidatoCreateNestedManyWithoutConcursoInput
    comissoes?: ComissaoCreateNestedManyWithoutConcursoInput
  }

  export type ConcursoUncheckedCreateInput = {
    idConcurso?: number
    nomeConcurso: string
    lancamentoEdital: Date | string
    inscricoesInicio: Date | string
    inscricoesFinal: Date | string
    dataProvaEscrita: Date | string
    dataProvasPraticas: Date | string
    dataResultado: Date | string
    local: string
    anexoEdital?: Bytes | null
    candidatos?: CandidatoUncheckedCreateNestedManyWithoutConcursoInput
    comissoes?: ComissaoUncheckedCreateNestedManyWithoutConcursoInput
  }

  export type ConcursoUpdateInput = {
    nomeConcurso?: StringFieldUpdateOperationsInput | string
    lancamentoEdital?: DateTimeFieldUpdateOperationsInput | Date | string
    inscricoesInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    inscricoesFinal?: DateTimeFieldUpdateOperationsInput | Date | string
    dataProvaEscrita?: DateTimeFieldUpdateOperationsInput | Date | string
    dataProvasPraticas?: DateTimeFieldUpdateOperationsInput | Date | string
    dataResultado?: DateTimeFieldUpdateOperationsInput | Date | string
    local?: StringFieldUpdateOperationsInput | string
    anexoEdital?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    candidatos?: CandidatoUpdateManyWithoutConcursoNestedInput
    comissoes?: ComissaoUpdateManyWithoutConcursoNestedInput
  }

  export type ConcursoUncheckedUpdateInput = {
    idConcurso?: IntFieldUpdateOperationsInput | number
    nomeConcurso?: StringFieldUpdateOperationsInput | string
    lancamentoEdital?: DateTimeFieldUpdateOperationsInput | Date | string
    inscricoesInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    inscricoesFinal?: DateTimeFieldUpdateOperationsInput | Date | string
    dataProvaEscrita?: DateTimeFieldUpdateOperationsInput | Date | string
    dataProvasPraticas?: DateTimeFieldUpdateOperationsInput | Date | string
    dataResultado?: DateTimeFieldUpdateOperationsInput | Date | string
    local?: StringFieldUpdateOperationsInput | string
    anexoEdital?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    candidatos?: CandidatoUncheckedUpdateManyWithoutConcursoNestedInput
    comissoes?: ComissaoUncheckedUpdateManyWithoutConcursoNestedInput
  }

  export type ConcursoCreateManyInput = {
    idConcurso?: number
    nomeConcurso: string
    lancamentoEdital: Date | string
    inscricoesInicio: Date | string
    inscricoesFinal: Date | string
    dataProvaEscrita: Date | string
    dataProvasPraticas: Date | string
    dataResultado: Date | string
    local: string
    anexoEdital?: Bytes | null
  }

  export type ConcursoUpdateManyMutationInput = {
    nomeConcurso?: StringFieldUpdateOperationsInput | string
    lancamentoEdital?: DateTimeFieldUpdateOperationsInput | Date | string
    inscricoesInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    inscricoesFinal?: DateTimeFieldUpdateOperationsInput | Date | string
    dataProvaEscrita?: DateTimeFieldUpdateOperationsInput | Date | string
    dataProvasPraticas?: DateTimeFieldUpdateOperationsInput | Date | string
    dataResultado?: DateTimeFieldUpdateOperationsInput | Date | string
    local?: StringFieldUpdateOperationsInput | string
    anexoEdital?: NullableBytesFieldUpdateOperationsInput | Bytes | null
  }

  export type ConcursoUncheckedUpdateManyInput = {
    idConcurso?: IntFieldUpdateOperationsInput | number
    nomeConcurso?: StringFieldUpdateOperationsInput | string
    lancamentoEdital?: DateTimeFieldUpdateOperationsInput | Date | string
    inscricoesInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    inscricoesFinal?: DateTimeFieldUpdateOperationsInput | Date | string
    dataProvaEscrita?: DateTimeFieldUpdateOperationsInput | Date | string
    dataProvasPraticas?: DateTimeFieldUpdateOperationsInput | Date | string
    dataResultado?: DateTimeFieldUpdateOperationsInput | Date | string
    local?: StringFieldUpdateOperationsInput | string
    anexoEdital?: NullableBytesFieldUpdateOperationsInput | Bytes | null
  }

  export type ComissaoCreateInput = {
    nomeComissao: string
    concurso: ConcursoCreateNestedOneWithoutComissoesInput
    avalicao?: AvaliacaoCreateNestedManyWithoutComissaoInput
    usuarios?: ComissaoUsuarioCreateNestedManyWithoutComissaoInput
  }

  export type ComissaoUncheckedCreateInput = {
    idComissao?: number
    nomeComissao: string
    concursoId: number
    avalicao?: AvaliacaoUncheckedCreateNestedManyWithoutComissaoInput
    usuarios?: ComissaoUsuarioUncheckedCreateNestedManyWithoutComissaoInput
  }

  export type ComissaoUpdateInput = {
    nomeComissao?: StringFieldUpdateOperationsInput | string
    concurso?: ConcursoUpdateOneRequiredWithoutComissoesNestedInput
    avalicao?: AvaliacaoUpdateManyWithoutComissaoNestedInput
    usuarios?: ComissaoUsuarioUpdateManyWithoutComissaoNestedInput
  }

  export type ComissaoUncheckedUpdateInput = {
    idComissao?: IntFieldUpdateOperationsInput | number
    nomeComissao?: StringFieldUpdateOperationsInput | string
    concursoId?: IntFieldUpdateOperationsInput | number
    avalicao?: AvaliacaoUncheckedUpdateManyWithoutComissaoNestedInput
    usuarios?: ComissaoUsuarioUncheckedUpdateManyWithoutComissaoNestedInput
  }

  export type ComissaoCreateManyInput = {
    idComissao?: number
    nomeComissao: string
    concursoId: number
  }

  export type ComissaoUpdateManyMutationInput = {
    nomeComissao?: StringFieldUpdateOperationsInput | string
  }

  export type ComissaoUncheckedUpdateManyInput = {
    idComissao?: IntFieldUpdateOperationsInput | number
    nomeComissao?: StringFieldUpdateOperationsInput | string
    concursoId?: IntFieldUpdateOperationsInput | number
  }

  export type ComissaoUsuarioCreateInput = {
    Comissao: ComissaoCreateNestedOneWithoutUsuariosInput
    Usuarios: UsuarioCreateNestedOneWithoutComissaoUsuarioInput
  }

  export type ComissaoUsuarioUncheckedCreateInput = {
    idComissaoUsuario?: number
    comissaoId: number
    usuarioId: number
  }

  export type ComissaoUsuarioUpdateInput = {
    Comissao?: ComissaoUpdateOneRequiredWithoutUsuariosNestedInput
    Usuarios?: UsuarioUpdateOneRequiredWithoutComissaoUsuarioNestedInput
  }

  export type ComissaoUsuarioUncheckedUpdateInput = {
    idComissaoUsuario?: IntFieldUpdateOperationsInput | number
    comissaoId?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
  }

  export type ComissaoUsuarioCreateManyInput = {
    idComissaoUsuario?: number
    comissaoId: number
    usuarioId: number
  }

  export type ComissaoUsuarioUpdateManyMutationInput = {

  }

  export type ComissaoUsuarioUncheckedUpdateManyInput = {
    idComissaoUsuario?: IntFieldUpdateOperationsInput | number
    comissaoId?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
  }

  export type CategoriaCreateInput = {
    nomeCategoria: string
    escolaridade: string
    sorteioDanca: number
    idadeInicial: number
    idadeLimite?: number | null
    candidatos?: CandidatoCreateNestedManyWithoutCategoriaInput
    Prova?: ProvaCreateNestedOneWithoutCategoriasInput
    ProvaTeorica?: ProvaTeoricaCreateNestedOneWithoutCategoriaInput
    ProvaPratica?: ProvaPraticaCreateNestedOneWithoutCategoriaInput
  }

  export type CategoriaUncheckedCreateInput = {
    idCategoria?: number
    nomeCategoria: string
    escolaridade: string
    sorteioDanca: number
    idadeInicial: number
    idadeLimite?: number | null
    provaId?: number | null
    provaTeoricaId?: number | null
    provaPraticaId?: number | null
    candidatos?: CandidatoUncheckedCreateNestedManyWithoutCategoriaInput
  }

  export type CategoriaUpdateInput = {
    nomeCategoria?: StringFieldUpdateOperationsInput | string
    escolaridade?: StringFieldUpdateOperationsInput | string
    sorteioDanca?: IntFieldUpdateOperationsInput | number
    idadeInicial?: IntFieldUpdateOperationsInput | number
    idadeLimite?: NullableIntFieldUpdateOperationsInput | number | null
    candidatos?: CandidatoUpdateManyWithoutCategoriaNestedInput
    Prova?: ProvaUpdateOneWithoutCategoriasNestedInput
    ProvaTeorica?: ProvaTeoricaUpdateOneWithoutCategoriaNestedInput
    ProvaPratica?: ProvaPraticaUpdateOneWithoutCategoriaNestedInput
  }

  export type CategoriaUncheckedUpdateInput = {
    idCategoria?: IntFieldUpdateOperationsInput | number
    nomeCategoria?: StringFieldUpdateOperationsInput | string
    escolaridade?: StringFieldUpdateOperationsInput | string
    sorteioDanca?: IntFieldUpdateOperationsInput | number
    idadeInicial?: IntFieldUpdateOperationsInput | number
    idadeLimite?: NullableIntFieldUpdateOperationsInput | number | null
    provaId?: NullableIntFieldUpdateOperationsInput | number | null
    provaTeoricaId?: NullableIntFieldUpdateOperationsInput | number | null
    provaPraticaId?: NullableIntFieldUpdateOperationsInput | number | null
    candidatos?: CandidatoUncheckedUpdateManyWithoutCategoriaNestedInput
  }

  export type CategoriaCreateManyInput = {
    idCategoria?: number
    nomeCategoria: string
    escolaridade: string
    sorteioDanca: number
    idadeInicial: number
    idadeLimite?: number | null
    provaId?: number | null
    provaTeoricaId?: number | null
    provaPraticaId?: number | null
  }

  export type CategoriaUpdateManyMutationInput = {
    nomeCategoria?: StringFieldUpdateOperationsInput | string
    escolaridade?: StringFieldUpdateOperationsInput | string
    sorteioDanca?: IntFieldUpdateOperationsInput | number
    idadeInicial?: IntFieldUpdateOperationsInput | number
    idadeLimite?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CategoriaUncheckedUpdateManyInput = {
    idCategoria?: IntFieldUpdateOperationsInput | number
    nomeCategoria?: StringFieldUpdateOperationsInput | string
    escolaridade?: StringFieldUpdateOperationsInput | string
    sorteioDanca?: IntFieldUpdateOperationsInput | number
    idadeInicial?: IntFieldUpdateOperationsInput | number
    idadeLimite?: NullableIntFieldUpdateOperationsInput | number | null
    provaId?: NullableIntFieldUpdateOperationsInput | number | null
    provaTeoricaId?: NullableIntFieldUpdateOperationsInput | number | null
    provaPraticaId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AvaliacaoCreateInput = {
    dataAvaliacao?: Date | string
    nota: number
    Comissao: ComissaoCreateNestedOneWithoutAvalicaoInput
    Usuario: UsuarioCreateNestedOneWithoutAvalicoesInput
    Prova?: ProvaCreateNestedOneWithoutAvaliacaoInput
    BlocoProva?: BlocoProvaCreateNestedOneWithoutAvaliacaoInput
    quesitos?: QuesitosCreateNestedManyWithoutAvaliacaoInput
    Candidato: CandidatoCreateNestedOneWithoutAvalicoesInput
    FichaCandidato?: FichaCandidatoCreateNestedOneWithoutAvaliacoesInput
  }

  export type AvaliacaoUncheckedCreateInput = {
    idAvalicao?: number
    dataAvaliacao?: Date | string
    comissaoId: number
    avaliadorId: number
    provaId: number
    blocoProvaId?: number | null
    nota: number
    candidatoId: number
    fichaCandidatoIdFicha?: number | null
    quesitos?: QuesitosUncheckedCreateNestedManyWithoutAvaliacaoInput
  }

  export type AvaliacaoUpdateInput = {
    dataAvaliacao?: DateTimeFieldUpdateOperationsInput | Date | string
    nota?: FloatFieldUpdateOperationsInput | number
    Comissao?: ComissaoUpdateOneRequiredWithoutAvalicaoNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutAvalicoesNestedInput
    Prova?: ProvaUpdateOneWithoutAvaliacaoNestedInput
    BlocoProva?: BlocoProvaUpdateOneWithoutAvaliacaoNestedInput
    quesitos?: QuesitosUpdateManyWithoutAvaliacaoNestedInput
    Candidato?: CandidatoUpdateOneRequiredWithoutAvalicoesNestedInput
    FichaCandidato?: FichaCandidatoUpdateOneWithoutAvaliacoesNestedInput
  }

  export type AvaliacaoUncheckedUpdateInput = {
    idAvalicao?: IntFieldUpdateOperationsInput | number
    dataAvaliacao?: DateTimeFieldUpdateOperationsInput | Date | string
    comissaoId?: IntFieldUpdateOperationsInput | number
    avaliadorId?: IntFieldUpdateOperationsInput | number
    provaId?: IntFieldUpdateOperationsInput | number
    blocoProvaId?: NullableIntFieldUpdateOperationsInput | number | null
    nota?: FloatFieldUpdateOperationsInput | number
    candidatoId?: IntFieldUpdateOperationsInput | number
    fichaCandidatoIdFicha?: NullableIntFieldUpdateOperationsInput | number | null
    quesitos?: QuesitosUncheckedUpdateManyWithoutAvaliacaoNestedInput
  }

  export type AvaliacaoCreateManyInput = {
    idAvalicao?: number
    dataAvaliacao?: Date | string
    comissaoId: number
    avaliadorId: number
    provaId: number
    blocoProvaId?: number | null
    nota: number
    candidatoId: number
    fichaCandidatoIdFicha?: number | null
  }

  export type AvaliacaoUpdateManyMutationInput = {
    dataAvaliacao?: DateTimeFieldUpdateOperationsInput | Date | string
    nota?: FloatFieldUpdateOperationsInput | number
  }

  export type AvaliacaoUncheckedUpdateManyInput = {
    idAvalicao?: IntFieldUpdateOperationsInput | number
    dataAvaliacao?: DateTimeFieldUpdateOperationsInput | Date | string
    comissaoId?: IntFieldUpdateOperationsInput | number
    avaliadorId?: IntFieldUpdateOperationsInput | number
    provaId?: IntFieldUpdateOperationsInput | number
    blocoProvaId?: NullableIntFieldUpdateOperationsInput | number | null
    nota?: FloatFieldUpdateOperationsInput | number
    candidatoId?: IntFieldUpdateOperationsInput | number
    fichaCandidatoIdFicha?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProvaCreateInput = {
    nomeProva: string
    notaMaxima: number
    categorias?: CategoriaCreateNestedManyWithoutProvaInput
    ProvaTeorica?: ProvaTeoricaCreateNestedManyWithoutProvaInput
    ProvaPratica?: ProvaPraticaCreateNestedManyWithoutProvaInput
    recursos?: RecursoCreateNestedManyWithoutProvaInput
    Avaliacao?: AvaliacaoCreateNestedManyWithoutProvaInput
  }

  export type ProvaUncheckedCreateInput = {
    idProva?: number
    nomeProva: string
    notaMaxima: number
    categorias?: CategoriaUncheckedCreateNestedManyWithoutProvaInput
    ProvaTeorica?: ProvaTeoricaUncheckedCreateNestedManyWithoutProvaInput
    ProvaPratica?: ProvaPraticaUncheckedCreateNestedManyWithoutProvaInput
    recursos?: RecursoUncheckedCreateNestedManyWithoutProvaInput
    Avaliacao?: AvaliacaoUncheckedCreateNestedManyWithoutProvaInput
  }

  export type ProvaUpdateInput = {
    nomeProva?: StringFieldUpdateOperationsInput | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    categorias?: CategoriaUpdateManyWithoutProvaNestedInput
    ProvaTeorica?: ProvaTeoricaUpdateManyWithoutProvaNestedInput
    ProvaPratica?: ProvaPraticaUpdateManyWithoutProvaNestedInput
    recursos?: RecursoUpdateManyWithoutProvaNestedInput
    Avaliacao?: AvaliacaoUpdateManyWithoutProvaNestedInput
  }

  export type ProvaUncheckedUpdateInput = {
    idProva?: IntFieldUpdateOperationsInput | number
    nomeProva?: StringFieldUpdateOperationsInput | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    categorias?: CategoriaUncheckedUpdateManyWithoutProvaNestedInput
    ProvaTeorica?: ProvaTeoricaUncheckedUpdateManyWithoutProvaNestedInput
    ProvaPratica?: ProvaPraticaUncheckedUpdateManyWithoutProvaNestedInput
    recursos?: RecursoUncheckedUpdateManyWithoutProvaNestedInput
    Avaliacao?: AvaliacaoUncheckedUpdateManyWithoutProvaNestedInput
  }

  export type ProvaCreateManyInput = {
    idProva?: number
    nomeProva: string
    notaMaxima: number
  }

  export type ProvaUpdateManyMutationInput = {
    nomeProva?: StringFieldUpdateOperationsInput | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
  }

  export type ProvaUncheckedUpdateManyInput = {
    idProva?: IntFieldUpdateOperationsInput | number
    nomeProva?: StringFieldUpdateOperationsInput | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
  }

  export type ProvaTeoricaCreateInput = {
    gabaritoOficinal: Bytes
    numQuestao: number
    Prova?: ProvaCreateNestedOneWithoutProvaTeoricaInput
    quesitos?: QuesitosCreateNestedManyWithoutProvaTeoricaInput
    Categoria?: CategoriaCreateNestedManyWithoutProvaTeoricaInput
    Recurso?: RecursoCreateNestedManyWithoutProvaTeoricaInput
  }

  export type ProvaTeoricaUncheckedCreateInput = {
    idprovaTeorica?: number
    provaId?: number | null
    gabaritoOficinal: Bytes
    numQuestao: number
    quesitos?: QuesitosUncheckedCreateNestedManyWithoutProvaTeoricaInput
    Categoria?: CategoriaUncheckedCreateNestedManyWithoutProvaTeoricaInput
    Recurso?: RecursoUncheckedCreateNestedManyWithoutProvaTeoricaInput
  }

  export type ProvaTeoricaUpdateInput = {
    gabaritoOficinal?: BytesFieldUpdateOperationsInput | Bytes
    numQuestao?: IntFieldUpdateOperationsInput | number
    Prova?: ProvaUpdateOneWithoutProvaTeoricaNestedInput
    quesitos?: QuesitosUpdateManyWithoutProvaTeoricaNestedInput
    Categoria?: CategoriaUpdateManyWithoutProvaTeoricaNestedInput
    Recurso?: RecursoUpdateManyWithoutProvaTeoricaNestedInput
  }

  export type ProvaTeoricaUncheckedUpdateInput = {
    idprovaTeorica?: IntFieldUpdateOperationsInput | number
    provaId?: NullableIntFieldUpdateOperationsInput | number | null
    gabaritoOficinal?: BytesFieldUpdateOperationsInput | Bytes
    numQuestao?: IntFieldUpdateOperationsInput | number
    quesitos?: QuesitosUncheckedUpdateManyWithoutProvaTeoricaNestedInput
    Categoria?: CategoriaUncheckedUpdateManyWithoutProvaTeoricaNestedInput
    Recurso?: RecursoUncheckedUpdateManyWithoutProvaTeoricaNestedInput
  }

  export type ProvaTeoricaCreateManyInput = {
    idprovaTeorica?: number
    provaId?: number | null
    gabaritoOficinal: Bytes
    numQuestao: number
  }

  export type ProvaTeoricaUpdateManyMutationInput = {
    gabaritoOficinal?: BytesFieldUpdateOperationsInput | Bytes
    numQuestao?: IntFieldUpdateOperationsInput | number
  }

  export type ProvaTeoricaUncheckedUpdateManyInput = {
    idprovaTeorica?: IntFieldUpdateOperationsInput | number
    provaId?: NullableIntFieldUpdateOperationsInput | number | null
    gabaritoOficinal?: BytesFieldUpdateOperationsInput | Bytes
    numQuestao?: IntFieldUpdateOperationsInput | number
  }

  export type ProvaPraticaCreateInput = {
    prova?: ProvaCreateNestedOneWithoutProvaPraticaInput
    blocosProvas?: BlocoProvaCreateNestedManyWithoutProvaPraticaInput
    Categoria?: CategoriaCreateNestedManyWithoutProvaPraticaInput
    Recurso?: RecursoCreateNestedManyWithoutProvaPraticaInput
  }

  export type ProvaPraticaUncheckedCreateInput = {
    idProvaPratica?: number
    provaId?: number | null
    blocosProvas?: BlocoProvaUncheckedCreateNestedManyWithoutProvaPraticaInput
    Categoria?: CategoriaUncheckedCreateNestedManyWithoutProvaPraticaInput
    Recurso?: RecursoUncheckedCreateNestedManyWithoutProvaPraticaInput
  }

  export type ProvaPraticaUpdateInput = {
    prova?: ProvaUpdateOneWithoutProvaPraticaNestedInput
    blocosProvas?: BlocoProvaUpdateManyWithoutProvaPraticaNestedInput
    Categoria?: CategoriaUpdateManyWithoutProvaPraticaNestedInput
    Recurso?: RecursoUpdateManyWithoutProvaPraticaNestedInput
  }

  export type ProvaPraticaUncheckedUpdateInput = {
    idProvaPratica?: IntFieldUpdateOperationsInput | number
    provaId?: NullableIntFieldUpdateOperationsInput | number | null
    blocosProvas?: BlocoProvaUncheckedUpdateManyWithoutProvaPraticaNestedInput
    Categoria?: CategoriaUncheckedUpdateManyWithoutProvaPraticaNestedInput
    Recurso?: RecursoUncheckedUpdateManyWithoutProvaPraticaNestedInput
  }

  export type ProvaPraticaCreateManyInput = {
    idProvaPratica?: number
    provaId?: number | null
  }

  export type ProvaPraticaUpdateManyMutationInput = {

  }

  export type ProvaPraticaUncheckedUpdateManyInput = {
    idProvaPratica?: IntFieldUpdateOperationsInput | number
    provaId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BlocoProvaCreateInput = {
    nomeBloco: string
    notaMaximaBloco: number
    ProvaPratica?: ProvaPraticaCreateNestedOneWithoutBlocosProvasInput
    quesitos?: QuesitosCreateNestedManyWithoutBlocoProvaInput
    Avaliacao?: AvaliacaoCreateNestedManyWithoutBlocoProvaInput
  }

  export type BlocoProvaUncheckedCreateInput = {
    idBloco?: number
    nomeBloco: string
    notaMaximaBloco: number
    provaPraticaId?: number | null
    quesitos?: QuesitosUncheckedCreateNestedManyWithoutBlocoProvaInput
    Avaliacao?: AvaliacaoUncheckedCreateNestedManyWithoutBlocoProvaInput
  }

  export type BlocoProvaUpdateInput = {
    nomeBloco?: StringFieldUpdateOperationsInput | string
    notaMaximaBloco?: FloatFieldUpdateOperationsInput | number
    ProvaPratica?: ProvaPraticaUpdateOneWithoutBlocosProvasNestedInput
    quesitos?: QuesitosUpdateManyWithoutBlocoProvaNestedInput
    Avaliacao?: AvaliacaoUpdateManyWithoutBlocoProvaNestedInput
  }

  export type BlocoProvaUncheckedUpdateInput = {
    idBloco?: IntFieldUpdateOperationsInput | number
    nomeBloco?: StringFieldUpdateOperationsInput | string
    notaMaximaBloco?: FloatFieldUpdateOperationsInput | number
    provaPraticaId?: NullableIntFieldUpdateOperationsInput | number | null
    quesitos?: QuesitosUncheckedUpdateManyWithoutBlocoProvaNestedInput
    Avaliacao?: AvaliacaoUncheckedUpdateManyWithoutBlocoProvaNestedInput
  }

  export type BlocoProvaCreateManyInput = {
    idBloco?: number
    nomeBloco: string
    notaMaximaBloco: number
    provaPraticaId?: number | null
  }

  export type BlocoProvaUpdateManyMutationInput = {
    nomeBloco?: StringFieldUpdateOperationsInput | string
    notaMaximaBloco?: FloatFieldUpdateOperationsInput | number
  }

  export type BlocoProvaUncheckedUpdateManyInput = {
    idBloco?: IntFieldUpdateOperationsInput | number
    nomeBloco?: StringFieldUpdateOperationsInput | string
    notaMaximaBloco?: FloatFieldUpdateOperationsInput | number
    provaPraticaId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuesitosCreateInput = {
    nomeQuesito: string
    notaMaximaQuesito: number
    danca: boolean
    dancaSalaoTradicional: $Enums.DancaSalaoTradicional
    BlocoProva?: BlocoProvaCreateNestedOneWithoutQuesitosInput
    ProvaTeorica?: ProvaTeoricaCreateNestedOneWithoutQuesitosInput
    subeQuesitos?: SubQuesitosCreateNestedManyWithoutQuesitoInput
    recursos?: RecursoCreateNestedManyWithoutQuesitoInput
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaCreateNestedOneWithoutQuesitosInput
    Avaliacao?: AvaliacaoCreateNestedOneWithoutQuesitosInput
  }

  export type QuesitosUncheckedCreateInput = {
    idQuesito?: number
    nomeQuesito: string
    notaMaximaQuesito: number
    danca: boolean
    dancaSalaoTradicional: $Enums.DancaSalaoTradicional
    blocoProvaIdBloco?: number | null
    provaTeoricaIdprovaTeorica?: number | null
    preferenciaSorteioDancaId?: number | null
    avaliacaoIdAvalicao?: number | null
    subeQuesitos?: SubQuesitosUncheckedCreateNestedManyWithoutQuesitoInput
    recursos?: RecursoUncheckedCreateNestedManyWithoutQuesitoInput
  }

  export type QuesitosUpdateInput = {
    nomeQuesito?: StringFieldUpdateOperationsInput | string
    notaMaximaQuesito?: FloatFieldUpdateOperationsInput | number
    danca?: BoolFieldUpdateOperationsInput | boolean
    dancaSalaoTradicional?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
    BlocoProva?: BlocoProvaUpdateOneWithoutQuesitosNestedInput
    ProvaTeorica?: ProvaTeoricaUpdateOneWithoutQuesitosNestedInput
    subeQuesitos?: SubQuesitosUpdateManyWithoutQuesitoNestedInput
    recursos?: RecursoUpdateManyWithoutQuesitoNestedInput
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaUpdateOneWithoutQuesitosNestedInput
    Avaliacao?: AvaliacaoUpdateOneWithoutQuesitosNestedInput
  }

  export type QuesitosUncheckedUpdateInput = {
    idQuesito?: IntFieldUpdateOperationsInput | number
    nomeQuesito?: StringFieldUpdateOperationsInput | string
    notaMaximaQuesito?: FloatFieldUpdateOperationsInput | number
    danca?: BoolFieldUpdateOperationsInput | boolean
    dancaSalaoTradicional?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
    blocoProvaIdBloco?: NullableIntFieldUpdateOperationsInput | number | null
    provaTeoricaIdprovaTeorica?: NullableIntFieldUpdateOperationsInput | number | null
    preferenciaSorteioDancaId?: NullableIntFieldUpdateOperationsInput | number | null
    avaliacaoIdAvalicao?: NullableIntFieldUpdateOperationsInput | number | null
    subeQuesitos?: SubQuesitosUncheckedUpdateManyWithoutQuesitoNestedInput
    recursos?: RecursoUncheckedUpdateManyWithoutQuesitoNestedInput
  }

  export type QuesitosCreateManyInput = {
    idQuesito?: number
    nomeQuesito: string
    notaMaximaQuesito: number
    danca: boolean
    dancaSalaoTradicional: $Enums.DancaSalaoTradicional
    blocoProvaIdBloco?: number | null
    provaTeoricaIdprovaTeorica?: number | null
    preferenciaSorteioDancaId?: number | null
    avaliacaoIdAvalicao?: number | null
  }

  export type QuesitosUpdateManyMutationInput = {
    nomeQuesito?: StringFieldUpdateOperationsInput | string
    notaMaximaQuesito?: FloatFieldUpdateOperationsInput | number
    danca?: BoolFieldUpdateOperationsInput | boolean
    dancaSalaoTradicional?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
  }

  export type QuesitosUncheckedUpdateManyInput = {
    idQuesito?: IntFieldUpdateOperationsInput | number
    nomeQuesito?: StringFieldUpdateOperationsInput | string
    notaMaximaQuesito?: FloatFieldUpdateOperationsInput | number
    danca?: BoolFieldUpdateOperationsInput | boolean
    dancaSalaoTradicional?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
    blocoProvaIdBloco?: NullableIntFieldUpdateOperationsInput | number | null
    provaTeoricaIdprovaTeorica?: NullableIntFieldUpdateOperationsInput | number | null
    preferenciaSorteioDancaId?: NullableIntFieldUpdateOperationsInput | number | null
    avaliacaoIdAvalicao?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SubQuesitosCreateInput = {
    nomeSubquesito: string
    notaSubequesito: number
    Quesito: QuesitosCreateNestedOneWithoutSubeQuesitosInput
    subequesitosFilhos?: SubQuesitosCreateNestedManyWithoutSubequesitosPaiInput
    subequesitosPai?: SubQuesitosCreateNestedManyWithoutSubequesitosFilhosInput
  }

  export type SubQuesitosUncheckedCreateInput = {
    idSubequestios?: number
    nomeSubquesito: string
    notaSubequesito: number
    quesitoId: number
    subequesitosFilhos?: SubQuesitosUncheckedCreateNestedManyWithoutSubequesitosPaiInput
    subequesitosPai?: SubQuesitosUncheckedCreateNestedManyWithoutSubequesitosFilhosInput
  }

  export type SubQuesitosUpdateInput = {
    nomeSubquesito?: StringFieldUpdateOperationsInput | string
    notaSubequesito?: FloatFieldUpdateOperationsInput | number
    Quesito?: QuesitosUpdateOneRequiredWithoutSubeQuesitosNestedInput
    subequesitosFilhos?: SubQuesitosUpdateManyWithoutSubequesitosPaiNestedInput
    subequesitosPai?: SubQuesitosUpdateManyWithoutSubequesitosFilhosNestedInput
  }

  export type SubQuesitosUncheckedUpdateInput = {
    idSubequestios?: IntFieldUpdateOperationsInput | number
    nomeSubquesito?: StringFieldUpdateOperationsInput | string
    notaSubequesito?: FloatFieldUpdateOperationsInput | number
    quesitoId?: IntFieldUpdateOperationsInput | number
    subequesitosFilhos?: SubQuesitosUncheckedUpdateManyWithoutSubequesitosPaiNestedInput
    subequesitosPai?: SubQuesitosUncheckedUpdateManyWithoutSubequesitosFilhosNestedInput
  }

  export type SubQuesitosCreateManyInput = {
    idSubequestios?: number
    nomeSubquesito: string
    notaSubequesito: number
    quesitoId: number
  }

  export type SubQuesitosUpdateManyMutationInput = {
    nomeSubquesito?: StringFieldUpdateOperationsInput | string
    notaSubequesito?: FloatFieldUpdateOperationsInput | number
  }

  export type SubQuesitosUncheckedUpdateManyInput = {
    idSubequestios?: IntFieldUpdateOperationsInput | number
    nomeSubquesito?: StringFieldUpdateOperationsInput | string
    notaSubequesito?: FloatFieldUpdateOperationsInput | number
    quesitoId?: IntFieldUpdateOperationsInput | number
  }

  export type RecursoCreateInput = {
    nomeRecurso: string
    justificativa: string
    status: boolean
    dataRecurso?: Date | string
    arquivos: Bytes
    Candidato: CandidatoCreateNestedOneWithoutRecursoInput
    Usuario: UsuarioCreateNestedOneWithoutRecursosInput
    Quesito: QuesitosCreateNestedOneWithoutRecursosInput
    ProvaTeorica?: ProvaTeoricaCreateNestedOneWithoutRecursoInput
    ProvaPratica?: ProvaPraticaCreateNestedOneWithoutRecursoInput
    Prova?: ProvaCreateNestedOneWithoutRecursosInput
  }

  export type RecursoUncheckedCreateInput = {
    idRecurso?: number
    nomeRecurso: string
    justificativa: string
    status: boolean
    dataRecurso?: Date | string
    arquivos: Bytes
    candidato: number
    avaliador: number
    quesitoRecurso: number
    provaTeoricaIdprovaTeorica?: number | null
    provaPraticaIdProvaPratica?: number | null
    provaIdProva?: number | null
  }

  export type RecursoUpdateInput = {
    nomeRecurso?: StringFieldUpdateOperationsInput | string
    justificativa?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dataRecurso?: DateTimeFieldUpdateOperationsInput | Date | string
    arquivos?: BytesFieldUpdateOperationsInput | Bytes
    Candidato?: CandidatoUpdateOneRequiredWithoutRecursoNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutRecursosNestedInput
    Quesito?: QuesitosUpdateOneRequiredWithoutRecursosNestedInput
    ProvaTeorica?: ProvaTeoricaUpdateOneWithoutRecursoNestedInput
    ProvaPratica?: ProvaPraticaUpdateOneWithoutRecursoNestedInput
    Prova?: ProvaUpdateOneWithoutRecursosNestedInput
  }

  export type RecursoUncheckedUpdateInput = {
    idRecurso?: IntFieldUpdateOperationsInput | number
    nomeRecurso?: StringFieldUpdateOperationsInput | string
    justificativa?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dataRecurso?: DateTimeFieldUpdateOperationsInput | Date | string
    arquivos?: BytesFieldUpdateOperationsInput | Bytes
    candidato?: IntFieldUpdateOperationsInput | number
    avaliador?: IntFieldUpdateOperationsInput | number
    quesitoRecurso?: IntFieldUpdateOperationsInput | number
    provaTeoricaIdprovaTeorica?: NullableIntFieldUpdateOperationsInput | number | null
    provaPraticaIdProvaPratica?: NullableIntFieldUpdateOperationsInput | number | null
    provaIdProva?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RecursoCreateManyInput = {
    idRecurso?: number
    nomeRecurso: string
    justificativa: string
    status: boolean
    dataRecurso?: Date | string
    arquivos: Bytes
    candidato: number
    avaliador: number
    quesitoRecurso: number
    provaTeoricaIdprovaTeorica?: number | null
    provaPraticaIdProvaPratica?: number | null
    provaIdProva?: number | null
  }

  export type RecursoUpdateManyMutationInput = {
    nomeRecurso?: StringFieldUpdateOperationsInput | string
    justificativa?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dataRecurso?: DateTimeFieldUpdateOperationsInput | Date | string
    arquivos?: BytesFieldUpdateOperationsInput | Bytes
  }

  export type RecursoUncheckedUpdateManyInput = {
    idRecurso?: IntFieldUpdateOperationsInput | number
    nomeRecurso?: StringFieldUpdateOperationsInput | string
    justificativa?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dataRecurso?: DateTimeFieldUpdateOperationsInput | Date | string
    arquivos?: BytesFieldUpdateOperationsInput | Bytes
    candidato?: IntFieldUpdateOperationsInput | number
    avaliador?: IntFieldUpdateOperationsInput | number
    quesitoRecurso?: IntFieldUpdateOperationsInput | number
    provaTeoricaIdprovaTeorica?: NullableIntFieldUpdateOperationsInput | number | null
    provaPraticaIdProvaPratica?: NullableIntFieldUpdateOperationsInput | number | null
    provaIdProva?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SorteioDancaCreateInput = {
    resultadoSorteio: number
    dataSorteio?: Date | string
    tipoDanca: $Enums.DancaSalaoTradicional
    preferenciaSorteioDancaIds?: PreferenciaSorteioDancaCreateNestedManyWithoutSorteioDancaInput
    Candidato: CandidatoCreateNestedOneWithoutSorteioDancaInput
    Usuario: UsuarioCreateNestedOneWithoutSorteioDancaInput
  }

  export type SorteioDancaUncheckedCreateInput = {
    idSorteio?: number
    resultadoSorteio: number
    dataSorteio?: Date | string
    tipoDanca: $Enums.DancaSalaoTradicional
    candidatoId: number
    usuarioId: number
    preferenciaSorteioDancaIds?: PreferenciaSorteioDancaUncheckedCreateNestedManyWithoutSorteioDancaInput
  }

  export type SorteioDancaUpdateInput = {
    resultadoSorteio?: IntFieldUpdateOperationsInput | number
    dataSorteio?: DateTimeFieldUpdateOperationsInput | Date | string
    tipoDanca?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
    preferenciaSorteioDancaIds?: PreferenciaSorteioDancaUpdateManyWithoutSorteioDancaNestedInput
    Candidato?: CandidatoUpdateOneRequiredWithoutSorteioDancaNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutSorteioDancaNestedInput
  }

  export type SorteioDancaUncheckedUpdateInput = {
    idSorteio?: IntFieldUpdateOperationsInput | number
    resultadoSorteio?: IntFieldUpdateOperationsInput | number
    dataSorteio?: DateTimeFieldUpdateOperationsInput | Date | string
    tipoDanca?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
    candidatoId?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    preferenciaSorteioDancaIds?: PreferenciaSorteioDancaUncheckedUpdateManyWithoutSorteioDancaNestedInput
  }

  export type SorteioDancaCreateManyInput = {
    idSorteio?: number
    resultadoSorteio: number
    dataSorteio?: Date | string
    tipoDanca: $Enums.DancaSalaoTradicional
    candidatoId: number
    usuarioId: number
  }

  export type SorteioDancaUpdateManyMutationInput = {
    resultadoSorteio?: IntFieldUpdateOperationsInput | number
    dataSorteio?: DateTimeFieldUpdateOperationsInput | Date | string
    tipoDanca?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
  }

  export type SorteioDancaUncheckedUpdateManyInput = {
    idSorteio?: IntFieldUpdateOperationsInput | number
    resultadoSorteio?: IntFieldUpdateOperationsInput | number
    dataSorteio?: DateTimeFieldUpdateOperationsInput | Date | string
    tipoDanca?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
    candidatoId?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
  }

  export type FichaCandidatoCreateInput = {
    candidatoId: number
    notaCandidato: number
    provaId: number
    concursoId: number
    categoriaId: number
    anexoTermodeCiencia: Bytes
    dataTermo?: Date | string
    numAcertosProvaTeorica: number
    anexoGabarito: Bytes
    notaRedacao: number
    anexoRedacao: Bytes
    anexoProvaPratica: Bytes
    avaliacoes?: AvaliacaoCreateNestedManyWithoutFichaCandidatoInput
  }

  export type FichaCandidatoUncheckedCreateInput = {
    idFicha?: number
    candidatoId: number
    notaCandidato: number
    provaId: number
    concursoId: number
    categoriaId: number
    anexoTermodeCiencia: Bytes
    dataTermo?: Date | string
    numAcertosProvaTeorica: number
    anexoGabarito: Bytes
    notaRedacao: number
    anexoRedacao: Bytes
    anexoProvaPratica: Bytes
    avaliacoes?: AvaliacaoUncheckedCreateNestedManyWithoutFichaCandidatoInput
  }

  export type FichaCandidatoUpdateInput = {
    candidatoId?: IntFieldUpdateOperationsInput | number
    notaCandidato?: FloatFieldUpdateOperationsInput | number
    provaId?: IntFieldUpdateOperationsInput | number
    concursoId?: IntFieldUpdateOperationsInput | number
    categoriaId?: IntFieldUpdateOperationsInput | number
    anexoTermodeCiencia?: BytesFieldUpdateOperationsInput | Bytes
    dataTermo?: DateTimeFieldUpdateOperationsInput | Date | string
    numAcertosProvaTeorica?: IntFieldUpdateOperationsInput | number
    anexoGabarito?: BytesFieldUpdateOperationsInput | Bytes
    notaRedacao?: FloatFieldUpdateOperationsInput | number
    anexoRedacao?: BytesFieldUpdateOperationsInput | Bytes
    anexoProvaPratica?: BytesFieldUpdateOperationsInput | Bytes
    avaliacoes?: AvaliacaoUpdateManyWithoutFichaCandidatoNestedInput
  }

  export type FichaCandidatoUncheckedUpdateInput = {
    idFicha?: IntFieldUpdateOperationsInput | number
    candidatoId?: IntFieldUpdateOperationsInput | number
    notaCandidato?: FloatFieldUpdateOperationsInput | number
    provaId?: IntFieldUpdateOperationsInput | number
    concursoId?: IntFieldUpdateOperationsInput | number
    categoriaId?: IntFieldUpdateOperationsInput | number
    anexoTermodeCiencia?: BytesFieldUpdateOperationsInput | Bytes
    dataTermo?: DateTimeFieldUpdateOperationsInput | Date | string
    numAcertosProvaTeorica?: IntFieldUpdateOperationsInput | number
    anexoGabarito?: BytesFieldUpdateOperationsInput | Bytes
    notaRedacao?: FloatFieldUpdateOperationsInput | number
    anexoRedacao?: BytesFieldUpdateOperationsInput | Bytes
    anexoProvaPratica?: BytesFieldUpdateOperationsInput | Bytes
    avaliacoes?: AvaliacaoUncheckedUpdateManyWithoutFichaCandidatoNestedInput
  }

  export type FichaCandidatoCreateManyInput = {
    idFicha?: number
    candidatoId: number
    notaCandidato: number
    provaId: number
    concursoId: number
    categoriaId: number
    anexoTermodeCiencia: Bytes
    dataTermo?: Date | string
    numAcertosProvaTeorica: number
    anexoGabarito: Bytes
    notaRedacao: number
    anexoRedacao: Bytes
    anexoProvaPratica: Bytes
  }

  export type FichaCandidatoUpdateManyMutationInput = {
    candidatoId?: IntFieldUpdateOperationsInput | number
    notaCandidato?: FloatFieldUpdateOperationsInput | number
    provaId?: IntFieldUpdateOperationsInput | number
    concursoId?: IntFieldUpdateOperationsInput | number
    categoriaId?: IntFieldUpdateOperationsInput | number
    anexoTermodeCiencia?: BytesFieldUpdateOperationsInput | Bytes
    dataTermo?: DateTimeFieldUpdateOperationsInput | Date | string
    numAcertosProvaTeorica?: IntFieldUpdateOperationsInput | number
    anexoGabarito?: BytesFieldUpdateOperationsInput | Bytes
    notaRedacao?: FloatFieldUpdateOperationsInput | number
    anexoRedacao?: BytesFieldUpdateOperationsInput | Bytes
    anexoProvaPratica?: BytesFieldUpdateOperationsInput | Bytes
  }

  export type FichaCandidatoUncheckedUpdateManyInput = {
    idFicha?: IntFieldUpdateOperationsInput | number
    candidatoId?: IntFieldUpdateOperationsInput | number
    notaCandidato?: FloatFieldUpdateOperationsInput | number
    provaId?: IntFieldUpdateOperationsInput | number
    concursoId?: IntFieldUpdateOperationsInput | number
    categoriaId?: IntFieldUpdateOperationsInput | number
    anexoTermodeCiencia?: BytesFieldUpdateOperationsInput | Bytes
    dataTermo?: DateTimeFieldUpdateOperationsInput | Date | string
    numAcertosProvaTeorica?: IntFieldUpdateOperationsInput | number
    anexoGabarito?: BytesFieldUpdateOperationsInput | Bytes
    notaRedacao?: FloatFieldUpdateOperationsInput | number
    anexoRedacao?: BytesFieldUpdateOperationsInput | Bytes
    anexoProvaPratica?: BytesFieldUpdateOperationsInput | Bytes
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumProvaCampeiraEsportivaNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ProvaCampeiraEsportiva | EnumProvaCampeiraEsportivaFieldRefInput<$PrismaModel> | null
    in?: $Enums.ProvaCampeiraEsportiva[] | ListEnumProvaCampeiraEsportivaFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ProvaCampeiraEsportiva[] | ListEnumProvaCampeiraEsportivaFieldRefInput<$PrismaModel> | null
    not?: NestedEnumProvaCampeiraEsportivaNullableFilter<$PrismaModel> | $Enums.ProvaCampeiraEsportiva | null
  }

  export type BytesNullableFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel> | null
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Bytes | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CTGScalarRelationFilter = {
    is?: CTGWhereInput
    isNot?: CTGWhereInput
  }

  export type PreferenciaSorteioDancaListRelationFilter = {
    every?: PreferenciaSorteioDancaWhereInput
    some?: PreferenciaSorteioDancaWhereInput
    none?: PreferenciaSorteioDancaWhereInput
  }

  export type CategoriaScalarRelationFilter = {
    is?: CategoriaWhereInput
    isNot?: CategoriaWhereInput
  }

  export type AvaliacaoListRelationFilter = {
    every?: AvaliacaoWhereInput
    some?: AvaliacaoWhereInput
    none?: AvaliacaoWhereInput
  }

  export type SorteioDancaListRelationFilter = {
    every?: SorteioDancaWhereInput
    some?: SorteioDancaWhereInput
    none?: SorteioDancaWhereInput
  }

  export type RecursoListRelationFilter = {
    every?: RecursoWhereInput
    some?: RecursoWhereInput
    none?: RecursoWhereInput
  }

  export type ConcursoNullableScalarRelationFilter = {
    is?: ConcursoWhereInput | null
    isNot?: ConcursoWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PreferenciaSorteioDancaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AvaliacaoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SorteioDancaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecursoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CandidatoCountOrderByAggregateInput = {
    idCandidato?: SortOrder
    nomeCompleto?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
    CTGId?: SortOrder
    numCarteirinha?: SortOrder
    CPF?: SortOrder
    RG?: SortOrder
    endereco?: SortOrder
    numEndereco?: SortOrder
    bairro?: SortOrder
    escolaridade?: SortOrder
    filiacao?: SortOrder
    ProvaCampeiraEsportiva?: SortOrder
    anexoDocumento?: SortOrder
    anexoCarteirinha?: SortOrder
    anexoEscolaridade?: SortOrder
    anexoResidencia?: SortOrder
    anexoAtaConcurso?: SortOrder
    fichaInscricao?: SortOrder
    anexoTermoCandidato?: SortOrder
    anexoRelatorioVivencia?: SortOrder
    anexoResponsavel?: SortOrder
    anexoProvaEsportivaCampeira?: SortOrder
    categoriaId?: SortOrder
    concursoIdConcurso?: SortOrder
  }

  export type CandidatoAvgOrderByAggregateInput = {
    idCandidato?: SortOrder
    CTGId?: SortOrder
    numEndereco?: SortOrder
    categoriaId?: SortOrder
    concursoIdConcurso?: SortOrder
  }

  export type CandidatoMaxOrderByAggregateInput = {
    idCandidato?: SortOrder
    nomeCompleto?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
    CTGId?: SortOrder
    numCarteirinha?: SortOrder
    CPF?: SortOrder
    RG?: SortOrder
    endereco?: SortOrder
    numEndereco?: SortOrder
    bairro?: SortOrder
    escolaridade?: SortOrder
    filiacao?: SortOrder
    ProvaCampeiraEsportiva?: SortOrder
    anexoDocumento?: SortOrder
    anexoCarteirinha?: SortOrder
    anexoEscolaridade?: SortOrder
    anexoResidencia?: SortOrder
    anexoAtaConcurso?: SortOrder
    fichaInscricao?: SortOrder
    anexoTermoCandidato?: SortOrder
    anexoRelatorioVivencia?: SortOrder
    anexoResponsavel?: SortOrder
    anexoProvaEsportivaCampeira?: SortOrder
    categoriaId?: SortOrder
    concursoIdConcurso?: SortOrder
  }

  export type CandidatoMinOrderByAggregateInput = {
    idCandidato?: SortOrder
    nomeCompleto?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
    CTGId?: SortOrder
    numCarteirinha?: SortOrder
    CPF?: SortOrder
    RG?: SortOrder
    endereco?: SortOrder
    numEndereco?: SortOrder
    bairro?: SortOrder
    escolaridade?: SortOrder
    filiacao?: SortOrder
    ProvaCampeiraEsportiva?: SortOrder
    anexoDocumento?: SortOrder
    anexoCarteirinha?: SortOrder
    anexoEscolaridade?: SortOrder
    anexoResidencia?: SortOrder
    anexoAtaConcurso?: SortOrder
    fichaInscricao?: SortOrder
    anexoTermoCandidato?: SortOrder
    anexoRelatorioVivencia?: SortOrder
    anexoResponsavel?: SortOrder
    anexoProvaEsportivaCampeira?: SortOrder
    categoriaId?: SortOrder
    concursoIdConcurso?: SortOrder
  }

  export type CandidatoSumOrderByAggregateInput = {
    idCandidato?: SortOrder
    CTGId?: SortOrder
    numEndereco?: SortOrder
    categoriaId?: SortOrder
    concursoIdConcurso?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumProvaCampeiraEsportivaNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProvaCampeiraEsportiva | EnumProvaCampeiraEsportivaFieldRefInput<$PrismaModel> | null
    in?: $Enums.ProvaCampeiraEsportiva[] | ListEnumProvaCampeiraEsportivaFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ProvaCampeiraEsportiva[] | ListEnumProvaCampeiraEsportivaFieldRefInput<$PrismaModel> | null
    not?: NestedEnumProvaCampeiraEsportivaNullableWithAggregatesFilter<$PrismaModel> | $Enums.ProvaCampeiraEsportiva | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumProvaCampeiraEsportivaNullableFilter<$PrismaModel>
    _max?: NestedEnumProvaCampeiraEsportivaNullableFilter<$PrismaModel>
  }

  export type BytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel> | null
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Bytes | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumFuncaoFilter<$PrismaModel = never> = {
    equals?: $Enums.Funcao | EnumFuncaoFieldRefInput<$PrismaModel>
    in?: $Enums.Funcao[] | ListEnumFuncaoFieldRefInput<$PrismaModel>
    notIn?: $Enums.Funcao[] | ListEnumFuncaoFieldRefInput<$PrismaModel>
    not?: NestedEnumFuncaoFilter<$PrismaModel> | $Enums.Funcao
  }

  export type EnumCredenciamentoFilter<$PrismaModel = never> = {
    equals?: $Enums.Credenciamento | EnumCredenciamentoFieldRefInput<$PrismaModel>
    in?: $Enums.Credenciamento[] | ListEnumCredenciamentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.Credenciamento[] | ListEnumCredenciamentoFieldRefInput<$PrismaModel>
    not?: NestedEnumCredenciamentoFilter<$PrismaModel> | $Enums.Credenciamento
  }

  export type ComissaoUsuarioNullableScalarRelationFilter = {
    is?: ComissaoUsuarioWhereInput | null
    isNot?: ComissaoUsuarioWhereInput | null
  }

  export type UsuarioCountOrderByAggregateInput = {
    idUsuario?: SortOrder
    nomeCompleto?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
    CTGId?: SortOrder
    numCarteirinha?: SortOrder
    login?: SortOrder
    senha?: SortOrder
    funcao?: SortOrder
    credenciamento?: SortOrder
    numCredenciamento?: SortOrder
    comissaoUsuarioId?: SortOrder
  }

  export type UsuarioAvgOrderByAggregateInput = {
    idUsuario?: SortOrder
    CTGId?: SortOrder
    numCredenciamento?: SortOrder
    comissaoUsuarioId?: SortOrder
  }

  export type UsuarioMaxOrderByAggregateInput = {
    idUsuario?: SortOrder
    nomeCompleto?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
    CTGId?: SortOrder
    numCarteirinha?: SortOrder
    login?: SortOrder
    senha?: SortOrder
    funcao?: SortOrder
    credenciamento?: SortOrder
    numCredenciamento?: SortOrder
    comissaoUsuarioId?: SortOrder
  }

  export type UsuarioMinOrderByAggregateInput = {
    idUsuario?: SortOrder
    nomeCompleto?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
    CTGId?: SortOrder
    numCarteirinha?: SortOrder
    login?: SortOrder
    senha?: SortOrder
    funcao?: SortOrder
    credenciamento?: SortOrder
    numCredenciamento?: SortOrder
    comissaoUsuarioId?: SortOrder
  }

  export type UsuarioSumOrderByAggregateInput = {
    idUsuario?: SortOrder
    CTGId?: SortOrder
    numCredenciamento?: SortOrder
    comissaoUsuarioId?: SortOrder
  }

  export type EnumFuncaoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Funcao | EnumFuncaoFieldRefInput<$PrismaModel>
    in?: $Enums.Funcao[] | ListEnumFuncaoFieldRefInput<$PrismaModel>
    notIn?: $Enums.Funcao[] | ListEnumFuncaoFieldRefInput<$PrismaModel>
    not?: NestedEnumFuncaoWithAggregatesFilter<$PrismaModel> | $Enums.Funcao
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFuncaoFilter<$PrismaModel>
    _max?: NestedEnumFuncaoFilter<$PrismaModel>
  }

  export type EnumCredenciamentoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Credenciamento | EnumCredenciamentoFieldRefInput<$PrismaModel>
    in?: $Enums.Credenciamento[] | ListEnumCredenciamentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.Credenciamento[] | ListEnumCredenciamentoFieldRefInput<$PrismaModel>
    not?: NestedEnumCredenciamentoWithAggregatesFilter<$PrismaModel> | $Enums.Credenciamento
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCredenciamentoFilter<$PrismaModel>
    _max?: NestedEnumCredenciamentoFilter<$PrismaModel>
  }

  export type RTScalarRelationFilter = {
    is?: RTWhereInput
    isNot?: RTWhereInput
  }

  export type UsuarioListRelationFilter = {
    every?: UsuarioWhereInput
    some?: UsuarioWhereInput
    none?: UsuarioWhereInput
  }

  export type CandidatoListRelationFilter = {
    every?: CandidatoWhereInput
    some?: CandidatoWhereInput
    none?: CandidatoWhereInput
  }

  export type UsuarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CandidatoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CTGCountOrderByAggregateInput = {
    idCTG?: SortOrder
    nomeCTG?: SortOrder
    RTid?: SortOrder
  }

  export type CTGAvgOrderByAggregateInput = {
    idCTG?: SortOrder
    RTid?: SortOrder
  }

  export type CTGMaxOrderByAggregateInput = {
    idCTG?: SortOrder
    nomeCTG?: SortOrder
    RTid?: SortOrder
  }

  export type CTGMinOrderByAggregateInput = {
    idCTG?: SortOrder
    nomeCTG?: SortOrder
    RTid?: SortOrder
  }

  export type CTGSumOrderByAggregateInput = {
    idCTG?: SortOrder
    RTid?: SortOrder
  }

  export type CTGListRelationFilter = {
    every?: CTGWhereInput
    some?: CTGWhereInput
    none?: CTGWhereInput
  }

  export type CTGOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RTCountOrderByAggregateInput = {
    idRT?: SortOrder
    nomeRT?: SortOrder
    numeroRT?: SortOrder
  }

  export type RTAvgOrderByAggregateInput = {
    idRT?: SortOrder
    numeroRT?: SortOrder
  }

  export type RTMaxOrderByAggregateInput = {
    idRT?: SortOrder
    nomeRT?: SortOrder
    numeroRT?: SortOrder
  }

  export type RTMinOrderByAggregateInput = {
    idRT?: SortOrder
    nomeRT?: SortOrder
    numeroRT?: SortOrder
  }

  export type RTSumOrderByAggregateInput = {
    idRT?: SortOrder
    numeroRT?: SortOrder
  }

  export type EnumDancaSalaoTradicionalFilter<$PrismaModel = never> = {
    equals?: $Enums.DancaSalaoTradicional | EnumDancaSalaoTradicionalFieldRefInput<$PrismaModel>
    in?: $Enums.DancaSalaoTradicional[] | ListEnumDancaSalaoTradicionalFieldRefInput<$PrismaModel>
    notIn?: $Enums.DancaSalaoTradicional[] | ListEnumDancaSalaoTradicionalFieldRefInput<$PrismaModel>
    not?: NestedEnumDancaSalaoTradicionalFilter<$PrismaModel> | $Enums.DancaSalaoTradicional
  }

  export type CandidatoScalarRelationFilter = {
    is?: CandidatoWhereInput
    isNot?: CandidatoWhereInput
  }

  export type SorteioDancaNullableScalarRelationFilter = {
    is?: SorteioDancaWhereInput | null
    isNot?: SorteioDancaWhereInput | null
  }

  export type QuesitosListRelationFilter = {
    every?: QuesitosWhereInput
    some?: QuesitosWhereInput
    none?: QuesitosWhereInput
  }

  export type QuesitosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PreferenciaSorteioDancaCountOrderByAggregateInput = {
    idPreferencia?: SortOrder
    nomeSorteioDanca?: SortOrder
    candidatoId?: SortOrder
    sorteioDancaId?: SortOrder
  }

  export type PreferenciaSorteioDancaAvgOrderByAggregateInput = {
    idPreferencia?: SortOrder
    candidatoId?: SortOrder
    sorteioDancaId?: SortOrder
  }

  export type PreferenciaSorteioDancaMaxOrderByAggregateInput = {
    idPreferencia?: SortOrder
    nomeSorteioDanca?: SortOrder
    candidatoId?: SortOrder
    sorteioDancaId?: SortOrder
  }

  export type PreferenciaSorteioDancaMinOrderByAggregateInput = {
    idPreferencia?: SortOrder
    nomeSorteioDanca?: SortOrder
    candidatoId?: SortOrder
    sorteioDancaId?: SortOrder
  }

  export type PreferenciaSorteioDancaSumOrderByAggregateInput = {
    idPreferencia?: SortOrder
    candidatoId?: SortOrder
    sorteioDancaId?: SortOrder
  }

  export type EnumDancaSalaoTradicionalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DancaSalaoTradicional | EnumDancaSalaoTradicionalFieldRefInput<$PrismaModel>
    in?: $Enums.DancaSalaoTradicional[] | ListEnumDancaSalaoTradicionalFieldRefInput<$PrismaModel>
    notIn?: $Enums.DancaSalaoTradicional[] | ListEnumDancaSalaoTradicionalFieldRefInput<$PrismaModel>
    not?: NestedEnumDancaSalaoTradicionalWithAggregatesFilter<$PrismaModel> | $Enums.DancaSalaoTradicional
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDancaSalaoTradicionalFilter<$PrismaModel>
    _max?: NestedEnumDancaSalaoTradicionalFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ComissaoListRelationFilter = {
    every?: ComissaoWhereInput
    some?: ComissaoWhereInput
    none?: ComissaoWhereInput
  }

  export type ComissaoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConcursoCountOrderByAggregateInput = {
    idConcurso?: SortOrder
    nomeConcurso?: SortOrder
    lancamentoEdital?: SortOrder
    inscricoesInicio?: SortOrder
    inscricoesFinal?: SortOrder
    dataProvaEscrita?: SortOrder
    dataProvasPraticas?: SortOrder
    dataResultado?: SortOrder
    local?: SortOrder
    anexoEdital?: SortOrder
  }

  export type ConcursoAvgOrderByAggregateInput = {
    idConcurso?: SortOrder
  }

  export type ConcursoMaxOrderByAggregateInput = {
    idConcurso?: SortOrder
    nomeConcurso?: SortOrder
    lancamentoEdital?: SortOrder
    inscricoesInicio?: SortOrder
    inscricoesFinal?: SortOrder
    dataProvaEscrita?: SortOrder
    dataProvasPraticas?: SortOrder
    dataResultado?: SortOrder
    local?: SortOrder
    anexoEdital?: SortOrder
  }

  export type ConcursoMinOrderByAggregateInput = {
    idConcurso?: SortOrder
    nomeConcurso?: SortOrder
    lancamentoEdital?: SortOrder
    inscricoesInicio?: SortOrder
    inscricoesFinal?: SortOrder
    dataProvaEscrita?: SortOrder
    dataProvasPraticas?: SortOrder
    dataResultado?: SortOrder
    local?: SortOrder
    anexoEdital?: SortOrder
  }

  export type ConcursoSumOrderByAggregateInput = {
    idConcurso?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type ConcursoScalarRelationFilter = {
    is?: ConcursoWhereInput
    isNot?: ConcursoWhereInput
  }

  export type ComissaoUsuarioListRelationFilter = {
    every?: ComissaoUsuarioWhereInput
    some?: ComissaoUsuarioWhereInput
    none?: ComissaoUsuarioWhereInput
  }

  export type ComissaoUsuarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComissaoCountOrderByAggregateInput = {
    idComissao?: SortOrder
    nomeComissao?: SortOrder
    concursoId?: SortOrder
  }

  export type ComissaoAvgOrderByAggregateInput = {
    idComissao?: SortOrder
    concursoId?: SortOrder
  }

  export type ComissaoMaxOrderByAggregateInput = {
    idComissao?: SortOrder
    nomeComissao?: SortOrder
    concursoId?: SortOrder
  }

  export type ComissaoMinOrderByAggregateInput = {
    idComissao?: SortOrder
    nomeComissao?: SortOrder
    concursoId?: SortOrder
  }

  export type ComissaoSumOrderByAggregateInput = {
    idComissao?: SortOrder
    concursoId?: SortOrder
  }

  export type ComissaoScalarRelationFilter = {
    is?: ComissaoWhereInput
    isNot?: ComissaoWhereInput
  }

  export type UsuarioScalarRelationFilter = {
    is?: UsuarioWhereInput
    isNot?: UsuarioWhereInput
  }

  export type ComissaoUsuarioComissaoIdUsuarioIdCompoundUniqueInput = {
    comissaoId: number
    usuarioId: number
  }

  export type ComissaoUsuarioCountOrderByAggregateInput = {
    idComissaoUsuario?: SortOrder
    comissaoId?: SortOrder
    usuarioId?: SortOrder
  }

  export type ComissaoUsuarioAvgOrderByAggregateInput = {
    idComissaoUsuario?: SortOrder
    comissaoId?: SortOrder
    usuarioId?: SortOrder
  }

  export type ComissaoUsuarioMaxOrderByAggregateInput = {
    idComissaoUsuario?: SortOrder
    comissaoId?: SortOrder
    usuarioId?: SortOrder
  }

  export type ComissaoUsuarioMinOrderByAggregateInput = {
    idComissaoUsuario?: SortOrder
    comissaoId?: SortOrder
    usuarioId?: SortOrder
  }

  export type ComissaoUsuarioSumOrderByAggregateInput = {
    idComissaoUsuario?: SortOrder
    comissaoId?: SortOrder
    usuarioId?: SortOrder
  }

  export type ProvaNullableScalarRelationFilter = {
    is?: ProvaWhereInput | null
    isNot?: ProvaWhereInput | null
  }

  export type ProvaTeoricaNullableScalarRelationFilter = {
    is?: ProvaTeoricaWhereInput | null
    isNot?: ProvaTeoricaWhereInput | null
  }

  export type ProvaPraticaNullableScalarRelationFilter = {
    is?: ProvaPraticaWhereInput | null
    isNot?: ProvaPraticaWhereInput | null
  }

  export type CategoriaCountOrderByAggregateInput = {
    idCategoria?: SortOrder
    nomeCategoria?: SortOrder
    escolaridade?: SortOrder
    sorteioDanca?: SortOrder
    idadeInicial?: SortOrder
    idadeLimite?: SortOrder
    provaId?: SortOrder
    provaTeoricaId?: SortOrder
    provaPraticaId?: SortOrder
  }

  export type CategoriaAvgOrderByAggregateInput = {
    idCategoria?: SortOrder
    sorteioDanca?: SortOrder
    idadeInicial?: SortOrder
    idadeLimite?: SortOrder
    provaId?: SortOrder
    provaTeoricaId?: SortOrder
    provaPraticaId?: SortOrder
  }

  export type CategoriaMaxOrderByAggregateInput = {
    idCategoria?: SortOrder
    nomeCategoria?: SortOrder
    escolaridade?: SortOrder
    sorteioDanca?: SortOrder
    idadeInicial?: SortOrder
    idadeLimite?: SortOrder
    provaId?: SortOrder
    provaTeoricaId?: SortOrder
    provaPraticaId?: SortOrder
  }

  export type CategoriaMinOrderByAggregateInput = {
    idCategoria?: SortOrder
    nomeCategoria?: SortOrder
    escolaridade?: SortOrder
    sorteioDanca?: SortOrder
    idadeInicial?: SortOrder
    idadeLimite?: SortOrder
    provaId?: SortOrder
    provaTeoricaId?: SortOrder
    provaPraticaId?: SortOrder
  }

  export type CategoriaSumOrderByAggregateInput = {
    idCategoria?: SortOrder
    sorteioDanca?: SortOrder
    idadeInicial?: SortOrder
    idadeLimite?: SortOrder
    provaId?: SortOrder
    provaTeoricaId?: SortOrder
    provaPraticaId?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type BlocoProvaNullableScalarRelationFilter = {
    is?: BlocoProvaWhereInput | null
    isNot?: BlocoProvaWhereInput | null
  }

  export type FichaCandidatoNullableScalarRelationFilter = {
    is?: FichaCandidatoWhereInput | null
    isNot?: FichaCandidatoWhereInput | null
  }

  export type AvaliacaoCountOrderByAggregateInput = {
    idAvalicao?: SortOrder
    dataAvaliacao?: SortOrder
    comissaoId?: SortOrder
    avaliadorId?: SortOrder
    provaId?: SortOrder
    blocoProvaId?: SortOrder
    nota?: SortOrder
    candidatoId?: SortOrder
    fichaCandidatoIdFicha?: SortOrder
  }

  export type AvaliacaoAvgOrderByAggregateInput = {
    idAvalicao?: SortOrder
    comissaoId?: SortOrder
    avaliadorId?: SortOrder
    provaId?: SortOrder
    blocoProvaId?: SortOrder
    nota?: SortOrder
    candidatoId?: SortOrder
    fichaCandidatoIdFicha?: SortOrder
  }

  export type AvaliacaoMaxOrderByAggregateInput = {
    idAvalicao?: SortOrder
    dataAvaliacao?: SortOrder
    comissaoId?: SortOrder
    avaliadorId?: SortOrder
    provaId?: SortOrder
    blocoProvaId?: SortOrder
    nota?: SortOrder
    candidatoId?: SortOrder
    fichaCandidatoIdFicha?: SortOrder
  }

  export type AvaliacaoMinOrderByAggregateInput = {
    idAvalicao?: SortOrder
    dataAvaliacao?: SortOrder
    comissaoId?: SortOrder
    avaliadorId?: SortOrder
    provaId?: SortOrder
    blocoProvaId?: SortOrder
    nota?: SortOrder
    candidatoId?: SortOrder
    fichaCandidatoIdFicha?: SortOrder
  }

  export type AvaliacaoSumOrderByAggregateInput = {
    idAvalicao?: SortOrder
    comissaoId?: SortOrder
    avaliadorId?: SortOrder
    provaId?: SortOrder
    blocoProvaId?: SortOrder
    nota?: SortOrder
    candidatoId?: SortOrder
    fichaCandidatoIdFicha?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type CategoriaListRelationFilter = {
    every?: CategoriaWhereInput
    some?: CategoriaWhereInput
    none?: CategoriaWhereInput
  }

  export type ProvaTeoricaListRelationFilter = {
    every?: ProvaTeoricaWhereInput
    some?: ProvaTeoricaWhereInput
    none?: ProvaTeoricaWhereInput
  }

  export type ProvaPraticaListRelationFilter = {
    every?: ProvaPraticaWhereInput
    some?: ProvaPraticaWhereInput
    none?: ProvaPraticaWhereInput
  }

  export type CategoriaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProvaTeoricaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProvaPraticaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProvaCountOrderByAggregateInput = {
    idProva?: SortOrder
    nomeProva?: SortOrder
    notaMaxima?: SortOrder
  }

  export type ProvaAvgOrderByAggregateInput = {
    idProva?: SortOrder
    notaMaxima?: SortOrder
  }

  export type ProvaMaxOrderByAggregateInput = {
    idProva?: SortOrder
    nomeProva?: SortOrder
    notaMaxima?: SortOrder
  }

  export type ProvaMinOrderByAggregateInput = {
    idProva?: SortOrder
    nomeProva?: SortOrder
    notaMaxima?: SortOrder
  }

  export type ProvaSumOrderByAggregateInput = {
    idProva?: SortOrder
    notaMaxima?: SortOrder
  }

  export type BytesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel>
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Bytes
  }

  export type ProvaTeoricaCountOrderByAggregateInput = {
    idprovaTeorica?: SortOrder
    provaId?: SortOrder
    gabaritoOficinal?: SortOrder
    numQuestao?: SortOrder
  }

  export type ProvaTeoricaAvgOrderByAggregateInput = {
    idprovaTeorica?: SortOrder
    provaId?: SortOrder
    numQuestao?: SortOrder
  }

  export type ProvaTeoricaMaxOrderByAggregateInput = {
    idprovaTeorica?: SortOrder
    provaId?: SortOrder
    gabaritoOficinal?: SortOrder
    numQuestao?: SortOrder
  }

  export type ProvaTeoricaMinOrderByAggregateInput = {
    idprovaTeorica?: SortOrder
    provaId?: SortOrder
    gabaritoOficinal?: SortOrder
    numQuestao?: SortOrder
  }

  export type ProvaTeoricaSumOrderByAggregateInput = {
    idprovaTeorica?: SortOrder
    provaId?: SortOrder
    numQuestao?: SortOrder
  }

  export type BytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel>
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Bytes
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type BlocoProvaListRelationFilter = {
    every?: BlocoProvaWhereInput
    some?: BlocoProvaWhereInput
    none?: BlocoProvaWhereInput
  }

  export type BlocoProvaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProvaPraticaCountOrderByAggregateInput = {
    idProvaPratica?: SortOrder
    provaId?: SortOrder
  }

  export type ProvaPraticaAvgOrderByAggregateInput = {
    idProvaPratica?: SortOrder
    provaId?: SortOrder
  }

  export type ProvaPraticaMaxOrderByAggregateInput = {
    idProvaPratica?: SortOrder
    provaId?: SortOrder
  }

  export type ProvaPraticaMinOrderByAggregateInput = {
    idProvaPratica?: SortOrder
    provaId?: SortOrder
  }

  export type ProvaPraticaSumOrderByAggregateInput = {
    idProvaPratica?: SortOrder
    provaId?: SortOrder
  }

  export type BlocoProvaCountOrderByAggregateInput = {
    idBloco?: SortOrder
    nomeBloco?: SortOrder
    notaMaximaBloco?: SortOrder
    provaPraticaId?: SortOrder
  }

  export type BlocoProvaAvgOrderByAggregateInput = {
    idBloco?: SortOrder
    notaMaximaBloco?: SortOrder
    provaPraticaId?: SortOrder
  }

  export type BlocoProvaMaxOrderByAggregateInput = {
    idBloco?: SortOrder
    nomeBloco?: SortOrder
    notaMaximaBloco?: SortOrder
    provaPraticaId?: SortOrder
  }

  export type BlocoProvaMinOrderByAggregateInput = {
    idBloco?: SortOrder
    nomeBloco?: SortOrder
    notaMaximaBloco?: SortOrder
    provaPraticaId?: SortOrder
  }

  export type BlocoProvaSumOrderByAggregateInput = {
    idBloco?: SortOrder
    notaMaximaBloco?: SortOrder
    provaPraticaId?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type SubQuesitosListRelationFilter = {
    every?: SubQuesitosWhereInput
    some?: SubQuesitosWhereInput
    none?: SubQuesitosWhereInput
  }

  export type PreferenciaSorteioDancaNullableScalarRelationFilter = {
    is?: PreferenciaSorteioDancaWhereInput | null
    isNot?: PreferenciaSorteioDancaWhereInput | null
  }

  export type AvaliacaoNullableScalarRelationFilter = {
    is?: AvaliacaoWhereInput | null
    isNot?: AvaliacaoWhereInput | null
  }

  export type SubQuesitosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuesitosCountOrderByAggregateInput = {
    idQuesito?: SortOrder
    nomeQuesito?: SortOrder
    notaMaximaQuesito?: SortOrder
    danca?: SortOrder
    dancaSalaoTradicional?: SortOrder
    blocoProvaIdBloco?: SortOrder
    provaTeoricaIdprovaTeorica?: SortOrder
    preferenciaSorteioDancaId?: SortOrder
    avaliacaoIdAvalicao?: SortOrder
  }

  export type QuesitosAvgOrderByAggregateInput = {
    idQuesito?: SortOrder
    notaMaximaQuesito?: SortOrder
    blocoProvaIdBloco?: SortOrder
    provaTeoricaIdprovaTeorica?: SortOrder
    preferenciaSorteioDancaId?: SortOrder
    avaliacaoIdAvalicao?: SortOrder
  }

  export type QuesitosMaxOrderByAggregateInput = {
    idQuesito?: SortOrder
    nomeQuesito?: SortOrder
    notaMaximaQuesito?: SortOrder
    danca?: SortOrder
    dancaSalaoTradicional?: SortOrder
    blocoProvaIdBloco?: SortOrder
    provaTeoricaIdprovaTeorica?: SortOrder
    preferenciaSorteioDancaId?: SortOrder
    avaliacaoIdAvalicao?: SortOrder
  }

  export type QuesitosMinOrderByAggregateInput = {
    idQuesito?: SortOrder
    nomeQuesito?: SortOrder
    notaMaximaQuesito?: SortOrder
    danca?: SortOrder
    dancaSalaoTradicional?: SortOrder
    blocoProvaIdBloco?: SortOrder
    provaTeoricaIdprovaTeorica?: SortOrder
    preferenciaSorteioDancaId?: SortOrder
    avaliacaoIdAvalicao?: SortOrder
  }

  export type QuesitosSumOrderByAggregateInput = {
    idQuesito?: SortOrder
    notaMaximaQuesito?: SortOrder
    blocoProvaIdBloco?: SortOrder
    provaTeoricaIdprovaTeorica?: SortOrder
    preferenciaSorteioDancaId?: SortOrder
    avaliacaoIdAvalicao?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type QuesitosScalarRelationFilter = {
    is?: QuesitosWhereInput
    isNot?: QuesitosWhereInput
  }

  export type SubQuesitosCountOrderByAggregateInput = {
    idSubequestios?: SortOrder
    nomeSubquesito?: SortOrder
    notaSubequesito?: SortOrder
    quesitoId?: SortOrder
  }

  export type SubQuesitosAvgOrderByAggregateInput = {
    idSubequestios?: SortOrder
    notaSubequesito?: SortOrder
    quesitoId?: SortOrder
  }

  export type SubQuesitosMaxOrderByAggregateInput = {
    idSubequestios?: SortOrder
    nomeSubquesito?: SortOrder
    notaSubequesito?: SortOrder
    quesitoId?: SortOrder
  }

  export type SubQuesitosMinOrderByAggregateInput = {
    idSubequestios?: SortOrder
    nomeSubquesito?: SortOrder
    notaSubequesito?: SortOrder
    quesitoId?: SortOrder
  }

  export type SubQuesitosSumOrderByAggregateInput = {
    idSubequestios?: SortOrder
    notaSubequesito?: SortOrder
    quesitoId?: SortOrder
  }

  export type RecursoCountOrderByAggregateInput = {
    idRecurso?: SortOrder
    nomeRecurso?: SortOrder
    justificativa?: SortOrder
    status?: SortOrder
    dataRecurso?: SortOrder
    arquivos?: SortOrder
    candidato?: SortOrder
    avaliador?: SortOrder
    quesitoRecurso?: SortOrder
    provaTeoricaIdprovaTeorica?: SortOrder
    provaPraticaIdProvaPratica?: SortOrder
    provaIdProva?: SortOrder
  }

  export type RecursoAvgOrderByAggregateInput = {
    idRecurso?: SortOrder
    candidato?: SortOrder
    avaliador?: SortOrder
    quesitoRecurso?: SortOrder
    provaTeoricaIdprovaTeorica?: SortOrder
    provaPraticaIdProvaPratica?: SortOrder
    provaIdProva?: SortOrder
  }

  export type RecursoMaxOrderByAggregateInput = {
    idRecurso?: SortOrder
    nomeRecurso?: SortOrder
    justificativa?: SortOrder
    status?: SortOrder
    dataRecurso?: SortOrder
    arquivos?: SortOrder
    candidato?: SortOrder
    avaliador?: SortOrder
    quesitoRecurso?: SortOrder
    provaTeoricaIdprovaTeorica?: SortOrder
    provaPraticaIdProvaPratica?: SortOrder
    provaIdProva?: SortOrder
  }

  export type RecursoMinOrderByAggregateInput = {
    idRecurso?: SortOrder
    nomeRecurso?: SortOrder
    justificativa?: SortOrder
    status?: SortOrder
    dataRecurso?: SortOrder
    arquivos?: SortOrder
    candidato?: SortOrder
    avaliador?: SortOrder
    quesitoRecurso?: SortOrder
    provaTeoricaIdprovaTeorica?: SortOrder
    provaPraticaIdProvaPratica?: SortOrder
    provaIdProva?: SortOrder
  }

  export type RecursoSumOrderByAggregateInput = {
    idRecurso?: SortOrder
    candidato?: SortOrder
    avaliador?: SortOrder
    quesitoRecurso?: SortOrder
    provaTeoricaIdprovaTeorica?: SortOrder
    provaPraticaIdProvaPratica?: SortOrder
    provaIdProva?: SortOrder
  }

  export type SorteioDancaCountOrderByAggregateInput = {
    idSorteio?: SortOrder
    resultadoSorteio?: SortOrder
    dataSorteio?: SortOrder
    tipoDanca?: SortOrder
    candidatoId?: SortOrder
    usuarioId?: SortOrder
  }

  export type SorteioDancaAvgOrderByAggregateInput = {
    idSorteio?: SortOrder
    resultadoSorteio?: SortOrder
    candidatoId?: SortOrder
    usuarioId?: SortOrder
  }

  export type SorteioDancaMaxOrderByAggregateInput = {
    idSorteio?: SortOrder
    resultadoSorteio?: SortOrder
    dataSorteio?: SortOrder
    tipoDanca?: SortOrder
    candidatoId?: SortOrder
    usuarioId?: SortOrder
  }

  export type SorteioDancaMinOrderByAggregateInput = {
    idSorteio?: SortOrder
    resultadoSorteio?: SortOrder
    dataSorteio?: SortOrder
    tipoDanca?: SortOrder
    candidatoId?: SortOrder
    usuarioId?: SortOrder
  }

  export type SorteioDancaSumOrderByAggregateInput = {
    idSorteio?: SortOrder
    resultadoSorteio?: SortOrder
    candidatoId?: SortOrder
    usuarioId?: SortOrder
  }

  export type FichaCandidatoCountOrderByAggregateInput = {
    idFicha?: SortOrder
    candidatoId?: SortOrder
    notaCandidato?: SortOrder
    provaId?: SortOrder
    concursoId?: SortOrder
    categoriaId?: SortOrder
    anexoTermodeCiencia?: SortOrder
    dataTermo?: SortOrder
    numAcertosProvaTeorica?: SortOrder
    anexoGabarito?: SortOrder
    notaRedacao?: SortOrder
    anexoRedacao?: SortOrder
    anexoProvaPratica?: SortOrder
  }

  export type FichaCandidatoAvgOrderByAggregateInput = {
    idFicha?: SortOrder
    candidatoId?: SortOrder
    notaCandidato?: SortOrder
    provaId?: SortOrder
    concursoId?: SortOrder
    categoriaId?: SortOrder
    numAcertosProvaTeorica?: SortOrder
    notaRedacao?: SortOrder
  }

  export type FichaCandidatoMaxOrderByAggregateInput = {
    idFicha?: SortOrder
    candidatoId?: SortOrder
    notaCandidato?: SortOrder
    provaId?: SortOrder
    concursoId?: SortOrder
    categoriaId?: SortOrder
    anexoTermodeCiencia?: SortOrder
    dataTermo?: SortOrder
    numAcertosProvaTeorica?: SortOrder
    anexoGabarito?: SortOrder
    notaRedacao?: SortOrder
    anexoRedacao?: SortOrder
    anexoProvaPratica?: SortOrder
  }

  export type FichaCandidatoMinOrderByAggregateInput = {
    idFicha?: SortOrder
    candidatoId?: SortOrder
    notaCandidato?: SortOrder
    provaId?: SortOrder
    concursoId?: SortOrder
    categoriaId?: SortOrder
    anexoTermodeCiencia?: SortOrder
    dataTermo?: SortOrder
    numAcertosProvaTeorica?: SortOrder
    anexoGabarito?: SortOrder
    notaRedacao?: SortOrder
    anexoRedacao?: SortOrder
    anexoProvaPratica?: SortOrder
  }

  export type FichaCandidatoSumOrderByAggregateInput = {
    idFicha?: SortOrder
    candidatoId?: SortOrder
    notaCandidato?: SortOrder
    provaId?: SortOrder
    concursoId?: SortOrder
    categoriaId?: SortOrder
    numAcertosProvaTeorica?: SortOrder
    notaRedacao?: SortOrder
  }

  export type CTGCreateNestedOneWithoutCandidatoInput = {
    create?: XOR<CTGCreateWithoutCandidatoInput, CTGUncheckedCreateWithoutCandidatoInput>
    connectOrCreate?: CTGCreateOrConnectWithoutCandidatoInput
    connect?: CTGWhereUniqueInput
  }

  export type PreferenciaSorteioDancaCreateNestedManyWithoutCandidatoInput = {
    create?: XOR<PreferenciaSorteioDancaCreateWithoutCandidatoInput, PreferenciaSorteioDancaUncheckedCreateWithoutCandidatoInput> | PreferenciaSorteioDancaCreateWithoutCandidatoInput[] | PreferenciaSorteioDancaUncheckedCreateWithoutCandidatoInput[]
    connectOrCreate?: PreferenciaSorteioDancaCreateOrConnectWithoutCandidatoInput | PreferenciaSorteioDancaCreateOrConnectWithoutCandidatoInput[]
    createMany?: PreferenciaSorteioDancaCreateManyCandidatoInputEnvelope
    connect?: PreferenciaSorteioDancaWhereUniqueInput | PreferenciaSorteioDancaWhereUniqueInput[]
  }

  export type CategoriaCreateNestedOneWithoutCandidatosInput = {
    create?: XOR<CategoriaCreateWithoutCandidatosInput, CategoriaUncheckedCreateWithoutCandidatosInput>
    connectOrCreate?: CategoriaCreateOrConnectWithoutCandidatosInput
    connect?: CategoriaWhereUniqueInput
  }

  export type AvaliacaoCreateNestedManyWithoutCandidatoInput = {
    create?: XOR<AvaliacaoCreateWithoutCandidatoInput, AvaliacaoUncheckedCreateWithoutCandidatoInput> | AvaliacaoCreateWithoutCandidatoInput[] | AvaliacaoUncheckedCreateWithoutCandidatoInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutCandidatoInput | AvaliacaoCreateOrConnectWithoutCandidatoInput[]
    createMany?: AvaliacaoCreateManyCandidatoInputEnvelope
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
  }

  export type SorteioDancaCreateNestedManyWithoutCandidatoInput = {
    create?: XOR<SorteioDancaCreateWithoutCandidatoInput, SorteioDancaUncheckedCreateWithoutCandidatoInput> | SorteioDancaCreateWithoutCandidatoInput[] | SorteioDancaUncheckedCreateWithoutCandidatoInput[]
    connectOrCreate?: SorteioDancaCreateOrConnectWithoutCandidatoInput | SorteioDancaCreateOrConnectWithoutCandidatoInput[]
    createMany?: SorteioDancaCreateManyCandidatoInputEnvelope
    connect?: SorteioDancaWhereUniqueInput | SorteioDancaWhereUniqueInput[]
  }

  export type RecursoCreateNestedManyWithoutCandidatoInput = {
    create?: XOR<RecursoCreateWithoutCandidatoInput, RecursoUncheckedCreateWithoutCandidatoInput> | RecursoCreateWithoutCandidatoInput[] | RecursoUncheckedCreateWithoutCandidatoInput[]
    connectOrCreate?: RecursoCreateOrConnectWithoutCandidatoInput | RecursoCreateOrConnectWithoutCandidatoInput[]
    createMany?: RecursoCreateManyCandidatoInputEnvelope
    connect?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
  }

  export type ConcursoCreateNestedOneWithoutCandidatosInput = {
    create?: XOR<ConcursoCreateWithoutCandidatosInput, ConcursoUncheckedCreateWithoutCandidatosInput>
    connectOrCreate?: ConcursoCreateOrConnectWithoutCandidatosInput
    connect?: ConcursoWhereUniqueInput
  }

  export type PreferenciaSorteioDancaUncheckedCreateNestedManyWithoutCandidatoInput = {
    create?: XOR<PreferenciaSorteioDancaCreateWithoutCandidatoInput, PreferenciaSorteioDancaUncheckedCreateWithoutCandidatoInput> | PreferenciaSorteioDancaCreateWithoutCandidatoInput[] | PreferenciaSorteioDancaUncheckedCreateWithoutCandidatoInput[]
    connectOrCreate?: PreferenciaSorteioDancaCreateOrConnectWithoutCandidatoInput | PreferenciaSorteioDancaCreateOrConnectWithoutCandidatoInput[]
    createMany?: PreferenciaSorteioDancaCreateManyCandidatoInputEnvelope
    connect?: PreferenciaSorteioDancaWhereUniqueInput | PreferenciaSorteioDancaWhereUniqueInput[]
  }

  export type AvaliacaoUncheckedCreateNestedManyWithoutCandidatoInput = {
    create?: XOR<AvaliacaoCreateWithoutCandidatoInput, AvaliacaoUncheckedCreateWithoutCandidatoInput> | AvaliacaoCreateWithoutCandidatoInput[] | AvaliacaoUncheckedCreateWithoutCandidatoInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutCandidatoInput | AvaliacaoCreateOrConnectWithoutCandidatoInput[]
    createMany?: AvaliacaoCreateManyCandidatoInputEnvelope
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
  }

  export type SorteioDancaUncheckedCreateNestedManyWithoutCandidatoInput = {
    create?: XOR<SorteioDancaCreateWithoutCandidatoInput, SorteioDancaUncheckedCreateWithoutCandidatoInput> | SorteioDancaCreateWithoutCandidatoInput[] | SorteioDancaUncheckedCreateWithoutCandidatoInput[]
    connectOrCreate?: SorteioDancaCreateOrConnectWithoutCandidatoInput | SorteioDancaCreateOrConnectWithoutCandidatoInput[]
    createMany?: SorteioDancaCreateManyCandidatoInputEnvelope
    connect?: SorteioDancaWhereUniqueInput | SorteioDancaWhereUniqueInput[]
  }

  export type RecursoUncheckedCreateNestedManyWithoutCandidatoInput = {
    create?: XOR<RecursoCreateWithoutCandidatoInput, RecursoUncheckedCreateWithoutCandidatoInput> | RecursoCreateWithoutCandidatoInput[] | RecursoUncheckedCreateWithoutCandidatoInput[]
    connectOrCreate?: RecursoCreateOrConnectWithoutCandidatoInput | RecursoCreateOrConnectWithoutCandidatoInput[]
    createMany?: RecursoCreateManyCandidatoInputEnvelope
    connect?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumProvaCampeiraEsportivaFieldUpdateOperationsInput = {
    set?: $Enums.ProvaCampeiraEsportiva | null
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Bytes | null
  }

  export type CTGUpdateOneRequiredWithoutCandidatoNestedInput = {
    create?: XOR<CTGCreateWithoutCandidatoInput, CTGUncheckedCreateWithoutCandidatoInput>
    connectOrCreate?: CTGCreateOrConnectWithoutCandidatoInput
    upsert?: CTGUpsertWithoutCandidatoInput
    connect?: CTGWhereUniqueInput
    update?: XOR<XOR<CTGUpdateToOneWithWhereWithoutCandidatoInput, CTGUpdateWithoutCandidatoInput>, CTGUncheckedUpdateWithoutCandidatoInput>
  }

  export type PreferenciaSorteioDancaUpdateManyWithoutCandidatoNestedInput = {
    create?: XOR<PreferenciaSorteioDancaCreateWithoutCandidatoInput, PreferenciaSorteioDancaUncheckedCreateWithoutCandidatoInput> | PreferenciaSorteioDancaCreateWithoutCandidatoInput[] | PreferenciaSorteioDancaUncheckedCreateWithoutCandidatoInput[]
    connectOrCreate?: PreferenciaSorteioDancaCreateOrConnectWithoutCandidatoInput | PreferenciaSorteioDancaCreateOrConnectWithoutCandidatoInput[]
    upsert?: PreferenciaSorteioDancaUpsertWithWhereUniqueWithoutCandidatoInput | PreferenciaSorteioDancaUpsertWithWhereUniqueWithoutCandidatoInput[]
    createMany?: PreferenciaSorteioDancaCreateManyCandidatoInputEnvelope
    set?: PreferenciaSorteioDancaWhereUniqueInput | PreferenciaSorteioDancaWhereUniqueInput[]
    disconnect?: PreferenciaSorteioDancaWhereUniqueInput | PreferenciaSorteioDancaWhereUniqueInput[]
    delete?: PreferenciaSorteioDancaWhereUniqueInput | PreferenciaSorteioDancaWhereUniqueInput[]
    connect?: PreferenciaSorteioDancaWhereUniqueInput | PreferenciaSorteioDancaWhereUniqueInput[]
    update?: PreferenciaSorteioDancaUpdateWithWhereUniqueWithoutCandidatoInput | PreferenciaSorteioDancaUpdateWithWhereUniqueWithoutCandidatoInput[]
    updateMany?: PreferenciaSorteioDancaUpdateManyWithWhereWithoutCandidatoInput | PreferenciaSorteioDancaUpdateManyWithWhereWithoutCandidatoInput[]
    deleteMany?: PreferenciaSorteioDancaScalarWhereInput | PreferenciaSorteioDancaScalarWhereInput[]
  }

  export type CategoriaUpdateOneRequiredWithoutCandidatosNestedInput = {
    create?: XOR<CategoriaCreateWithoutCandidatosInput, CategoriaUncheckedCreateWithoutCandidatosInput>
    connectOrCreate?: CategoriaCreateOrConnectWithoutCandidatosInput
    upsert?: CategoriaUpsertWithoutCandidatosInput
    connect?: CategoriaWhereUniqueInput
    update?: XOR<XOR<CategoriaUpdateToOneWithWhereWithoutCandidatosInput, CategoriaUpdateWithoutCandidatosInput>, CategoriaUncheckedUpdateWithoutCandidatosInput>
  }

  export type AvaliacaoUpdateManyWithoutCandidatoNestedInput = {
    create?: XOR<AvaliacaoCreateWithoutCandidatoInput, AvaliacaoUncheckedCreateWithoutCandidatoInput> | AvaliacaoCreateWithoutCandidatoInput[] | AvaliacaoUncheckedCreateWithoutCandidatoInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutCandidatoInput | AvaliacaoCreateOrConnectWithoutCandidatoInput[]
    upsert?: AvaliacaoUpsertWithWhereUniqueWithoutCandidatoInput | AvaliacaoUpsertWithWhereUniqueWithoutCandidatoInput[]
    createMany?: AvaliacaoCreateManyCandidatoInputEnvelope
    set?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    disconnect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    delete?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    update?: AvaliacaoUpdateWithWhereUniqueWithoutCandidatoInput | AvaliacaoUpdateWithWhereUniqueWithoutCandidatoInput[]
    updateMany?: AvaliacaoUpdateManyWithWhereWithoutCandidatoInput | AvaliacaoUpdateManyWithWhereWithoutCandidatoInput[]
    deleteMany?: AvaliacaoScalarWhereInput | AvaliacaoScalarWhereInput[]
  }

  export type SorteioDancaUpdateManyWithoutCandidatoNestedInput = {
    create?: XOR<SorteioDancaCreateWithoutCandidatoInput, SorteioDancaUncheckedCreateWithoutCandidatoInput> | SorteioDancaCreateWithoutCandidatoInput[] | SorteioDancaUncheckedCreateWithoutCandidatoInput[]
    connectOrCreate?: SorteioDancaCreateOrConnectWithoutCandidatoInput | SorteioDancaCreateOrConnectWithoutCandidatoInput[]
    upsert?: SorteioDancaUpsertWithWhereUniqueWithoutCandidatoInput | SorteioDancaUpsertWithWhereUniqueWithoutCandidatoInput[]
    createMany?: SorteioDancaCreateManyCandidatoInputEnvelope
    set?: SorteioDancaWhereUniqueInput | SorteioDancaWhereUniqueInput[]
    disconnect?: SorteioDancaWhereUniqueInput | SorteioDancaWhereUniqueInput[]
    delete?: SorteioDancaWhereUniqueInput | SorteioDancaWhereUniqueInput[]
    connect?: SorteioDancaWhereUniqueInput | SorteioDancaWhereUniqueInput[]
    update?: SorteioDancaUpdateWithWhereUniqueWithoutCandidatoInput | SorteioDancaUpdateWithWhereUniqueWithoutCandidatoInput[]
    updateMany?: SorteioDancaUpdateManyWithWhereWithoutCandidatoInput | SorteioDancaUpdateManyWithWhereWithoutCandidatoInput[]
    deleteMany?: SorteioDancaScalarWhereInput | SorteioDancaScalarWhereInput[]
  }

  export type RecursoUpdateManyWithoutCandidatoNestedInput = {
    create?: XOR<RecursoCreateWithoutCandidatoInput, RecursoUncheckedCreateWithoutCandidatoInput> | RecursoCreateWithoutCandidatoInput[] | RecursoUncheckedCreateWithoutCandidatoInput[]
    connectOrCreate?: RecursoCreateOrConnectWithoutCandidatoInput | RecursoCreateOrConnectWithoutCandidatoInput[]
    upsert?: RecursoUpsertWithWhereUniqueWithoutCandidatoInput | RecursoUpsertWithWhereUniqueWithoutCandidatoInput[]
    createMany?: RecursoCreateManyCandidatoInputEnvelope
    set?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    disconnect?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    delete?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    connect?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    update?: RecursoUpdateWithWhereUniqueWithoutCandidatoInput | RecursoUpdateWithWhereUniqueWithoutCandidatoInput[]
    updateMany?: RecursoUpdateManyWithWhereWithoutCandidatoInput | RecursoUpdateManyWithWhereWithoutCandidatoInput[]
    deleteMany?: RecursoScalarWhereInput | RecursoScalarWhereInput[]
  }

  export type ConcursoUpdateOneWithoutCandidatosNestedInput = {
    create?: XOR<ConcursoCreateWithoutCandidatosInput, ConcursoUncheckedCreateWithoutCandidatosInput>
    connectOrCreate?: ConcursoCreateOrConnectWithoutCandidatosInput
    upsert?: ConcursoUpsertWithoutCandidatosInput
    disconnect?: ConcursoWhereInput | boolean
    delete?: ConcursoWhereInput | boolean
    connect?: ConcursoWhereUniqueInput
    update?: XOR<XOR<ConcursoUpdateToOneWithWhereWithoutCandidatosInput, ConcursoUpdateWithoutCandidatosInput>, ConcursoUncheckedUpdateWithoutCandidatosInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PreferenciaSorteioDancaUncheckedUpdateManyWithoutCandidatoNestedInput = {
    create?: XOR<PreferenciaSorteioDancaCreateWithoutCandidatoInput, PreferenciaSorteioDancaUncheckedCreateWithoutCandidatoInput> | PreferenciaSorteioDancaCreateWithoutCandidatoInput[] | PreferenciaSorteioDancaUncheckedCreateWithoutCandidatoInput[]
    connectOrCreate?: PreferenciaSorteioDancaCreateOrConnectWithoutCandidatoInput | PreferenciaSorteioDancaCreateOrConnectWithoutCandidatoInput[]
    upsert?: PreferenciaSorteioDancaUpsertWithWhereUniqueWithoutCandidatoInput | PreferenciaSorteioDancaUpsertWithWhereUniqueWithoutCandidatoInput[]
    createMany?: PreferenciaSorteioDancaCreateManyCandidatoInputEnvelope
    set?: PreferenciaSorteioDancaWhereUniqueInput | PreferenciaSorteioDancaWhereUniqueInput[]
    disconnect?: PreferenciaSorteioDancaWhereUniqueInput | PreferenciaSorteioDancaWhereUniqueInput[]
    delete?: PreferenciaSorteioDancaWhereUniqueInput | PreferenciaSorteioDancaWhereUniqueInput[]
    connect?: PreferenciaSorteioDancaWhereUniqueInput | PreferenciaSorteioDancaWhereUniqueInput[]
    update?: PreferenciaSorteioDancaUpdateWithWhereUniqueWithoutCandidatoInput | PreferenciaSorteioDancaUpdateWithWhereUniqueWithoutCandidatoInput[]
    updateMany?: PreferenciaSorteioDancaUpdateManyWithWhereWithoutCandidatoInput | PreferenciaSorteioDancaUpdateManyWithWhereWithoutCandidatoInput[]
    deleteMany?: PreferenciaSorteioDancaScalarWhereInput | PreferenciaSorteioDancaScalarWhereInput[]
  }

  export type AvaliacaoUncheckedUpdateManyWithoutCandidatoNestedInput = {
    create?: XOR<AvaliacaoCreateWithoutCandidatoInput, AvaliacaoUncheckedCreateWithoutCandidatoInput> | AvaliacaoCreateWithoutCandidatoInput[] | AvaliacaoUncheckedCreateWithoutCandidatoInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutCandidatoInput | AvaliacaoCreateOrConnectWithoutCandidatoInput[]
    upsert?: AvaliacaoUpsertWithWhereUniqueWithoutCandidatoInput | AvaliacaoUpsertWithWhereUniqueWithoutCandidatoInput[]
    createMany?: AvaliacaoCreateManyCandidatoInputEnvelope
    set?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    disconnect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    delete?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    update?: AvaliacaoUpdateWithWhereUniqueWithoutCandidatoInput | AvaliacaoUpdateWithWhereUniqueWithoutCandidatoInput[]
    updateMany?: AvaliacaoUpdateManyWithWhereWithoutCandidatoInput | AvaliacaoUpdateManyWithWhereWithoutCandidatoInput[]
    deleteMany?: AvaliacaoScalarWhereInput | AvaliacaoScalarWhereInput[]
  }

  export type SorteioDancaUncheckedUpdateManyWithoutCandidatoNestedInput = {
    create?: XOR<SorteioDancaCreateWithoutCandidatoInput, SorteioDancaUncheckedCreateWithoutCandidatoInput> | SorteioDancaCreateWithoutCandidatoInput[] | SorteioDancaUncheckedCreateWithoutCandidatoInput[]
    connectOrCreate?: SorteioDancaCreateOrConnectWithoutCandidatoInput | SorteioDancaCreateOrConnectWithoutCandidatoInput[]
    upsert?: SorteioDancaUpsertWithWhereUniqueWithoutCandidatoInput | SorteioDancaUpsertWithWhereUniqueWithoutCandidatoInput[]
    createMany?: SorteioDancaCreateManyCandidatoInputEnvelope
    set?: SorteioDancaWhereUniqueInput | SorteioDancaWhereUniqueInput[]
    disconnect?: SorteioDancaWhereUniqueInput | SorteioDancaWhereUniqueInput[]
    delete?: SorteioDancaWhereUniqueInput | SorteioDancaWhereUniqueInput[]
    connect?: SorteioDancaWhereUniqueInput | SorteioDancaWhereUniqueInput[]
    update?: SorteioDancaUpdateWithWhereUniqueWithoutCandidatoInput | SorteioDancaUpdateWithWhereUniqueWithoutCandidatoInput[]
    updateMany?: SorteioDancaUpdateManyWithWhereWithoutCandidatoInput | SorteioDancaUpdateManyWithWhereWithoutCandidatoInput[]
    deleteMany?: SorteioDancaScalarWhereInput | SorteioDancaScalarWhereInput[]
  }

  export type RecursoUncheckedUpdateManyWithoutCandidatoNestedInput = {
    create?: XOR<RecursoCreateWithoutCandidatoInput, RecursoUncheckedCreateWithoutCandidatoInput> | RecursoCreateWithoutCandidatoInput[] | RecursoUncheckedCreateWithoutCandidatoInput[]
    connectOrCreate?: RecursoCreateOrConnectWithoutCandidatoInput | RecursoCreateOrConnectWithoutCandidatoInput[]
    upsert?: RecursoUpsertWithWhereUniqueWithoutCandidatoInput | RecursoUpsertWithWhereUniqueWithoutCandidatoInput[]
    createMany?: RecursoCreateManyCandidatoInputEnvelope
    set?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    disconnect?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    delete?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    connect?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    update?: RecursoUpdateWithWhereUniqueWithoutCandidatoInput | RecursoUpdateWithWhereUniqueWithoutCandidatoInput[]
    updateMany?: RecursoUpdateManyWithWhereWithoutCandidatoInput | RecursoUpdateManyWithWhereWithoutCandidatoInput[]
    deleteMany?: RecursoScalarWhereInput | RecursoScalarWhereInput[]
  }

  export type CTGCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<CTGCreateWithoutUsuarioInput, CTGUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: CTGCreateOrConnectWithoutUsuarioInput
    connect?: CTGWhereUniqueInput
  }

  export type ComissaoUsuarioCreateNestedOneWithoutUsuariosInput = {
    create?: XOR<ComissaoUsuarioCreateWithoutUsuariosInput, ComissaoUsuarioUncheckedCreateWithoutUsuariosInput>
    connectOrCreate?: ComissaoUsuarioCreateOrConnectWithoutUsuariosInput
    connect?: ComissaoUsuarioWhereUniqueInput
  }

  export type AvaliacaoCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<AvaliacaoCreateWithoutUsuarioInput, AvaliacaoUncheckedCreateWithoutUsuarioInput> | AvaliacaoCreateWithoutUsuarioInput[] | AvaliacaoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutUsuarioInput | AvaliacaoCreateOrConnectWithoutUsuarioInput[]
    createMany?: AvaliacaoCreateManyUsuarioInputEnvelope
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
  }

  export type RecursoCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<RecursoCreateWithoutUsuarioInput, RecursoUncheckedCreateWithoutUsuarioInput> | RecursoCreateWithoutUsuarioInput[] | RecursoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: RecursoCreateOrConnectWithoutUsuarioInput | RecursoCreateOrConnectWithoutUsuarioInput[]
    createMany?: RecursoCreateManyUsuarioInputEnvelope
    connect?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
  }

  export type SorteioDancaCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<SorteioDancaCreateWithoutUsuarioInput, SorteioDancaUncheckedCreateWithoutUsuarioInput> | SorteioDancaCreateWithoutUsuarioInput[] | SorteioDancaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: SorteioDancaCreateOrConnectWithoutUsuarioInput | SorteioDancaCreateOrConnectWithoutUsuarioInput[]
    createMany?: SorteioDancaCreateManyUsuarioInputEnvelope
    connect?: SorteioDancaWhereUniqueInput | SorteioDancaWhereUniqueInput[]
  }

  export type ComissaoUsuarioUncheckedCreateNestedOneWithoutUsuariosInput = {
    create?: XOR<ComissaoUsuarioCreateWithoutUsuariosInput, ComissaoUsuarioUncheckedCreateWithoutUsuariosInput>
    connectOrCreate?: ComissaoUsuarioCreateOrConnectWithoutUsuariosInput
    connect?: ComissaoUsuarioWhereUniqueInput
  }

  export type AvaliacaoUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<AvaliacaoCreateWithoutUsuarioInput, AvaliacaoUncheckedCreateWithoutUsuarioInput> | AvaliacaoCreateWithoutUsuarioInput[] | AvaliacaoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutUsuarioInput | AvaliacaoCreateOrConnectWithoutUsuarioInput[]
    createMany?: AvaliacaoCreateManyUsuarioInputEnvelope
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
  }

  export type RecursoUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<RecursoCreateWithoutUsuarioInput, RecursoUncheckedCreateWithoutUsuarioInput> | RecursoCreateWithoutUsuarioInput[] | RecursoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: RecursoCreateOrConnectWithoutUsuarioInput | RecursoCreateOrConnectWithoutUsuarioInput[]
    createMany?: RecursoCreateManyUsuarioInputEnvelope
    connect?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
  }

  export type SorteioDancaUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<SorteioDancaCreateWithoutUsuarioInput, SorteioDancaUncheckedCreateWithoutUsuarioInput> | SorteioDancaCreateWithoutUsuarioInput[] | SorteioDancaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: SorteioDancaCreateOrConnectWithoutUsuarioInput | SorteioDancaCreateOrConnectWithoutUsuarioInput[]
    createMany?: SorteioDancaCreateManyUsuarioInputEnvelope
    connect?: SorteioDancaWhereUniqueInput | SorteioDancaWhereUniqueInput[]
  }

  export type EnumFuncaoFieldUpdateOperationsInput = {
    set?: $Enums.Funcao
  }

  export type EnumCredenciamentoFieldUpdateOperationsInput = {
    set?: $Enums.Credenciamento
  }

  export type CTGUpdateOneRequiredWithoutUsuarioNestedInput = {
    create?: XOR<CTGCreateWithoutUsuarioInput, CTGUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: CTGCreateOrConnectWithoutUsuarioInput
    upsert?: CTGUpsertWithoutUsuarioInput
    connect?: CTGWhereUniqueInput
    update?: XOR<XOR<CTGUpdateToOneWithWhereWithoutUsuarioInput, CTGUpdateWithoutUsuarioInput>, CTGUncheckedUpdateWithoutUsuarioInput>
  }

  export type ComissaoUsuarioUpdateOneWithoutUsuariosNestedInput = {
    create?: XOR<ComissaoUsuarioCreateWithoutUsuariosInput, ComissaoUsuarioUncheckedCreateWithoutUsuariosInput>
    connectOrCreate?: ComissaoUsuarioCreateOrConnectWithoutUsuariosInput
    upsert?: ComissaoUsuarioUpsertWithoutUsuariosInput
    disconnect?: ComissaoUsuarioWhereInput | boolean
    delete?: ComissaoUsuarioWhereInput | boolean
    connect?: ComissaoUsuarioWhereUniqueInput
    update?: XOR<XOR<ComissaoUsuarioUpdateToOneWithWhereWithoutUsuariosInput, ComissaoUsuarioUpdateWithoutUsuariosInput>, ComissaoUsuarioUncheckedUpdateWithoutUsuariosInput>
  }

  export type AvaliacaoUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<AvaliacaoCreateWithoutUsuarioInput, AvaliacaoUncheckedCreateWithoutUsuarioInput> | AvaliacaoCreateWithoutUsuarioInput[] | AvaliacaoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutUsuarioInput | AvaliacaoCreateOrConnectWithoutUsuarioInput[]
    upsert?: AvaliacaoUpsertWithWhereUniqueWithoutUsuarioInput | AvaliacaoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: AvaliacaoCreateManyUsuarioInputEnvelope
    set?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    disconnect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    delete?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    update?: AvaliacaoUpdateWithWhereUniqueWithoutUsuarioInput | AvaliacaoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: AvaliacaoUpdateManyWithWhereWithoutUsuarioInput | AvaliacaoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: AvaliacaoScalarWhereInput | AvaliacaoScalarWhereInput[]
  }

  export type RecursoUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<RecursoCreateWithoutUsuarioInput, RecursoUncheckedCreateWithoutUsuarioInput> | RecursoCreateWithoutUsuarioInput[] | RecursoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: RecursoCreateOrConnectWithoutUsuarioInput | RecursoCreateOrConnectWithoutUsuarioInput[]
    upsert?: RecursoUpsertWithWhereUniqueWithoutUsuarioInput | RecursoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: RecursoCreateManyUsuarioInputEnvelope
    set?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    disconnect?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    delete?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    connect?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    update?: RecursoUpdateWithWhereUniqueWithoutUsuarioInput | RecursoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: RecursoUpdateManyWithWhereWithoutUsuarioInput | RecursoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: RecursoScalarWhereInput | RecursoScalarWhereInput[]
  }

  export type SorteioDancaUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<SorteioDancaCreateWithoutUsuarioInput, SorteioDancaUncheckedCreateWithoutUsuarioInput> | SorteioDancaCreateWithoutUsuarioInput[] | SorteioDancaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: SorteioDancaCreateOrConnectWithoutUsuarioInput | SorteioDancaCreateOrConnectWithoutUsuarioInput[]
    upsert?: SorteioDancaUpsertWithWhereUniqueWithoutUsuarioInput | SorteioDancaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: SorteioDancaCreateManyUsuarioInputEnvelope
    set?: SorteioDancaWhereUniqueInput | SorteioDancaWhereUniqueInput[]
    disconnect?: SorteioDancaWhereUniqueInput | SorteioDancaWhereUniqueInput[]
    delete?: SorteioDancaWhereUniqueInput | SorteioDancaWhereUniqueInput[]
    connect?: SorteioDancaWhereUniqueInput | SorteioDancaWhereUniqueInput[]
    update?: SorteioDancaUpdateWithWhereUniqueWithoutUsuarioInput | SorteioDancaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: SorteioDancaUpdateManyWithWhereWithoutUsuarioInput | SorteioDancaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: SorteioDancaScalarWhereInput | SorteioDancaScalarWhereInput[]
  }

  export type ComissaoUsuarioUncheckedUpdateOneWithoutUsuariosNestedInput = {
    create?: XOR<ComissaoUsuarioCreateWithoutUsuariosInput, ComissaoUsuarioUncheckedCreateWithoutUsuariosInput>
    connectOrCreate?: ComissaoUsuarioCreateOrConnectWithoutUsuariosInput
    upsert?: ComissaoUsuarioUpsertWithoutUsuariosInput
    disconnect?: ComissaoUsuarioWhereInput | boolean
    delete?: ComissaoUsuarioWhereInput | boolean
    connect?: ComissaoUsuarioWhereUniqueInput
    update?: XOR<XOR<ComissaoUsuarioUpdateToOneWithWhereWithoutUsuariosInput, ComissaoUsuarioUpdateWithoutUsuariosInput>, ComissaoUsuarioUncheckedUpdateWithoutUsuariosInput>
  }

  export type AvaliacaoUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<AvaliacaoCreateWithoutUsuarioInput, AvaliacaoUncheckedCreateWithoutUsuarioInput> | AvaliacaoCreateWithoutUsuarioInput[] | AvaliacaoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutUsuarioInput | AvaliacaoCreateOrConnectWithoutUsuarioInput[]
    upsert?: AvaliacaoUpsertWithWhereUniqueWithoutUsuarioInput | AvaliacaoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: AvaliacaoCreateManyUsuarioInputEnvelope
    set?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    disconnect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    delete?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    update?: AvaliacaoUpdateWithWhereUniqueWithoutUsuarioInput | AvaliacaoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: AvaliacaoUpdateManyWithWhereWithoutUsuarioInput | AvaliacaoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: AvaliacaoScalarWhereInput | AvaliacaoScalarWhereInput[]
  }

  export type RecursoUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<RecursoCreateWithoutUsuarioInput, RecursoUncheckedCreateWithoutUsuarioInput> | RecursoCreateWithoutUsuarioInput[] | RecursoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: RecursoCreateOrConnectWithoutUsuarioInput | RecursoCreateOrConnectWithoutUsuarioInput[]
    upsert?: RecursoUpsertWithWhereUniqueWithoutUsuarioInput | RecursoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: RecursoCreateManyUsuarioInputEnvelope
    set?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    disconnect?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    delete?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    connect?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    update?: RecursoUpdateWithWhereUniqueWithoutUsuarioInput | RecursoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: RecursoUpdateManyWithWhereWithoutUsuarioInput | RecursoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: RecursoScalarWhereInput | RecursoScalarWhereInput[]
  }

  export type SorteioDancaUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<SorteioDancaCreateWithoutUsuarioInput, SorteioDancaUncheckedCreateWithoutUsuarioInput> | SorteioDancaCreateWithoutUsuarioInput[] | SorteioDancaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: SorteioDancaCreateOrConnectWithoutUsuarioInput | SorteioDancaCreateOrConnectWithoutUsuarioInput[]
    upsert?: SorteioDancaUpsertWithWhereUniqueWithoutUsuarioInput | SorteioDancaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: SorteioDancaCreateManyUsuarioInputEnvelope
    set?: SorteioDancaWhereUniqueInput | SorteioDancaWhereUniqueInput[]
    disconnect?: SorteioDancaWhereUniqueInput | SorteioDancaWhereUniqueInput[]
    delete?: SorteioDancaWhereUniqueInput | SorteioDancaWhereUniqueInput[]
    connect?: SorteioDancaWhereUniqueInput | SorteioDancaWhereUniqueInput[]
    update?: SorteioDancaUpdateWithWhereUniqueWithoutUsuarioInput | SorteioDancaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: SorteioDancaUpdateManyWithWhereWithoutUsuarioInput | SorteioDancaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: SorteioDancaScalarWhereInput | SorteioDancaScalarWhereInput[]
  }

  export type RTCreateNestedOneWithoutCTGsInput = {
    create?: XOR<RTCreateWithoutCTGsInput, RTUncheckedCreateWithoutCTGsInput>
    connectOrCreate?: RTCreateOrConnectWithoutCTGsInput
    connect?: RTWhereUniqueInput
  }

  export type UsuarioCreateNestedManyWithoutCTGInput = {
    create?: XOR<UsuarioCreateWithoutCTGInput, UsuarioUncheckedCreateWithoutCTGInput> | UsuarioCreateWithoutCTGInput[] | UsuarioUncheckedCreateWithoutCTGInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutCTGInput | UsuarioCreateOrConnectWithoutCTGInput[]
    createMany?: UsuarioCreateManyCTGInputEnvelope
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
  }

  export type CandidatoCreateNestedManyWithoutCTGInput = {
    create?: XOR<CandidatoCreateWithoutCTGInput, CandidatoUncheckedCreateWithoutCTGInput> | CandidatoCreateWithoutCTGInput[] | CandidatoUncheckedCreateWithoutCTGInput[]
    connectOrCreate?: CandidatoCreateOrConnectWithoutCTGInput | CandidatoCreateOrConnectWithoutCTGInput[]
    createMany?: CandidatoCreateManyCTGInputEnvelope
    connect?: CandidatoWhereUniqueInput | CandidatoWhereUniqueInput[]
  }

  export type UsuarioUncheckedCreateNestedManyWithoutCTGInput = {
    create?: XOR<UsuarioCreateWithoutCTGInput, UsuarioUncheckedCreateWithoutCTGInput> | UsuarioCreateWithoutCTGInput[] | UsuarioUncheckedCreateWithoutCTGInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutCTGInput | UsuarioCreateOrConnectWithoutCTGInput[]
    createMany?: UsuarioCreateManyCTGInputEnvelope
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
  }

  export type CandidatoUncheckedCreateNestedManyWithoutCTGInput = {
    create?: XOR<CandidatoCreateWithoutCTGInput, CandidatoUncheckedCreateWithoutCTGInput> | CandidatoCreateWithoutCTGInput[] | CandidatoUncheckedCreateWithoutCTGInput[]
    connectOrCreate?: CandidatoCreateOrConnectWithoutCTGInput | CandidatoCreateOrConnectWithoutCTGInput[]
    createMany?: CandidatoCreateManyCTGInputEnvelope
    connect?: CandidatoWhereUniqueInput | CandidatoWhereUniqueInput[]
  }

  export type RTUpdateOneRequiredWithoutCTGsNestedInput = {
    create?: XOR<RTCreateWithoutCTGsInput, RTUncheckedCreateWithoutCTGsInput>
    connectOrCreate?: RTCreateOrConnectWithoutCTGsInput
    upsert?: RTUpsertWithoutCTGsInput
    connect?: RTWhereUniqueInput
    update?: XOR<XOR<RTUpdateToOneWithWhereWithoutCTGsInput, RTUpdateWithoutCTGsInput>, RTUncheckedUpdateWithoutCTGsInput>
  }

  export type UsuarioUpdateManyWithoutCTGNestedInput = {
    create?: XOR<UsuarioCreateWithoutCTGInput, UsuarioUncheckedCreateWithoutCTGInput> | UsuarioCreateWithoutCTGInput[] | UsuarioUncheckedCreateWithoutCTGInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutCTGInput | UsuarioCreateOrConnectWithoutCTGInput[]
    upsert?: UsuarioUpsertWithWhereUniqueWithoutCTGInput | UsuarioUpsertWithWhereUniqueWithoutCTGInput[]
    createMany?: UsuarioCreateManyCTGInputEnvelope
    set?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    disconnect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    delete?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    update?: UsuarioUpdateWithWhereUniqueWithoutCTGInput | UsuarioUpdateWithWhereUniqueWithoutCTGInput[]
    updateMany?: UsuarioUpdateManyWithWhereWithoutCTGInput | UsuarioUpdateManyWithWhereWithoutCTGInput[]
    deleteMany?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
  }

  export type CandidatoUpdateManyWithoutCTGNestedInput = {
    create?: XOR<CandidatoCreateWithoutCTGInput, CandidatoUncheckedCreateWithoutCTGInput> | CandidatoCreateWithoutCTGInput[] | CandidatoUncheckedCreateWithoutCTGInput[]
    connectOrCreate?: CandidatoCreateOrConnectWithoutCTGInput | CandidatoCreateOrConnectWithoutCTGInput[]
    upsert?: CandidatoUpsertWithWhereUniqueWithoutCTGInput | CandidatoUpsertWithWhereUniqueWithoutCTGInput[]
    createMany?: CandidatoCreateManyCTGInputEnvelope
    set?: CandidatoWhereUniqueInput | CandidatoWhereUniqueInput[]
    disconnect?: CandidatoWhereUniqueInput | CandidatoWhereUniqueInput[]
    delete?: CandidatoWhereUniqueInput | CandidatoWhereUniqueInput[]
    connect?: CandidatoWhereUniqueInput | CandidatoWhereUniqueInput[]
    update?: CandidatoUpdateWithWhereUniqueWithoutCTGInput | CandidatoUpdateWithWhereUniqueWithoutCTGInput[]
    updateMany?: CandidatoUpdateManyWithWhereWithoutCTGInput | CandidatoUpdateManyWithWhereWithoutCTGInput[]
    deleteMany?: CandidatoScalarWhereInput | CandidatoScalarWhereInput[]
  }

  export type UsuarioUncheckedUpdateManyWithoutCTGNestedInput = {
    create?: XOR<UsuarioCreateWithoutCTGInput, UsuarioUncheckedCreateWithoutCTGInput> | UsuarioCreateWithoutCTGInput[] | UsuarioUncheckedCreateWithoutCTGInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutCTGInput | UsuarioCreateOrConnectWithoutCTGInput[]
    upsert?: UsuarioUpsertWithWhereUniqueWithoutCTGInput | UsuarioUpsertWithWhereUniqueWithoutCTGInput[]
    createMany?: UsuarioCreateManyCTGInputEnvelope
    set?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    disconnect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    delete?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    update?: UsuarioUpdateWithWhereUniqueWithoutCTGInput | UsuarioUpdateWithWhereUniqueWithoutCTGInput[]
    updateMany?: UsuarioUpdateManyWithWhereWithoutCTGInput | UsuarioUpdateManyWithWhereWithoutCTGInput[]
    deleteMany?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
  }

  export type CandidatoUncheckedUpdateManyWithoutCTGNestedInput = {
    create?: XOR<CandidatoCreateWithoutCTGInput, CandidatoUncheckedCreateWithoutCTGInput> | CandidatoCreateWithoutCTGInput[] | CandidatoUncheckedCreateWithoutCTGInput[]
    connectOrCreate?: CandidatoCreateOrConnectWithoutCTGInput | CandidatoCreateOrConnectWithoutCTGInput[]
    upsert?: CandidatoUpsertWithWhereUniqueWithoutCTGInput | CandidatoUpsertWithWhereUniqueWithoutCTGInput[]
    createMany?: CandidatoCreateManyCTGInputEnvelope
    set?: CandidatoWhereUniqueInput | CandidatoWhereUniqueInput[]
    disconnect?: CandidatoWhereUniqueInput | CandidatoWhereUniqueInput[]
    delete?: CandidatoWhereUniqueInput | CandidatoWhereUniqueInput[]
    connect?: CandidatoWhereUniqueInput | CandidatoWhereUniqueInput[]
    update?: CandidatoUpdateWithWhereUniqueWithoutCTGInput | CandidatoUpdateWithWhereUniqueWithoutCTGInput[]
    updateMany?: CandidatoUpdateManyWithWhereWithoutCTGInput | CandidatoUpdateManyWithWhereWithoutCTGInput[]
    deleteMany?: CandidatoScalarWhereInput | CandidatoScalarWhereInput[]
  }

  export type CTGCreateNestedManyWithoutRTInput = {
    create?: XOR<CTGCreateWithoutRTInput, CTGUncheckedCreateWithoutRTInput> | CTGCreateWithoutRTInput[] | CTGUncheckedCreateWithoutRTInput[]
    connectOrCreate?: CTGCreateOrConnectWithoutRTInput | CTGCreateOrConnectWithoutRTInput[]
    createMany?: CTGCreateManyRTInputEnvelope
    connect?: CTGWhereUniqueInput | CTGWhereUniqueInput[]
  }

  export type CTGUncheckedCreateNestedManyWithoutRTInput = {
    create?: XOR<CTGCreateWithoutRTInput, CTGUncheckedCreateWithoutRTInput> | CTGCreateWithoutRTInput[] | CTGUncheckedCreateWithoutRTInput[]
    connectOrCreate?: CTGCreateOrConnectWithoutRTInput | CTGCreateOrConnectWithoutRTInput[]
    createMany?: CTGCreateManyRTInputEnvelope
    connect?: CTGWhereUniqueInput | CTGWhereUniqueInput[]
  }

  export type CTGUpdateManyWithoutRTNestedInput = {
    create?: XOR<CTGCreateWithoutRTInput, CTGUncheckedCreateWithoutRTInput> | CTGCreateWithoutRTInput[] | CTGUncheckedCreateWithoutRTInput[]
    connectOrCreate?: CTGCreateOrConnectWithoutRTInput | CTGCreateOrConnectWithoutRTInput[]
    upsert?: CTGUpsertWithWhereUniqueWithoutRTInput | CTGUpsertWithWhereUniqueWithoutRTInput[]
    createMany?: CTGCreateManyRTInputEnvelope
    set?: CTGWhereUniqueInput | CTGWhereUniqueInput[]
    disconnect?: CTGWhereUniqueInput | CTGWhereUniqueInput[]
    delete?: CTGWhereUniqueInput | CTGWhereUniqueInput[]
    connect?: CTGWhereUniqueInput | CTGWhereUniqueInput[]
    update?: CTGUpdateWithWhereUniqueWithoutRTInput | CTGUpdateWithWhereUniqueWithoutRTInput[]
    updateMany?: CTGUpdateManyWithWhereWithoutRTInput | CTGUpdateManyWithWhereWithoutRTInput[]
    deleteMany?: CTGScalarWhereInput | CTGScalarWhereInput[]
  }

  export type CTGUncheckedUpdateManyWithoutRTNestedInput = {
    create?: XOR<CTGCreateWithoutRTInput, CTGUncheckedCreateWithoutRTInput> | CTGCreateWithoutRTInput[] | CTGUncheckedCreateWithoutRTInput[]
    connectOrCreate?: CTGCreateOrConnectWithoutRTInput | CTGCreateOrConnectWithoutRTInput[]
    upsert?: CTGUpsertWithWhereUniqueWithoutRTInput | CTGUpsertWithWhereUniqueWithoutRTInput[]
    createMany?: CTGCreateManyRTInputEnvelope
    set?: CTGWhereUniqueInput | CTGWhereUniqueInput[]
    disconnect?: CTGWhereUniqueInput | CTGWhereUniqueInput[]
    delete?: CTGWhereUniqueInput | CTGWhereUniqueInput[]
    connect?: CTGWhereUniqueInput | CTGWhereUniqueInput[]
    update?: CTGUpdateWithWhereUniqueWithoutRTInput | CTGUpdateWithWhereUniqueWithoutRTInput[]
    updateMany?: CTGUpdateManyWithWhereWithoutRTInput | CTGUpdateManyWithWhereWithoutRTInput[]
    deleteMany?: CTGScalarWhereInput | CTGScalarWhereInput[]
  }

  export type CandidatoCreateNestedOneWithoutPreferenciaSorteioDancaInput = {
    create?: XOR<CandidatoCreateWithoutPreferenciaSorteioDancaInput, CandidatoUncheckedCreateWithoutPreferenciaSorteioDancaInput>
    connectOrCreate?: CandidatoCreateOrConnectWithoutPreferenciaSorteioDancaInput
    connect?: CandidatoWhereUniqueInput
  }

  export type SorteioDancaCreateNestedOneWithoutPreferenciaSorteioDancaIdsInput = {
    create?: XOR<SorteioDancaCreateWithoutPreferenciaSorteioDancaIdsInput, SorteioDancaUncheckedCreateWithoutPreferenciaSorteioDancaIdsInput>
    connectOrCreate?: SorteioDancaCreateOrConnectWithoutPreferenciaSorteioDancaIdsInput
    connect?: SorteioDancaWhereUniqueInput
  }

  export type QuesitosCreateNestedManyWithoutPreferenciaSorteioDancaInput = {
    create?: XOR<QuesitosCreateWithoutPreferenciaSorteioDancaInput, QuesitosUncheckedCreateWithoutPreferenciaSorteioDancaInput> | QuesitosCreateWithoutPreferenciaSorteioDancaInput[] | QuesitosUncheckedCreateWithoutPreferenciaSorteioDancaInput[]
    connectOrCreate?: QuesitosCreateOrConnectWithoutPreferenciaSorteioDancaInput | QuesitosCreateOrConnectWithoutPreferenciaSorteioDancaInput[]
    createMany?: QuesitosCreateManyPreferenciaSorteioDancaInputEnvelope
    connect?: QuesitosWhereUniqueInput | QuesitosWhereUniqueInput[]
  }

  export type QuesitosUncheckedCreateNestedManyWithoutPreferenciaSorteioDancaInput = {
    create?: XOR<QuesitosCreateWithoutPreferenciaSorteioDancaInput, QuesitosUncheckedCreateWithoutPreferenciaSorteioDancaInput> | QuesitosCreateWithoutPreferenciaSorteioDancaInput[] | QuesitosUncheckedCreateWithoutPreferenciaSorteioDancaInput[]
    connectOrCreate?: QuesitosCreateOrConnectWithoutPreferenciaSorteioDancaInput | QuesitosCreateOrConnectWithoutPreferenciaSorteioDancaInput[]
    createMany?: QuesitosCreateManyPreferenciaSorteioDancaInputEnvelope
    connect?: QuesitosWhereUniqueInput | QuesitosWhereUniqueInput[]
  }

  export type EnumDancaSalaoTradicionalFieldUpdateOperationsInput = {
    set?: $Enums.DancaSalaoTradicional
  }

  export type CandidatoUpdateOneRequiredWithoutPreferenciaSorteioDancaNestedInput = {
    create?: XOR<CandidatoCreateWithoutPreferenciaSorteioDancaInput, CandidatoUncheckedCreateWithoutPreferenciaSorteioDancaInput>
    connectOrCreate?: CandidatoCreateOrConnectWithoutPreferenciaSorteioDancaInput
    upsert?: CandidatoUpsertWithoutPreferenciaSorteioDancaInput
    connect?: CandidatoWhereUniqueInput
    update?: XOR<XOR<CandidatoUpdateToOneWithWhereWithoutPreferenciaSorteioDancaInput, CandidatoUpdateWithoutPreferenciaSorteioDancaInput>, CandidatoUncheckedUpdateWithoutPreferenciaSorteioDancaInput>
  }

  export type SorteioDancaUpdateOneWithoutPreferenciaSorteioDancaIdsNestedInput = {
    create?: XOR<SorteioDancaCreateWithoutPreferenciaSorteioDancaIdsInput, SorteioDancaUncheckedCreateWithoutPreferenciaSorteioDancaIdsInput>
    connectOrCreate?: SorteioDancaCreateOrConnectWithoutPreferenciaSorteioDancaIdsInput
    upsert?: SorteioDancaUpsertWithoutPreferenciaSorteioDancaIdsInput
    disconnect?: SorteioDancaWhereInput | boolean
    delete?: SorteioDancaWhereInput | boolean
    connect?: SorteioDancaWhereUniqueInput
    update?: XOR<XOR<SorteioDancaUpdateToOneWithWhereWithoutPreferenciaSorteioDancaIdsInput, SorteioDancaUpdateWithoutPreferenciaSorteioDancaIdsInput>, SorteioDancaUncheckedUpdateWithoutPreferenciaSorteioDancaIdsInput>
  }

  export type QuesitosUpdateManyWithoutPreferenciaSorteioDancaNestedInput = {
    create?: XOR<QuesitosCreateWithoutPreferenciaSorteioDancaInput, QuesitosUncheckedCreateWithoutPreferenciaSorteioDancaInput> | QuesitosCreateWithoutPreferenciaSorteioDancaInput[] | QuesitosUncheckedCreateWithoutPreferenciaSorteioDancaInput[]
    connectOrCreate?: QuesitosCreateOrConnectWithoutPreferenciaSorteioDancaInput | QuesitosCreateOrConnectWithoutPreferenciaSorteioDancaInput[]
    upsert?: QuesitosUpsertWithWhereUniqueWithoutPreferenciaSorteioDancaInput | QuesitosUpsertWithWhereUniqueWithoutPreferenciaSorteioDancaInput[]
    createMany?: QuesitosCreateManyPreferenciaSorteioDancaInputEnvelope
    set?: QuesitosWhereUniqueInput | QuesitosWhereUniqueInput[]
    disconnect?: QuesitosWhereUniqueInput | QuesitosWhereUniqueInput[]
    delete?: QuesitosWhereUniqueInput | QuesitosWhereUniqueInput[]
    connect?: QuesitosWhereUniqueInput | QuesitosWhereUniqueInput[]
    update?: QuesitosUpdateWithWhereUniqueWithoutPreferenciaSorteioDancaInput | QuesitosUpdateWithWhereUniqueWithoutPreferenciaSorteioDancaInput[]
    updateMany?: QuesitosUpdateManyWithWhereWithoutPreferenciaSorteioDancaInput | QuesitosUpdateManyWithWhereWithoutPreferenciaSorteioDancaInput[]
    deleteMany?: QuesitosScalarWhereInput | QuesitosScalarWhereInput[]
  }

  export type QuesitosUncheckedUpdateManyWithoutPreferenciaSorteioDancaNestedInput = {
    create?: XOR<QuesitosCreateWithoutPreferenciaSorteioDancaInput, QuesitosUncheckedCreateWithoutPreferenciaSorteioDancaInput> | QuesitosCreateWithoutPreferenciaSorteioDancaInput[] | QuesitosUncheckedCreateWithoutPreferenciaSorteioDancaInput[]
    connectOrCreate?: QuesitosCreateOrConnectWithoutPreferenciaSorteioDancaInput | QuesitosCreateOrConnectWithoutPreferenciaSorteioDancaInput[]
    upsert?: QuesitosUpsertWithWhereUniqueWithoutPreferenciaSorteioDancaInput | QuesitosUpsertWithWhereUniqueWithoutPreferenciaSorteioDancaInput[]
    createMany?: QuesitosCreateManyPreferenciaSorteioDancaInputEnvelope
    set?: QuesitosWhereUniqueInput | QuesitosWhereUniqueInput[]
    disconnect?: QuesitosWhereUniqueInput | QuesitosWhereUniqueInput[]
    delete?: QuesitosWhereUniqueInput | QuesitosWhereUniqueInput[]
    connect?: QuesitosWhereUniqueInput | QuesitosWhereUniqueInput[]
    update?: QuesitosUpdateWithWhereUniqueWithoutPreferenciaSorteioDancaInput | QuesitosUpdateWithWhereUniqueWithoutPreferenciaSorteioDancaInput[]
    updateMany?: QuesitosUpdateManyWithWhereWithoutPreferenciaSorteioDancaInput | QuesitosUpdateManyWithWhereWithoutPreferenciaSorteioDancaInput[]
    deleteMany?: QuesitosScalarWhereInput | QuesitosScalarWhereInput[]
  }

  export type CandidatoCreateNestedManyWithoutConcursoInput = {
    create?: XOR<CandidatoCreateWithoutConcursoInput, CandidatoUncheckedCreateWithoutConcursoInput> | CandidatoCreateWithoutConcursoInput[] | CandidatoUncheckedCreateWithoutConcursoInput[]
    connectOrCreate?: CandidatoCreateOrConnectWithoutConcursoInput | CandidatoCreateOrConnectWithoutConcursoInput[]
    createMany?: CandidatoCreateManyConcursoInputEnvelope
    connect?: CandidatoWhereUniqueInput | CandidatoWhereUniqueInput[]
  }

  export type ComissaoCreateNestedManyWithoutConcursoInput = {
    create?: XOR<ComissaoCreateWithoutConcursoInput, ComissaoUncheckedCreateWithoutConcursoInput> | ComissaoCreateWithoutConcursoInput[] | ComissaoUncheckedCreateWithoutConcursoInput[]
    connectOrCreate?: ComissaoCreateOrConnectWithoutConcursoInput | ComissaoCreateOrConnectWithoutConcursoInput[]
    createMany?: ComissaoCreateManyConcursoInputEnvelope
    connect?: ComissaoWhereUniqueInput | ComissaoWhereUniqueInput[]
  }

  export type CandidatoUncheckedCreateNestedManyWithoutConcursoInput = {
    create?: XOR<CandidatoCreateWithoutConcursoInput, CandidatoUncheckedCreateWithoutConcursoInput> | CandidatoCreateWithoutConcursoInput[] | CandidatoUncheckedCreateWithoutConcursoInput[]
    connectOrCreate?: CandidatoCreateOrConnectWithoutConcursoInput | CandidatoCreateOrConnectWithoutConcursoInput[]
    createMany?: CandidatoCreateManyConcursoInputEnvelope
    connect?: CandidatoWhereUniqueInput | CandidatoWhereUniqueInput[]
  }

  export type ComissaoUncheckedCreateNestedManyWithoutConcursoInput = {
    create?: XOR<ComissaoCreateWithoutConcursoInput, ComissaoUncheckedCreateWithoutConcursoInput> | ComissaoCreateWithoutConcursoInput[] | ComissaoUncheckedCreateWithoutConcursoInput[]
    connectOrCreate?: ComissaoCreateOrConnectWithoutConcursoInput | ComissaoCreateOrConnectWithoutConcursoInput[]
    createMany?: ComissaoCreateManyConcursoInputEnvelope
    connect?: ComissaoWhereUniqueInput | ComissaoWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CandidatoUpdateManyWithoutConcursoNestedInput = {
    create?: XOR<CandidatoCreateWithoutConcursoInput, CandidatoUncheckedCreateWithoutConcursoInput> | CandidatoCreateWithoutConcursoInput[] | CandidatoUncheckedCreateWithoutConcursoInput[]
    connectOrCreate?: CandidatoCreateOrConnectWithoutConcursoInput | CandidatoCreateOrConnectWithoutConcursoInput[]
    upsert?: CandidatoUpsertWithWhereUniqueWithoutConcursoInput | CandidatoUpsertWithWhereUniqueWithoutConcursoInput[]
    createMany?: CandidatoCreateManyConcursoInputEnvelope
    set?: CandidatoWhereUniqueInput | CandidatoWhereUniqueInput[]
    disconnect?: CandidatoWhereUniqueInput | CandidatoWhereUniqueInput[]
    delete?: CandidatoWhereUniqueInput | CandidatoWhereUniqueInput[]
    connect?: CandidatoWhereUniqueInput | CandidatoWhereUniqueInput[]
    update?: CandidatoUpdateWithWhereUniqueWithoutConcursoInput | CandidatoUpdateWithWhereUniqueWithoutConcursoInput[]
    updateMany?: CandidatoUpdateManyWithWhereWithoutConcursoInput | CandidatoUpdateManyWithWhereWithoutConcursoInput[]
    deleteMany?: CandidatoScalarWhereInput | CandidatoScalarWhereInput[]
  }

  export type ComissaoUpdateManyWithoutConcursoNestedInput = {
    create?: XOR<ComissaoCreateWithoutConcursoInput, ComissaoUncheckedCreateWithoutConcursoInput> | ComissaoCreateWithoutConcursoInput[] | ComissaoUncheckedCreateWithoutConcursoInput[]
    connectOrCreate?: ComissaoCreateOrConnectWithoutConcursoInput | ComissaoCreateOrConnectWithoutConcursoInput[]
    upsert?: ComissaoUpsertWithWhereUniqueWithoutConcursoInput | ComissaoUpsertWithWhereUniqueWithoutConcursoInput[]
    createMany?: ComissaoCreateManyConcursoInputEnvelope
    set?: ComissaoWhereUniqueInput | ComissaoWhereUniqueInput[]
    disconnect?: ComissaoWhereUniqueInput | ComissaoWhereUniqueInput[]
    delete?: ComissaoWhereUniqueInput | ComissaoWhereUniqueInput[]
    connect?: ComissaoWhereUniqueInput | ComissaoWhereUniqueInput[]
    update?: ComissaoUpdateWithWhereUniqueWithoutConcursoInput | ComissaoUpdateWithWhereUniqueWithoutConcursoInput[]
    updateMany?: ComissaoUpdateManyWithWhereWithoutConcursoInput | ComissaoUpdateManyWithWhereWithoutConcursoInput[]
    deleteMany?: ComissaoScalarWhereInput | ComissaoScalarWhereInput[]
  }

  export type CandidatoUncheckedUpdateManyWithoutConcursoNestedInput = {
    create?: XOR<CandidatoCreateWithoutConcursoInput, CandidatoUncheckedCreateWithoutConcursoInput> | CandidatoCreateWithoutConcursoInput[] | CandidatoUncheckedCreateWithoutConcursoInput[]
    connectOrCreate?: CandidatoCreateOrConnectWithoutConcursoInput | CandidatoCreateOrConnectWithoutConcursoInput[]
    upsert?: CandidatoUpsertWithWhereUniqueWithoutConcursoInput | CandidatoUpsertWithWhereUniqueWithoutConcursoInput[]
    createMany?: CandidatoCreateManyConcursoInputEnvelope
    set?: CandidatoWhereUniqueInput | CandidatoWhereUniqueInput[]
    disconnect?: CandidatoWhereUniqueInput | CandidatoWhereUniqueInput[]
    delete?: CandidatoWhereUniqueInput | CandidatoWhereUniqueInput[]
    connect?: CandidatoWhereUniqueInput | CandidatoWhereUniqueInput[]
    update?: CandidatoUpdateWithWhereUniqueWithoutConcursoInput | CandidatoUpdateWithWhereUniqueWithoutConcursoInput[]
    updateMany?: CandidatoUpdateManyWithWhereWithoutConcursoInput | CandidatoUpdateManyWithWhereWithoutConcursoInput[]
    deleteMany?: CandidatoScalarWhereInput | CandidatoScalarWhereInput[]
  }

  export type ComissaoUncheckedUpdateManyWithoutConcursoNestedInput = {
    create?: XOR<ComissaoCreateWithoutConcursoInput, ComissaoUncheckedCreateWithoutConcursoInput> | ComissaoCreateWithoutConcursoInput[] | ComissaoUncheckedCreateWithoutConcursoInput[]
    connectOrCreate?: ComissaoCreateOrConnectWithoutConcursoInput | ComissaoCreateOrConnectWithoutConcursoInput[]
    upsert?: ComissaoUpsertWithWhereUniqueWithoutConcursoInput | ComissaoUpsertWithWhereUniqueWithoutConcursoInput[]
    createMany?: ComissaoCreateManyConcursoInputEnvelope
    set?: ComissaoWhereUniqueInput | ComissaoWhereUniqueInput[]
    disconnect?: ComissaoWhereUniqueInput | ComissaoWhereUniqueInput[]
    delete?: ComissaoWhereUniqueInput | ComissaoWhereUniqueInput[]
    connect?: ComissaoWhereUniqueInput | ComissaoWhereUniqueInput[]
    update?: ComissaoUpdateWithWhereUniqueWithoutConcursoInput | ComissaoUpdateWithWhereUniqueWithoutConcursoInput[]
    updateMany?: ComissaoUpdateManyWithWhereWithoutConcursoInput | ComissaoUpdateManyWithWhereWithoutConcursoInput[]
    deleteMany?: ComissaoScalarWhereInput | ComissaoScalarWhereInput[]
  }

  export type ConcursoCreateNestedOneWithoutComissoesInput = {
    create?: XOR<ConcursoCreateWithoutComissoesInput, ConcursoUncheckedCreateWithoutComissoesInput>
    connectOrCreate?: ConcursoCreateOrConnectWithoutComissoesInput
    connect?: ConcursoWhereUniqueInput
  }

  export type AvaliacaoCreateNestedManyWithoutComissaoInput = {
    create?: XOR<AvaliacaoCreateWithoutComissaoInput, AvaliacaoUncheckedCreateWithoutComissaoInput> | AvaliacaoCreateWithoutComissaoInput[] | AvaliacaoUncheckedCreateWithoutComissaoInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutComissaoInput | AvaliacaoCreateOrConnectWithoutComissaoInput[]
    createMany?: AvaliacaoCreateManyComissaoInputEnvelope
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
  }

  export type ComissaoUsuarioCreateNestedManyWithoutComissaoInput = {
    create?: XOR<ComissaoUsuarioCreateWithoutComissaoInput, ComissaoUsuarioUncheckedCreateWithoutComissaoInput> | ComissaoUsuarioCreateWithoutComissaoInput[] | ComissaoUsuarioUncheckedCreateWithoutComissaoInput[]
    connectOrCreate?: ComissaoUsuarioCreateOrConnectWithoutComissaoInput | ComissaoUsuarioCreateOrConnectWithoutComissaoInput[]
    createMany?: ComissaoUsuarioCreateManyComissaoInputEnvelope
    connect?: ComissaoUsuarioWhereUniqueInput | ComissaoUsuarioWhereUniqueInput[]
  }

  export type AvaliacaoUncheckedCreateNestedManyWithoutComissaoInput = {
    create?: XOR<AvaliacaoCreateWithoutComissaoInput, AvaliacaoUncheckedCreateWithoutComissaoInput> | AvaliacaoCreateWithoutComissaoInput[] | AvaliacaoUncheckedCreateWithoutComissaoInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutComissaoInput | AvaliacaoCreateOrConnectWithoutComissaoInput[]
    createMany?: AvaliacaoCreateManyComissaoInputEnvelope
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
  }

  export type ComissaoUsuarioUncheckedCreateNestedManyWithoutComissaoInput = {
    create?: XOR<ComissaoUsuarioCreateWithoutComissaoInput, ComissaoUsuarioUncheckedCreateWithoutComissaoInput> | ComissaoUsuarioCreateWithoutComissaoInput[] | ComissaoUsuarioUncheckedCreateWithoutComissaoInput[]
    connectOrCreate?: ComissaoUsuarioCreateOrConnectWithoutComissaoInput | ComissaoUsuarioCreateOrConnectWithoutComissaoInput[]
    createMany?: ComissaoUsuarioCreateManyComissaoInputEnvelope
    connect?: ComissaoUsuarioWhereUniqueInput | ComissaoUsuarioWhereUniqueInput[]
  }

  export type ConcursoUpdateOneRequiredWithoutComissoesNestedInput = {
    create?: XOR<ConcursoCreateWithoutComissoesInput, ConcursoUncheckedCreateWithoutComissoesInput>
    connectOrCreate?: ConcursoCreateOrConnectWithoutComissoesInput
    upsert?: ConcursoUpsertWithoutComissoesInput
    connect?: ConcursoWhereUniqueInput
    update?: XOR<XOR<ConcursoUpdateToOneWithWhereWithoutComissoesInput, ConcursoUpdateWithoutComissoesInput>, ConcursoUncheckedUpdateWithoutComissoesInput>
  }

  export type AvaliacaoUpdateManyWithoutComissaoNestedInput = {
    create?: XOR<AvaliacaoCreateWithoutComissaoInput, AvaliacaoUncheckedCreateWithoutComissaoInput> | AvaliacaoCreateWithoutComissaoInput[] | AvaliacaoUncheckedCreateWithoutComissaoInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutComissaoInput | AvaliacaoCreateOrConnectWithoutComissaoInput[]
    upsert?: AvaliacaoUpsertWithWhereUniqueWithoutComissaoInput | AvaliacaoUpsertWithWhereUniqueWithoutComissaoInput[]
    createMany?: AvaliacaoCreateManyComissaoInputEnvelope
    set?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    disconnect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    delete?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    update?: AvaliacaoUpdateWithWhereUniqueWithoutComissaoInput | AvaliacaoUpdateWithWhereUniqueWithoutComissaoInput[]
    updateMany?: AvaliacaoUpdateManyWithWhereWithoutComissaoInput | AvaliacaoUpdateManyWithWhereWithoutComissaoInput[]
    deleteMany?: AvaliacaoScalarWhereInput | AvaliacaoScalarWhereInput[]
  }

  export type ComissaoUsuarioUpdateManyWithoutComissaoNestedInput = {
    create?: XOR<ComissaoUsuarioCreateWithoutComissaoInput, ComissaoUsuarioUncheckedCreateWithoutComissaoInput> | ComissaoUsuarioCreateWithoutComissaoInput[] | ComissaoUsuarioUncheckedCreateWithoutComissaoInput[]
    connectOrCreate?: ComissaoUsuarioCreateOrConnectWithoutComissaoInput | ComissaoUsuarioCreateOrConnectWithoutComissaoInput[]
    upsert?: ComissaoUsuarioUpsertWithWhereUniqueWithoutComissaoInput | ComissaoUsuarioUpsertWithWhereUniqueWithoutComissaoInput[]
    createMany?: ComissaoUsuarioCreateManyComissaoInputEnvelope
    set?: ComissaoUsuarioWhereUniqueInput | ComissaoUsuarioWhereUniqueInput[]
    disconnect?: ComissaoUsuarioWhereUniqueInput | ComissaoUsuarioWhereUniqueInput[]
    delete?: ComissaoUsuarioWhereUniqueInput | ComissaoUsuarioWhereUniqueInput[]
    connect?: ComissaoUsuarioWhereUniqueInput | ComissaoUsuarioWhereUniqueInput[]
    update?: ComissaoUsuarioUpdateWithWhereUniqueWithoutComissaoInput | ComissaoUsuarioUpdateWithWhereUniqueWithoutComissaoInput[]
    updateMany?: ComissaoUsuarioUpdateManyWithWhereWithoutComissaoInput | ComissaoUsuarioUpdateManyWithWhereWithoutComissaoInput[]
    deleteMany?: ComissaoUsuarioScalarWhereInput | ComissaoUsuarioScalarWhereInput[]
  }

  export type AvaliacaoUncheckedUpdateManyWithoutComissaoNestedInput = {
    create?: XOR<AvaliacaoCreateWithoutComissaoInput, AvaliacaoUncheckedCreateWithoutComissaoInput> | AvaliacaoCreateWithoutComissaoInput[] | AvaliacaoUncheckedCreateWithoutComissaoInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutComissaoInput | AvaliacaoCreateOrConnectWithoutComissaoInput[]
    upsert?: AvaliacaoUpsertWithWhereUniqueWithoutComissaoInput | AvaliacaoUpsertWithWhereUniqueWithoutComissaoInput[]
    createMany?: AvaliacaoCreateManyComissaoInputEnvelope
    set?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    disconnect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    delete?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    update?: AvaliacaoUpdateWithWhereUniqueWithoutComissaoInput | AvaliacaoUpdateWithWhereUniqueWithoutComissaoInput[]
    updateMany?: AvaliacaoUpdateManyWithWhereWithoutComissaoInput | AvaliacaoUpdateManyWithWhereWithoutComissaoInput[]
    deleteMany?: AvaliacaoScalarWhereInput | AvaliacaoScalarWhereInput[]
  }

  export type ComissaoUsuarioUncheckedUpdateManyWithoutComissaoNestedInput = {
    create?: XOR<ComissaoUsuarioCreateWithoutComissaoInput, ComissaoUsuarioUncheckedCreateWithoutComissaoInput> | ComissaoUsuarioCreateWithoutComissaoInput[] | ComissaoUsuarioUncheckedCreateWithoutComissaoInput[]
    connectOrCreate?: ComissaoUsuarioCreateOrConnectWithoutComissaoInput | ComissaoUsuarioCreateOrConnectWithoutComissaoInput[]
    upsert?: ComissaoUsuarioUpsertWithWhereUniqueWithoutComissaoInput | ComissaoUsuarioUpsertWithWhereUniqueWithoutComissaoInput[]
    createMany?: ComissaoUsuarioCreateManyComissaoInputEnvelope
    set?: ComissaoUsuarioWhereUniqueInput | ComissaoUsuarioWhereUniqueInput[]
    disconnect?: ComissaoUsuarioWhereUniqueInput | ComissaoUsuarioWhereUniqueInput[]
    delete?: ComissaoUsuarioWhereUniqueInput | ComissaoUsuarioWhereUniqueInput[]
    connect?: ComissaoUsuarioWhereUniqueInput | ComissaoUsuarioWhereUniqueInput[]
    update?: ComissaoUsuarioUpdateWithWhereUniqueWithoutComissaoInput | ComissaoUsuarioUpdateWithWhereUniqueWithoutComissaoInput[]
    updateMany?: ComissaoUsuarioUpdateManyWithWhereWithoutComissaoInput | ComissaoUsuarioUpdateManyWithWhereWithoutComissaoInput[]
    deleteMany?: ComissaoUsuarioScalarWhereInput | ComissaoUsuarioScalarWhereInput[]
  }

  export type ComissaoCreateNestedOneWithoutUsuariosInput = {
    create?: XOR<ComissaoCreateWithoutUsuariosInput, ComissaoUncheckedCreateWithoutUsuariosInput>
    connectOrCreate?: ComissaoCreateOrConnectWithoutUsuariosInput
    connect?: ComissaoWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutComissaoUsuarioInput = {
    create?: XOR<UsuarioCreateWithoutComissaoUsuarioInput, UsuarioUncheckedCreateWithoutComissaoUsuarioInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutComissaoUsuarioInput
    connect?: UsuarioWhereUniqueInput
  }

  export type ComissaoUpdateOneRequiredWithoutUsuariosNestedInput = {
    create?: XOR<ComissaoCreateWithoutUsuariosInput, ComissaoUncheckedCreateWithoutUsuariosInput>
    connectOrCreate?: ComissaoCreateOrConnectWithoutUsuariosInput
    upsert?: ComissaoUpsertWithoutUsuariosInput
    connect?: ComissaoWhereUniqueInput
    update?: XOR<XOR<ComissaoUpdateToOneWithWhereWithoutUsuariosInput, ComissaoUpdateWithoutUsuariosInput>, ComissaoUncheckedUpdateWithoutUsuariosInput>
  }

  export type UsuarioUpdateOneRequiredWithoutComissaoUsuarioNestedInput = {
    create?: XOR<UsuarioCreateWithoutComissaoUsuarioInput, UsuarioUncheckedCreateWithoutComissaoUsuarioInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutComissaoUsuarioInput
    upsert?: UsuarioUpsertWithoutComissaoUsuarioInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutComissaoUsuarioInput, UsuarioUpdateWithoutComissaoUsuarioInput>, UsuarioUncheckedUpdateWithoutComissaoUsuarioInput>
  }

  export type CandidatoCreateNestedManyWithoutCategoriaInput = {
    create?: XOR<CandidatoCreateWithoutCategoriaInput, CandidatoUncheckedCreateWithoutCategoriaInput> | CandidatoCreateWithoutCategoriaInput[] | CandidatoUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: CandidatoCreateOrConnectWithoutCategoriaInput | CandidatoCreateOrConnectWithoutCategoriaInput[]
    createMany?: CandidatoCreateManyCategoriaInputEnvelope
    connect?: CandidatoWhereUniqueInput | CandidatoWhereUniqueInput[]
  }

  export type ProvaCreateNestedOneWithoutCategoriasInput = {
    create?: XOR<ProvaCreateWithoutCategoriasInput, ProvaUncheckedCreateWithoutCategoriasInput>
    connectOrCreate?: ProvaCreateOrConnectWithoutCategoriasInput
    connect?: ProvaWhereUniqueInput
  }

  export type ProvaTeoricaCreateNestedOneWithoutCategoriaInput = {
    create?: XOR<ProvaTeoricaCreateWithoutCategoriaInput, ProvaTeoricaUncheckedCreateWithoutCategoriaInput>
    connectOrCreate?: ProvaTeoricaCreateOrConnectWithoutCategoriaInput
    connect?: ProvaTeoricaWhereUniqueInput
  }

  export type ProvaPraticaCreateNestedOneWithoutCategoriaInput = {
    create?: XOR<ProvaPraticaCreateWithoutCategoriaInput, ProvaPraticaUncheckedCreateWithoutCategoriaInput>
    connectOrCreate?: ProvaPraticaCreateOrConnectWithoutCategoriaInput
    connect?: ProvaPraticaWhereUniqueInput
  }

  export type CandidatoUncheckedCreateNestedManyWithoutCategoriaInput = {
    create?: XOR<CandidatoCreateWithoutCategoriaInput, CandidatoUncheckedCreateWithoutCategoriaInput> | CandidatoCreateWithoutCategoriaInput[] | CandidatoUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: CandidatoCreateOrConnectWithoutCategoriaInput | CandidatoCreateOrConnectWithoutCategoriaInput[]
    createMany?: CandidatoCreateManyCategoriaInputEnvelope
    connect?: CandidatoWhereUniqueInput | CandidatoWhereUniqueInput[]
  }

  export type CandidatoUpdateManyWithoutCategoriaNestedInput = {
    create?: XOR<CandidatoCreateWithoutCategoriaInput, CandidatoUncheckedCreateWithoutCategoriaInput> | CandidatoCreateWithoutCategoriaInput[] | CandidatoUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: CandidatoCreateOrConnectWithoutCategoriaInput | CandidatoCreateOrConnectWithoutCategoriaInput[]
    upsert?: CandidatoUpsertWithWhereUniqueWithoutCategoriaInput | CandidatoUpsertWithWhereUniqueWithoutCategoriaInput[]
    createMany?: CandidatoCreateManyCategoriaInputEnvelope
    set?: CandidatoWhereUniqueInput | CandidatoWhereUniqueInput[]
    disconnect?: CandidatoWhereUniqueInput | CandidatoWhereUniqueInput[]
    delete?: CandidatoWhereUniqueInput | CandidatoWhereUniqueInput[]
    connect?: CandidatoWhereUniqueInput | CandidatoWhereUniqueInput[]
    update?: CandidatoUpdateWithWhereUniqueWithoutCategoriaInput | CandidatoUpdateWithWhereUniqueWithoutCategoriaInput[]
    updateMany?: CandidatoUpdateManyWithWhereWithoutCategoriaInput | CandidatoUpdateManyWithWhereWithoutCategoriaInput[]
    deleteMany?: CandidatoScalarWhereInput | CandidatoScalarWhereInput[]
  }

  export type ProvaUpdateOneWithoutCategoriasNestedInput = {
    create?: XOR<ProvaCreateWithoutCategoriasInput, ProvaUncheckedCreateWithoutCategoriasInput>
    connectOrCreate?: ProvaCreateOrConnectWithoutCategoriasInput
    upsert?: ProvaUpsertWithoutCategoriasInput
    disconnect?: ProvaWhereInput | boolean
    delete?: ProvaWhereInput | boolean
    connect?: ProvaWhereUniqueInput
    update?: XOR<XOR<ProvaUpdateToOneWithWhereWithoutCategoriasInput, ProvaUpdateWithoutCategoriasInput>, ProvaUncheckedUpdateWithoutCategoriasInput>
  }

  export type ProvaTeoricaUpdateOneWithoutCategoriaNestedInput = {
    create?: XOR<ProvaTeoricaCreateWithoutCategoriaInput, ProvaTeoricaUncheckedCreateWithoutCategoriaInput>
    connectOrCreate?: ProvaTeoricaCreateOrConnectWithoutCategoriaInput
    upsert?: ProvaTeoricaUpsertWithoutCategoriaInput
    disconnect?: ProvaTeoricaWhereInput | boolean
    delete?: ProvaTeoricaWhereInput | boolean
    connect?: ProvaTeoricaWhereUniqueInput
    update?: XOR<XOR<ProvaTeoricaUpdateToOneWithWhereWithoutCategoriaInput, ProvaTeoricaUpdateWithoutCategoriaInput>, ProvaTeoricaUncheckedUpdateWithoutCategoriaInput>
  }

  export type ProvaPraticaUpdateOneWithoutCategoriaNestedInput = {
    create?: XOR<ProvaPraticaCreateWithoutCategoriaInput, ProvaPraticaUncheckedCreateWithoutCategoriaInput>
    connectOrCreate?: ProvaPraticaCreateOrConnectWithoutCategoriaInput
    upsert?: ProvaPraticaUpsertWithoutCategoriaInput
    disconnect?: ProvaPraticaWhereInput | boolean
    delete?: ProvaPraticaWhereInput | boolean
    connect?: ProvaPraticaWhereUniqueInput
    update?: XOR<XOR<ProvaPraticaUpdateToOneWithWhereWithoutCategoriaInput, ProvaPraticaUpdateWithoutCategoriaInput>, ProvaPraticaUncheckedUpdateWithoutCategoriaInput>
  }

  export type CandidatoUncheckedUpdateManyWithoutCategoriaNestedInput = {
    create?: XOR<CandidatoCreateWithoutCategoriaInput, CandidatoUncheckedCreateWithoutCategoriaInput> | CandidatoCreateWithoutCategoriaInput[] | CandidatoUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: CandidatoCreateOrConnectWithoutCategoriaInput | CandidatoCreateOrConnectWithoutCategoriaInput[]
    upsert?: CandidatoUpsertWithWhereUniqueWithoutCategoriaInput | CandidatoUpsertWithWhereUniqueWithoutCategoriaInput[]
    createMany?: CandidatoCreateManyCategoriaInputEnvelope
    set?: CandidatoWhereUniqueInput | CandidatoWhereUniqueInput[]
    disconnect?: CandidatoWhereUniqueInput | CandidatoWhereUniqueInput[]
    delete?: CandidatoWhereUniqueInput | CandidatoWhereUniqueInput[]
    connect?: CandidatoWhereUniqueInput | CandidatoWhereUniqueInput[]
    update?: CandidatoUpdateWithWhereUniqueWithoutCategoriaInput | CandidatoUpdateWithWhereUniqueWithoutCategoriaInput[]
    updateMany?: CandidatoUpdateManyWithWhereWithoutCategoriaInput | CandidatoUpdateManyWithWhereWithoutCategoriaInput[]
    deleteMany?: CandidatoScalarWhereInput | CandidatoScalarWhereInput[]
  }

  export type ComissaoCreateNestedOneWithoutAvalicaoInput = {
    create?: XOR<ComissaoCreateWithoutAvalicaoInput, ComissaoUncheckedCreateWithoutAvalicaoInput>
    connectOrCreate?: ComissaoCreateOrConnectWithoutAvalicaoInput
    connect?: ComissaoWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutAvalicoesInput = {
    create?: XOR<UsuarioCreateWithoutAvalicoesInput, UsuarioUncheckedCreateWithoutAvalicoesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutAvalicoesInput
    connect?: UsuarioWhereUniqueInput
  }

  export type ProvaCreateNestedOneWithoutAvaliacaoInput = {
    create?: XOR<ProvaCreateWithoutAvaliacaoInput, ProvaUncheckedCreateWithoutAvaliacaoInput>
    connectOrCreate?: ProvaCreateOrConnectWithoutAvaliacaoInput
    connect?: ProvaWhereUniqueInput
  }

  export type BlocoProvaCreateNestedOneWithoutAvaliacaoInput = {
    create?: XOR<BlocoProvaCreateWithoutAvaliacaoInput, BlocoProvaUncheckedCreateWithoutAvaliacaoInput>
    connectOrCreate?: BlocoProvaCreateOrConnectWithoutAvaliacaoInput
    connect?: BlocoProvaWhereUniqueInput
  }

  export type QuesitosCreateNestedManyWithoutAvaliacaoInput = {
    create?: XOR<QuesitosCreateWithoutAvaliacaoInput, QuesitosUncheckedCreateWithoutAvaliacaoInput> | QuesitosCreateWithoutAvaliacaoInput[] | QuesitosUncheckedCreateWithoutAvaliacaoInput[]
    connectOrCreate?: QuesitosCreateOrConnectWithoutAvaliacaoInput | QuesitosCreateOrConnectWithoutAvaliacaoInput[]
    createMany?: QuesitosCreateManyAvaliacaoInputEnvelope
    connect?: QuesitosWhereUniqueInput | QuesitosWhereUniqueInput[]
  }

  export type CandidatoCreateNestedOneWithoutAvalicoesInput = {
    create?: XOR<CandidatoCreateWithoutAvalicoesInput, CandidatoUncheckedCreateWithoutAvalicoesInput>
    connectOrCreate?: CandidatoCreateOrConnectWithoutAvalicoesInput
    connect?: CandidatoWhereUniqueInput
  }

  export type FichaCandidatoCreateNestedOneWithoutAvaliacoesInput = {
    create?: XOR<FichaCandidatoCreateWithoutAvaliacoesInput, FichaCandidatoUncheckedCreateWithoutAvaliacoesInput>
    connectOrCreate?: FichaCandidatoCreateOrConnectWithoutAvaliacoesInput
    connect?: FichaCandidatoWhereUniqueInput
  }

  export type QuesitosUncheckedCreateNestedManyWithoutAvaliacaoInput = {
    create?: XOR<QuesitosCreateWithoutAvaliacaoInput, QuesitosUncheckedCreateWithoutAvaliacaoInput> | QuesitosCreateWithoutAvaliacaoInput[] | QuesitosUncheckedCreateWithoutAvaliacaoInput[]
    connectOrCreate?: QuesitosCreateOrConnectWithoutAvaliacaoInput | QuesitosCreateOrConnectWithoutAvaliacaoInput[]
    createMany?: QuesitosCreateManyAvaliacaoInputEnvelope
    connect?: QuesitosWhereUniqueInput | QuesitosWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ComissaoUpdateOneRequiredWithoutAvalicaoNestedInput = {
    create?: XOR<ComissaoCreateWithoutAvalicaoInput, ComissaoUncheckedCreateWithoutAvalicaoInput>
    connectOrCreate?: ComissaoCreateOrConnectWithoutAvalicaoInput
    upsert?: ComissaoUpsertWithoutAvalicaoInput
    connect?: ComissaoWhereUniqueInput
    update?: XOR<XOR<ComissaoUpdateToOneWithWhereWithoutAvalicaoInput, ComissaoUpdateWithoutAvalicaoInput>, ComissaoUncheckedUpdateWithoutAvalicaoInput>
  }

  export type UsuarioUpdateOneRequiredWithoutAvalicoesNestedInput = {
    create?: XOR<UsuarioCreateWithoutAvalicoesInput, UsuarioUncheckedCreateWithoutAvalicoesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutAvalicoesInput
    upsert?: UsuarioUpsertWithoutAvalicoesInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutAvalicoesInput, UsuarioUpdateWithoutAvalicoesInput>, UsuarioUncheckedUpdateWithoutAvalicoesInput>
  }

  export type ProvaUpdateOneWithoutAvaliacaoNestedInput = {
    create?: XOR<ProvaCreateWithoutAvaliacaoInput, ProvaUncheckedCreateWithoutAvaliacaoInput>
    connectOrCreate?: ProvaCreateOrConnectWithoutAvaliacaoInput
    upsert?: ProvaUpsertWithoutAvaliacaoInput
    disconnect?: ProvaWhereInput | boolean
    delete?: ProvaWhereInput | boolean
    connect?: ProvaWhereUniqueInput
    update?: XOR<XOR<ProvaUpdateToOneWithWhereWithoutAvaliacaoInput, ProvaUpdateWithoutAvaliacaoInput>, ProvaUncheckedUpdateWithoutAvaliacaoInput>
  }

  export type BlocoProvaUpdateOneWithoutAvaliacaoNestedInput = {
    create?: XOR<BlocoProvaCreateWithoutAvaliacaoInput, BlocoProvaUncheckedCreateWithoutAvaliacaoInput>
    connectOrCreate?: BlocoProvaCreateOrConnectWithoutAvaliacaoInput
    upsert?: BlocoProvaUpsertWithoutAvaliacaoInput
    disconnect?: BlocoProvaWhereInput | boolean
    delete?: BlocoProvaWhereInput | boolean
    connect?: BlocoProvaWhereUniqueInput
    update?: XOR<XOR<BlocoProvaUpdateToOneWithWhereWithoutAvaliacaoInput, BlocoProvaUpdateWithoutAvaliacaoInput>, BlocoProvaUncheckedUpdateWithoutAvaliacaoInput>
  }

  export type QuesitosUpdateManyWithoutAvaliacaoNestedInput = {
    create?: XOR<QuesitosCreateWithoutAvaliacaoInput, QuesitosUncheckedCreateWithoutAvaliacaoInput> | QuesitosCreateWithoutAvaliacaoInput[] | QuesitosUncheckedCreateWithoutAvaliacaoInput[]
    connectOrCreate?: QuesitosCreateOrConnectWithoutAvaliacaoInput | QuesitosCreateOrConnectWithoutAvaliacaoInput[]
    upsert?: QuesitosUpsertWithWhereUniqueWithoutAvaliacaoInput | QuesitosUpsertWithWhereUniqueWithoutAvaliacaoInput[]
    createMany?: QuesitosCreateManyAvaliacaoInputEnvelope
    set?: QuesitosWhereUniqueInput | QuesitosWhereUniqueInput[]
    disconnect?: QuesitosWhereUniqueInput | QuesitosWhereUniqueInput[]
    delete?: QuesitosWhereUniqueInput | QuesitosWhereUniqueInput[]
    connect?: QuesitosWhereUniqueInput | QuesitosWhereUniqueInput[]
    update?: QuesitosUpdateWithWhereUniqueWithoutAvaliacaoInput | QuesitosUpdateWithWhereUniqueWithoutAvaliacaoInput[]
    updateMany?: QuesitosUpdateManyWithWhereWithoutAvaliacaoInput | QuesitosUpdateManyWithWhereWithoutAvaliacaoInput[]
    deleteMany?: QuesitosScalarWhereInput | QuesitosScalarWhereInput[]
  }

  export type CandidatoUpdateOneRequiredWithoutAvalicoesNestedInput = {
    create?: XOR<CandidatoCreateWithoutAvalicoesInput, CandidatoUncheckedCreateWithoutAvalicoesInput>
    connectOrCreate?: CandidatoCreateOrConnectWithoutAvalicoesInput
    upsert?: CandidatoUpsertWithoutAvalicoesInput
    connect?: CandidatoWhereUniqueInput
    update?: XOR<XOR<CandidatoUpdateToOneWithWhereWithoutAvalicoesInput, CandidatoUpdateWithoutAvalicoesInput>, CandidatoUncheckedUpdateWithoutAvalicoesInput>
  }

  export type FichaCandidatoUpdateOneWithoutAvaliacoesNestedInput = {
    create?: XOR<FichaCandidatoCreateWithoutAvaliacoesInput, FichaCandidatoUncheckedCreateWithoutAvaliacoesInput>
    connectOrCreate?: FichaCandidatoCreateOrConnectWithoutAvaliacoesInput
    upsert?: FichaCandidatoUpsertWithoutAvaliacoesInput
    disconnect?: FichaCandidatoWhereInput | boolean
    delete?: FichaCandidatoWhereInput | boolean
    connect?: FichaCandidatoWhereUniqueInput
    update?: XOR<XOR<FichaCandidatoUpdateToOneWithWhereWithoutAvaliacoesInput, FichaCandidatoUpdateWithoutAvaliacoesInput>, FichaCandidatoUncheckedUpdateWithoutAvaliacoesInput>
  }

  export type QuesitosUncheckedUpdateManyWithoutAvaliacaoNestedInput = {
    create?: XOR<QuesitosCreateWithoutAvaliacaoInput, QuesitosUncheckedCreateWithoutAvaliacaoInput> | QuesitosCreateWithoutAvaliacaoInput[] | QuesitosUncheckedCreateWithoutAvaliacaoInput[]
    connectOrCreate?: QuesitosCreateOrConnectWithoutAvaliacaoInput | QuesitosCreateOrConnectWithoutAvaliacaoInput[]
    upsert?: QuesitosUpsertWithWhereUniqueWithoutAvaliacaoInput | QuesitosUpsertWithWhereUniqueWithoutAvaliacaoInput[]
    createMany?: QuesitosCreateManyAvaliacaoInputEnvelope
    set?: QuesitosWhereUniqueInput | QuesitosWhereUniqueInput[]
    disconnect?: QuesitosWhereUniqueInput | QuesitosWhereUniqueInput[]
    delete?: QuesitosWhereUniqueInput | QuesitosWhereUniqueInput[]
    connect?: QuesitosWhereUniqueInput | QuesitosWhereUniqueInput[]
    update?: QuesitosUpdateWithWhereUniqueWithoutAvaliacaoInput | QuesitosUpdateWithWhereUniqueWithoutAvaliacaoInput[]
    updateMany?: QuesitosUpdateManyWithWhereWithoutAvaliacaoInput | QuesitosUpdateManyWithWhereWithoutAvaliacaoInput[]
    deleteMany?: QuesitosScalarWhereInput | QuesitosScalarWhereInput[]
  }

  export type CategoriaCreateNestedManyWithoutProvaInput = {
    create?: XOR<CategoriaCreateWithoutProvaInput, CategoriaUncheckedCreateWithoutProvaInput> | CategoriaCreateWithoutProvaInput[] | CategoriaUncheckedCreateWithoutProvaInput[]
    connectOrCreate?: CategoriaCreateOrConnectWithoutProvaInput | CategoriaCreateOrConnectWithoutProvaInput[]
    createMany?: CategoriaCreateManyProvaInputEnvelope
    connect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
  }

  export type ProvaTeoricaCreateNestedManyWithoutProvaInput = {
    create?: XOR<ProvaTeoricaCreateWithoutProvaInput, ProvaTeoricaUncheckedCreateWithoutProvaInput> | ProvaTeoricaCreateWithoutProvaInput[] | ProvaTeoricaUncheckedCreateWithoutProvaInput[]
    connectOrCreate?: ProvaTeoricaCreateOrConnectWithoutProvaInput | ProvaTeoricaCreateOrConnectWithoutProvaInput[]
    createMany?: ProvaTeoricaCreateManyProvaInputEnvelope
    connect?: ProvaTeoricaWhereUniqueInput | ProvaTeoricaWhereUniqueInput[]
  }

  export type ProvaPraticaCreateNestedManyWithoutProvaInput = {
    create?: XOR<ProvaPraticaCreateWithoutProvaInput, ProvaPraticaUncheckedCreateWithoutProvaInput> | ProvaPraticaCreateWithoutProvaInput[] | ProvaPraticaUncheckedCreateWithoutProvaInput[]
    connectOrCreate?: ProvaPraticaCreateOrConnectWithoutProvaInput | ProvaPraticaCreateOrConnectWithoutProvaInput[]
    createMany?: ProvaPraticaCreateManyProvaInputEnvelope
    connect?: ProvaPraticaWhereUniqueInput | ProvaPraticaWhereUniqueInput[]
  }

  export type RecursoCreateNestedManyWithoutProvaInput = {
    create?: XOR<RecursoCreateWithoutProvaInput, RecursoUncheckedCreateWithoutProvaInput> | RecursoCreateWithoutProvaInput[] | RecursoUncheckedCreateWithoutProvaInput[]
    connectOrCreate?: RecursoCreateOrConnectWithoutProvaInput | RecursoCreateOrConnectWithoutProvaInput[]
    createMany?: RecursoCreateManyProvaInputEnvelope
    connect?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
  }

  export type AvaliacaoCreateNestedManyWithoutProvaInput = {
    create?: XOR<AvaliacaoCreateWithoutProvaInput, AvaliacaoUncheckedCreateWithoutProvaInput> | AvaliacaoCreateWithoutProvaInput[] | AvaliacaoUncheckedCreateWithoutProvaInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutProvaInput | AvaliacaoCreateOrConnectWithoutProvaInput[]
    createMany?: AvaliacaoCreateManyProvaInputEnvelope
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
  }

  export type CategoriaUncheckedCreateNestedManyWithoutProvaInput = {
    create?: XOR<CategoriaCreateWithoutProvaInput, CategoriaUncheckedCreateWithoutProvaInput> | CategoriaCreateWithoutProvaInput[] | CategoriaUncheckedCreateWithoutProvaInput[]
    connectOrCreate?: CategoriaCreateOrConnectWithoutProvaInput | CategoriaCreateOrConnectWithoutProvaInput[]
    createMany?: CategoriaCreateManyProvaInputEnvelope
    connect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
  }

  export type ProvaTeoricaUncheckedCreateNestedManyWithoutProvaInput = {
    create?: XOR<ProvaTeoricaCreateWithoutProvaInput, ProvaTeoricaUncheckedCreateWithoutProvaInput> | ProvaTeoricaCreateWithoutProvaInput[] | ProvaTeoricaUncheckedCreateWithoutProvaInput[]
    connectOrCreate?: ProvaTeoricaCreateOrConnectWithoutProvaInput | ProvaTeoricaCreateOrConnectWithoutProvaInput[]
    createMany?: ProvaTeoricaCreateManyProvaInputEnvelope
    connect?: ProvaTeoricaWhereUniqueInput | ProvaTeoricaWhereUniqueInput[]
  }

  export type ProvaPraticaUncheckedCreateNestedManyWithoutProvaInput = {
    create?: XOR<ProvaPraticaCreateWithoutProvaInput, ProvaPraticaUncheckedCreateWithoutProvaInput> | ProvaPraticaCreateWithoutProvaInput[] | ProvaPraticaUncheckedCreateWithoutProvaInput[]
    connectOrCreate?: ProvaPraticaCreateOrConnectWithoutProvaInput | ProvaPraticaCreateOrConnectWithoutProvaInput[]
    createMany?: ProvaPraticaCreateManyProvaInputEnvelope
    connect?: ProvaPraticaWhereUniqueInput | ProvaPraticaWhereUniqueInput[]
  }

  export type RecursoUncheckedCreateNestedManyWithoutProvaInput = {
    create?: XOR<RecursoCreateWithoutProvaInput, RecursoUncheckedCreateWithoutProvaInput> | RecursoCreateWithoutProvaInput[] | RecursoUncheckedCreateWithoutProvaInput[]
    connectOrCreate?: RecursoCreateOrConnectWithoutProvaInput | RecursoCreateOrConnectWithoutProvaInput[]
    createMany?: RecursoCreateManyProvaInputEnvelope
    connect?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
  }

  export type AvaliacaoUncheckedCreateNestedManyWithoutProvaInput = {
    create?: XOR<AvaliacaoCreateWithoutProvaInput, AvaliacaoUncheckedCreateWithoutProvaInput> | AvaliacaoCreateWithoutProvaInput[] | AvaliacaoUncheckedCreateWithoutProvaInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutProvaInput | AvaliacaoCreateOrConnectWithoutProvaInput[]
    createMany?: AvaliacaoCreateManyProvaInputEnvelope
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
  }

  export type CategoriaUpdateManyWithoutProvaNestedInput = {
    create?: XOR<CategoriaCreateWithoutProvaInput, CategoriaUncheckedCreateWithoutProvaInput> | CategoriaCreateWithoutProvaInput[] | CategoriaUncheckedCreateWithoutProvaInput[]
    connectOrCreate?: CategoriaCreateOrConnectWithoutProvaInput | CategoriaCreateOrConnectWithoutProvaInput[]
    upsert?: CategoriaUpsertWithWhereUniqueWithoutProvaInput | CategoriaUpsertWithWhereUniqueWithoutProvaInput[]
    createMany?: CategoriaCreateManyProvaInputEnvelope
    set?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    disconnect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    delete?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    connect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    update?: CategoriaUpdateWithWhereUniqueWithoutProvaInput | CategoriaUpdateWithWhereUniqueWithoutProvaInput[]
    updateMany?: CategoriaUpdateManyWithWhereWithoutProvaInput | CategoriaUpdateManyWithWhereWithoutProvaInput[]
    deleteMany?: CategoriaScalarWhereInput | CategoriaScalarWhereInput[]
  }

  export type ProvaTeoricaUpdateManyWithoutProvaNestedInput = {
    create?: XOR<ProvaTeoricaCreateWithoutProvaInput, ProvaTeoricaUncheckedCreateWithoutProvaInput> | ProvaTeoricaCreateWithoutProvaInput[] | ProvaTeoricaUncheckedCreateWithoutProvaInput[]
    connectOrCreate?: ProvaTeoricaCreateOrConnectWithoutProvaInput | ProvaTeoricaCreateOrConnectWithoutProvaInput[]
    upsert?: ProvaTeoricaUpsertWithWhereUniqueWithoutProvaInput | ProvaTeoricaUpsertWithWhereUniqueWithoutProvaInput[]
    createMany?: ProvaTeoricaCreateManyProvaInputEnvelope
    set?: ProvaTeoricaWhereUniqueInput | ProvaTeoricaWhereUniqueInput[]
    disconnect?: ProvaTeoricaWhereUniqueInput | ProvaTeoricaWhereUniqueInput[]
    delete?: ProvaTeoricaWhereUniqueInput | ProvaTeoricaWhereUniqueInput[]
    connect?: ProvaTeoricaWhereUniqueInput | ProvaTeoricaWhereUniqueInput[]
    update?: ProvaTeoricaUpdateWithWhereUniqueWithoutProvaInput | ProvaTeoricaUpdateWithWhereUniqueWithoutProvaInput[]
    updateMany?: ProvaTeoricaUpdateManyWithWhereWithoutProvaInput | ProvaTeoricaUpdateManyWithWhereWithoutProvaInput[]
    deleteMany?: ProvaTeoricaScalarWhereInput | ProvaTeoricaScalarWhereInput[]
  }

  export type ProvaPraticaUpdateManyWithoutProvaNestedInput = {
    create?: XOR<ProvaPraticaCreateWithoutProvaInput, ProvaPraticaUncheckedCreateWithoutProvaInput> | ProvaPraticaCreateWithoutProvaInput[] | ProvaPraticaUncheckedCreateWithoutProvaInput[]
    connectOrCreate?: ProvaPraticaCreateOrConnectWithoutProvaInput | ProvaPraticaCreateOrConnectWithoutProvaInput[]
    upsert?: ProvaPraticaUpsertWithWhereUniqueWithoutProvaInput | ProvaPraticaUpsertWithWhereUniqueWithoutProvaInput[]
    createMany?: ProvaPraticaCreateManyProvaInputEnvelope
    set?: ProvaPraticaWhereUniqueInput | ProvaPraticaWhereUniqueInput[]
    disconnect?: ProvaPraticaWhereUniqueInput | ProvaPraticaWhereUniqueInput[]
    delete?: ProvaPraticaWhereUniqueInput | ProvaPraticaWhereUniqueInput[]
    connect?: ProvaPraticaWhereUniqueInput | ProvaPraticaWhereUniqueInput[]
    update?: ProvaPraticaUpdateWithWhereUniqueWithoutProvaInput | ProvaPraticaUpdateWithWhereUniqueWithoutProvaInput[]
    updateMany?: ProvaPraticaUpdateManyWithWhereWithoutProvaInput | ProvaPraticaUpdateManyWithWhereWithoutProvaInput[]
    deleteMany?: ProvaPraticaScalarWhereInput | ProvaPraticaScalarWhereInput[]
  }

  export type RecursoUpdateManyWithoutProvaNestedInput = {
    create?: XOR<RecursoCreateWithoutProvaInput, RecursoUncheckedCreateWithoutProvaInput> | RecursoCreateWithoutProvaInput[] | RecursoUncheckedCreateWithoutProvaInput[]
    connectOrCreate?: RecursoCreateOrConnectWithoutProvaInput | RecursoCreateOrConnectWithoutProvaInput[]
    upsert?: RecursoUpsertWithWhereUniqueWithoutProvaInput | RecursoUpsertWithWhereUniqueWithoutProvaInput[]
    createMany?: RecursoCreateManyProvaInputEnvelope
    set?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    disconnect?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    delete?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    connect?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    update?: RecursoUpdateWithWhereUniqueWithoutProvaInput | RecursoUpdateWithWhereUniqueWithoutProvaInput[]
    updateMany?: RecursoUpdateManyWithWhereWithoutProvaInput | RecursoUpdateManyWithWhereWithoutProvaInput[]
    deleteMany?: RecursoScalarWhereInput | RecursoScalarWhereInput[]
  }

  export type AvaliacaoUpdateManyWithoutProvaNestedInput = {
    create?: XOR<AvaliacaoCreateWithoutProvaInput, AvaliacaoUncheckedCreateWithoutProvaInput> | AvaliacaoCreateWithoutProvaInput[] | AvaliacaoUncheckedCreateWithoutProvaInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutProvaInput | AvaliacaoCreateOrConnectWithoutProvaInput[]
    upsert?: AvaliacaoUpsertWithWhereUniqueWithoutProvaInput | AvaliacaoUpsertWithWhereUniqueWithoutProvaInput[]
    createMany?: AvaliacaoCreateManyProvaInputEnvelope
    set?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    disconnect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    delete?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    update?: AvaliacaoUpdateWithWhereUniqueWithoutProvaInput | AvaliacaoUpdateWithWhereUniqueWithoutProvaInput[]
    updateMany?: AvaliacaoUpdateManyWithWhereWithoutProvaInput | AvaliacaoUpdateManyWithWhereWithoutProvaInput[]
    deleteMany?: AvaliacaoScalarWhereInput | AvaliacaoScalarWhereInput[]
  }

  export type CategoriaUncheckedUpdateManyWithoutProvaNestedInput = {
    create?: XOR<CategoriaCreateWithoutProvaInput, CategoriaUncheckedCreateWithoutProvaInput> | CategoriaCreateWithoutProvaInput[] | CategoriaUncheckedCreateWithoutProvaInput[]
    connectOrCreate?: CategoriaCreateOrConnectWithoutProvaInput | CategoriaCreateOrConnectWithoutProvaInput[]
    upsert?: CategoriaUpsertWithWhereUniqueWithoutProvaInput | CategoriaUpsertWithWhereUniqueWithoutProvaInput[]
    createMany?: CategoriaCreateManyProvaInputEnvelope
    set?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    disconnect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    delete?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    connect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    update?: CategoriaUpdateWithWhereUniqueWithoutProvaInput | CategoriaUpdateWithWhereUniqueWithoutProvaInput[]
    updateMany?: CategoriaUpdateManyWithWhereWithoutProvaInput | CategoriaUpdateManyWithWhereWithoutProvaInput[]
    deleteMany?: CategoriaScalarWhereInput | CategoriaScalarWhereInput[]
  }

  export type ProvaTeoricaUncheckedUpdateManyWithoutProvaNestedInput = {
    create?: XOR<ProvaTeoricaCreateWithoutProvaInput, ProvaTeoricaUncheckedCreateWithoutProvaInput> | ProvaTeoricaCreateWithoutProvaInput[] | ProvaTeoricaUncheckedCreateWithoutProvaInput[]
    connectOrCreate?: ProvaTeoricaCreateOrConnectWithoutProvaInput | ProvaTeoricaCreateOrConnectWithoutProvaInput[]
    upsert?: ProvaTeoricaUpsertWithWhereUniqueWithoutProvaInput | ProvaTeoricaUpsertWithWhereUniqueWithoutProvaInput[]
    createMany?: ProvaTeoricaCreateManyProvaInputEnvelope
    set?: ProvaTeoricaWhereUniqueInput | ProvaTeoricaWhereUniqueInput[]
    disconnect?: ProvaTeoricaWhereUniqueInput | ProvaTeoricaWhereUniqueInput[]
    delete?: ProvaTeoricaWhereUniqueInput | ProvaTeoricaWhereUniqueInput[]
    connect?: ProvaTeoricaWhereUniqueInput | ProvaTeoricaWhereUniqueInput[]
    update?: ProvaTeoricaUpdateWithWhereUniqueWithoutProvaInput | ProvaTeoricaUpdateWithWhereUniqueWithoutProvaInput[]
    updateMany?: ProvaTeoricaUpdateManyWithWhereWithoutProvaInput | ProvaTeoricaUpdateManyWithWhereWithoutProvaInput[]
    deleteMany?: ProvaTeoricaScalarWhereInput | ProvaTeoricaScalarWhereInput[]
  }

  export type ProvaPraticaUncheckedUpdateManyWithoutProvaNestedInput = {
    create?: XOR<ProvaPraticaCreateWithoutProvaInput, ProvaPraticaUncheckedCreateWithoutProvaInput> | ProvaPraticaCreateWithoutProvaInput[] | ProvaPraticaUncheckedCreateWithoutProvaInput[]
    connectOrCreate?: ProvaPraticaCreateOrConnectWithoutProvaInput | ProvaPraticaCreateOrConnectWithoutProvaInput[]
    upsert?: ProvaPraticaUpsertWithWhereUniqueWithoutProvaInput | ProvaPraticaUpsertWithWhereUniqueWithoutProvaInput[]
    createMany?: ProvaPraticaCreateManyProvaInputEnvelope
    set?: ProvaPraticaWhereUniqueInput | ProvaPraticaWhereUniqueInput[]
    disconnect?: ProvaPraticaWhereUniqueInput | ProvaPraticaWhereUniqueInput[]
    delete?: ProvaPraticaWhereUniqueInput | ProvaPraticaWhereUniqueInput[]
    connect?: ProvaPraticaWhereUniqueInput | ProvaPraticaWhereUniqueInput[]
    update?: ProvaPraticaUpdateWithWhereUniqueWithoutProvaInput | ProvaPraticaUpdateWithWhereUniqueWithoutProvaInput[]
    updateMany?: ProvaPraticaUpdateManyWithWhereWithoutProvaInput | ProvaPraticaUpdateManyWithWhereWithoutProvaInput[]
    deleteMany?: ProvaPraticaScalarWhereInput | ProvaPraticaScalarWhereInput[]
  }

  export type RecursoUncheckedUpdateManyWithoutProvaNestedInput = {
    create?: XOR<RecursoCreateWithoutProvaInput, RecursoUncheckedCreateWithoutProvaInput> | RecursoCreateWithoutProvaInput[] | RecursoUncheckedCreateWithoutProvaInput[]
    connectOrCreate?: RecursoCreateOrConnectWithoutProvaInput | RecursoCreateOrConnectWithoutProvaInput[]
    upsert?: RecursoUpsertWithWhereUniqueWithoutProvaInput | RecursoUpsertWithWhereUniqueWithoutProvaInput[]
    createMany?: RecursoCreateManyProvaInputEnvelope
    set?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    disconnect?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    delete?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    connect?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    update?: RecursoUpdateWithWhereUniqueWithoutProvaInput | RecursoUpdateWithWhereUniqueWithoutProvaInput[]
    updateMany?: RecursoUpdateManyWithWhereWithoutProvaInput | RecursoUpdateManyWithWhereWithoutProvaInput[]
    deleteMany?: RecursoScalarWhereInput | RecursoScalarWhereInput[]
  }

  export type AvaliacaoUncheckedUpdateManyWithoutProvaNestedInput = {
    create?: XOR<AvaliacaoCreateWithoutProvaInput, AvaliacaoUncheckedCreateWithoutProvaInput> | AvaliacaoCreateWithoutProvaInput[] | AvaliacaoUncheckedCreateWithoutProvaInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutProvaInput | AvaliacaoCreateOrConnectWithoutProvaInput[]
    upsert?: AvaliacaoUpsertWithWhereUniqueWithoutProvaInput | AvaliacaoUpsertWithWhereUniqueWithoutProvaInput[]
    createMany?: AvaliacaoCreateManyProvaInputEnvelope
    set?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    disconnect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    delete?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    update?: AvaliacaoUpdateWithWhereUniqueWithoutProvaInput | AvaliacaoUpdateWithWhereUniqueWithoutProvaInput[]
    updateMany?: AvaliacaoUpdateManyWithWhereWithoutProvaInput | AvaliacaoUpdateManyWithWhereWithoutProvaInput[]
    deleteMany?: AvaliacaoScalarWhereInput | AvaliacaoScalarWhereInput[]
  }

  export type ProvaCreateNestedOneWithoutProvaTeoricaInput = {
    create?: XOR<ProvaCreateWithoutProvaTeoricaInput, ProvaUncheckedCreateWithoutProvaTeoricaInput>
    connectOrCreate?: ProvaCreateOrConnectWithoutProvaTeoricaInput
    connect?: ProvaWhereUniqueInput
  }

  export type QuesitosCreateNestedManyWithoutProvaTeoricaInput = {
    create?: XOR<QuesitosCreateWithoutProvaTeoricaInput, QuesitosUncheckedCreateWithoutProvaTeoricaInput> | QuesitosCreateWithoutProvaTeoricaInput[] | QuesitosUncheckedCreateWithoutProvaTeoricaInput[]
    connectOrCreate?: QuesitosCreateOrConnectWithoutProvaTeoricaInput | QuesitosCreateOrConnectWithoutProvaTeoricaInput[]
    createMany?: QuesitosCreateManyProvaTeoricaInputEnvelope
    connect?: QuesitosWhereUniqueInput | QuesitosWhereUniqueInput[]
  }

  export type CategoriaCreateNestedManyWithoutProvaTeoricaInput = {
    create?: XOR<CategoriaCreateWithoutProvaTeoricaInput, CategoriaUncheckedCreateWithoutProvaTeoricaInput> | CategoriaCreateWithoutProvaTeoricaInput[] | CategoriaUncheckedCreateWithoutProvaTeoricaInput[]
    connectOrCreate?: CategoriaCreateOrConnectWithoutProvaTeoricaInput | CategoriaCreateOrConnectWithoutProvaTeoricaInput[]
    createMany?: CategoriaCreateManyProvaTeoricaInputEnvelope
    connect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
  }

  export type RecursoCreateNestedManyWithoutProvaTeoricaInput = {
    create?: XOR<RecursoCreateWithoutProvaTeoricaInput, RecursoUncheckedCreateWithoutProvaTeoricaInput> | RecursoCreateWithoutProvaTeoricaInput[] | RecursoUncheckedCreateWithoutProvaTeoricaInput[]
    connectOrCreate?: RecursoCreateOrConnectWithoutProvaTeoricaInput | RecursoCreateOrConnectWithoutProvaTeoricaInput[]
    createMany?: RecursoCreateManyProvaTeoricaInputEnvelope
    connect?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
  }

  export type QuesitosUncheckedCreateNestedManyWithoutProvaTeoricaInput = {
    create?: XOR<QuesitosCreateWithoutProvaTeoricaInput, QuesitosUncheckedCreateWithoutProvaTeoricaInput> | QuesitosCreateWithoutProvaTeoricaInput[] | QuesitosUncheckedCreateWithoutProvaTeoricaInput[]
    connectOrCreate?: QuesitosCreateOrConnectWithoutProvaTeoricaInput | QuesitosCreateOrConnectWithoutProvaTeoricaInput[]
    createMany?: QuesitosCreateManyProvaTeoricaInputEnvelope
    connect?: QuesitosWhereUniqueInput | QuesitosWhereUniqueInput[]
  }

  export type CategoriaUncheckedCreateNestedManyWithoutProvaTeoricaInput = {
    create?: XOR<CategoriaCreateWithoutProvaTeoricaInput, CategoriaUncheckedCreateWithoutProvaTeoricaInput> | CategoriaCreateWithoutProvaTeoricaInput[] | CategoriaUncheckedCreateWithoutProvaTeoricaInput[]
    connectOrCreate?: CategoriaCreateOrConnectWithoutProvaTeoricaInput | CategoriaCreateOrConnectWithoutProvaTeoricaInput[]
    createMany?: CategoriaCreateManyProvaTeoricaInputEnvelope
    connect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
  }

  export type RecursoUncheckedCreateNestedManyWithoutProvaTeoricaInput = {
    create?: XOR<RecursoCreateWithoutProvaTeoricaInput, RecursoUncheckedCreateWithoutProvaTeoricaInput> | RecursoCreateWithoutProvaTeoricaInput[] | RecursoUncheckedCreateWithoutProvaTeoricaInput[]
    connectOrCreate?: RecursoCreateOrConnectWithoutProvaTeoricaInput | RecursoCreateOrConnectWithoutProvaTeoricaInput[]
    createMany?: RecursoCreateManyProvaTeoricaInputEnvelope
    connect?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Bytes
  }

  export type ProvaUpdateOneWithoutProvaTeoricaNestedInput = {
    create?: XOR<ProvaCreateWithoutProvaTeoricaInput, ProvaUncheckedCreateWithoutProvaTeoricaInput>
    connectOrCreate?: ProvaCreateOrConnectWithoutProvaTeoricaInput
    upsert?: ProvaUpsertWithoutProvaTeoricaInput
    disconnect?: ProvaWhereInput | boolean
    delete?: ProvaWhereInput | boolean
    connect?: ProvaWhereUniqueInput
    update?: XOR<XOR<ProvaUpdateToOneWithWhereWithoutProvaTeoricaInput, ProvaUpdateWithoutProvaTeoricaInput>, ProvaUncheckedUpdateWithoutProvaTeoricaInput>
  }

  export type QuesitosUpdateManyWithoutProvaTeoricaNestedInput = {
    create?: XOR<QuesitosCreateWithoutProvaTeoricaInput, QuesitosUncheckedCreateWithoutProvaTeoricaInput> | QuesitosCreateWithoutProvaTeoricaInput[] | QuesitosUncheckedCreateWithoutProvaTeoricaInput[]
    connectOrCreate?: QuesitosCreateOrConnectWithoutProvaTeoricaInput | QuesitosCreateOrConnectWithoutProvaTeoricaInput[]
    upsert?: QuesitosUpsertWithWhereUniqueWithoutProvaTeoricaInput | QuesitosUpsertWithWhereUniqueWithoutProvaTeoricaInput[]
    createMany?: QuesitosCreateManyProvaTeoricaInputEnvelope
    set?: QuesitosWhereUniqueInput | QuesitosWhereUniqueInput[]
    disconnect?: QuesitosWhereUniqueInput | QuesitosWhereUniqueInput[]
    delete?: QuesitosWhereUniqueInput | QuesitosWhereUniqueInput[]
    connect?: QuesitosWhereUniqueInput | QuesitosWhereUniqueInput[]
    update?: QuesitosUpdateWithWhereUniqueWithoutProvaTeoricaInput | QuesitosUpdateWithWhereUniqueWithoutProvaTeoricaInput[]
    updateMany?: QuesitosUpdateManyWithWhereWithoutProvaTeoricaInput | QuesitosUpdateManyWithWhereWithoutProvaTeoricaInput[]
    deleteMany?: QuesitosScalarWhereInput | QuesitosScalarWhereInput[]
  }

  export type CategoriaUpdateManyWithoutProvaTeoricaNestedInput = {
    create?: XOR<CategoriaCreateWithoutProvaTeoricaInput, CategoriaUncheckedCreateWithoutProvaTeoricaInput> | CategoriaCreateWithoutProvaTeoricaInput[] | CategoriaUncheckedCreateWithoutProvaTeoricaInput[]
    connectOrCreate?: CategoriaCreateOrConnectWithoutProvaTeoricaInput | CategoriaCreateOrConnectWithoutProvaTeoricaInput[]
    upsert?: CategoriaUpsertWithWhereUniqueWithoutProvaTeoricaInput | CategoriaUpsertWithWhereUniqueWithoutProvaTeoricaInput[]
    createMany?: CategoriaCreateManyProvaTeoricaInputEnvelope
    set?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    disconnect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    delete?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    connect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    update?: CategoriaUpdateWithWhereUniqueWithoutProvaTeoricaInput | CategoriaUpdateWithWhereUniqueWithoutProvaTeoricaInput[]
    updateMany?: CategoriaUpdateManyWithWhereWithoutProvaTeoricaInput | CategoriaUpdateManyWithWhereWithoutProvaTeoricaInput[]
    deleteMany?: CategoriaScalarWhereInput | CategoriaScalarWhereInput[]
  }

  export type RecursoUpdateManyWithoutProvaTeoricaNestedInput = {
    create?: XOR<RecursoCreateWithoutProvaTeoricaInput, RecursoUncheckedCreateWithoutProvaTeoricaInput> | RecursoCreateWithoutProvaTeoricaInput[] | RecursoUncheckedCreateWithoutProvaTeoricaInput[]
    connectOrCreate?: RecursoCreateOrConnectWithoutProvaTeoricaInput | RecursoCreateOrConnectWithoutProvaTeoricaInput[]
    upsert?: RecursoUpsertWithWhereUniqueWithoutProvaTeoricaInput | RecursoUpsertWithWhereUniqueWithoutProvaTeoricaInput[]
    createMany?: RecursoCreateManyProvaTeoricaInputEnvelope
    set?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    disconnect?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    delete?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    connect?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    update?: RecursoUpdateWithWhereUniqueWithoutProvaTeoricaInput | RecursoUpdateWithWhereUniqueWithoutProvaTeoricaInput[]
    updateMany?: RecursoUpdateManyWithWhereWithoutProvaTeoricaInput | RecursoUpdateManyWithWhereWithoutProvaTeoricaInput[]
    deleteMany?: RecursoScalarWhereInput | RecursoScalarWhereInput[]
  }

  export type QuesitosUncheckedUpdateManyWithoutProvaTeoricaNestedInput = {
    create?: XOR<QuesitosCreateWithoutProvaTeoricaInput, QuesitosUncheckedCreateWithoutProvaTeoricaInput> | QuesitosCreateWithoutProvaTeoricaInput[] | QuesitosUncheckedCreateWithoutProvaTeoricaInput[]
    connectOrCreate?: QuesitosCreateOrConnectWithoutProvaTeoricaInput | QuesitosCreateOrConnectWithoutProvaTeoricaInput[]
    upsert?: QuesitosUpsertWithWhereUniqueWithoutProvaTeoricaInput | QuesitosUpsertWithWhereUniqueWithoutProvaTeoricaInput[]
    createMany?: QuesitosCreateManyProvaTeoricaInputEnvelope
    set?: QuesitosWhereUniqueInput | QuesitosWhereUniqueInput[]
    disconnect?: QuesitosWhereUniqueInput | QuesitosWhereUniqueInput[]
    delete?: QuesitosWhereUniqueInput | QuesitosWhereUniqueInput[]
    connect?: QuesitosWhereUniqueInput | QuesitosWhereUniqueInput[]
    update?: QuesitosUpdateWithWhereUniqueWithoutProvaTeoricaInput | QuesitosUpdateWithWhereUniqueWithoutProvaTeoricaInput[]
    updateMany?: QuesitosUpdateManyWithWhereWithoutProvaTeoricaInput | QuesitosUpdateManyWithWhereWithoutProvaTeoricaInput[]
    deleteMany?: QuesitosScalarWhereInput | QuesitosScalarWhereInput[]
  }

  export type CategoriaUncheckedUpdateManyWithoutProvaTeoricaNestedInput = {
    create?: XOR<CategoriaCreateWithoutProvaTeoricaInput, CategoriaUncheckedCreateWithoutProvaTeoricaInput> | CategoriaCreateWithoutProvaTeoricaInput[] | CategoriaUncheckedCreateWithoutProvaTeoricaInput[]
    connectOrCreate?: CategoriaCreateOrConnectWithoutProvaTeoricaInput | CategoriaCreateOrConnectWithoutProvaTeoricaInput[]
    upsert?: CategoriaUpsertWithWhereUniqueWithoutProvaTeoricaInput | CategoriaUpsertWithWhereUniqueWithoutProvaTeoricaInput[]
    createMany?: CategoriaCreateManyProvaTeoricaInputEnvelope
    set?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    disconnect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    delete?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    connect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    update?: CategoriaUpdateWithWhereUniqueWithoutProvaTeoricaInput | CategoriaUpdateWithWhereUniqueWithoutProvaTeoricaInput[]
    updateMany?: CategoriaUpdateManyWithWhereWithoutProvaTeoricaInput | CategoriaUpdateManyWithWhereWithoutProvaTeoricaInput[]
    deleteMany?: CategoriaScalarWhereInput | CategoriaScalarWhereInput[]
  }

  export type RecursoUncheckedUpdateManyWithoutProvaTeoricaNestedInput = {
    create?: XOR<RecursoCreateWithoutProvaTeoricaInput, RecursoUncheckedCreateWithoutProvaTeoricaInput> | RecursoCreateWithoutProvaTeoricaInput[] | RecursoUncheckedCreateWithoutProvaTeoricaInput[]
    connectOrCreate?: RecursoCreateOrConnectWithoutProvaTeoricaInput | RecursoCreateOrConnectWithoutProvaTeoricaInput[]
    upsert?: RecursoUpsertWithWhereUniqueWithoutProvaTeoricaInput | RecursoUpsertWithWhereUniqueWithoutProvaTeoricaInput[]
    createMany?: RecursoCreateManyProvaTeoricaInputEnvelope
    set?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    disconnect?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    delete?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    connect?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    update?: RecursoUpdateWithWhereUniqueWithoutProvaTeoricaInput | RecursoUpdateWithWhereUniqueWithoutProvaTeoricaInput[]
    updateMany?: RecursoUpdateManyWithWhereWithoutProvaTeoricaInput | RecursoUpdateManyWithWhereWithoutProvaTeoricaInput[]
    deleteMany?: RecursoScalarWhereInput | RecursoScalarWhereInput[]
  }

  export type ProvaCreateNestedOneWithoutProvaPraticaInput = {
    create?: XOR<ProvaCreateWithoutProvaPraticaInput, ProvaUncheckedCreateWithoutProvaPraticaInput>
    connectOrCreate?: ProvaCreateOrConnectWithoutProvaPraticaInput
    connect?: ProvaWhereUniqueInput
  }

  export type BlocoProvaCreateNestedManyWithoutProvaPraticaInput = {
    create?: XOR<BlocoProvaCreateWithoutProvaPraticaInput, BlocoProvaUncheckedCreateWithoutProvaPraticaInput> | BlocoProvaCreateWithoutProvaPraticaInput[] | BlocoProvaUncheckedCreateWithoutProvaPraticaInput[]
    connectOrCreate?: BlocoProvaCreateOrConnectWithoutProvaPraticaInput | BlocoProvaCreateOrConnectWithoutProvaPraticaInput[]
    createMany?: BlocoProvaCreateManyProvaPraticaInputEnvelope
    connect?: BlocoProvaWhereUniqueInput | BlocoProvaWhereUniqueInput[]
  }

  export type CategoriaCreateNestedManyWithoutProvaPraticaInput = {
    create?: XOR<CategoriaCreateWithoutProvaPraticaInput, CategoriaUncheckedCreateWithoutProvaPraticaInput> | CategoriaCreateWithoutProvaPraticaInput[] | CategoriaUncheckedCreateWithoutProvaPraticaInput[]
    connectOrCreate?: CategoriaCreateOrConnectWithoutProvaPraticaInput | CategoriaCreateOrConnectWithoutProvaPraticaInput[]
    createMany?: CategoriaCreateManyProvaPraticaInputEnvelope
    connect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
  }

  export type RecursoCreateNestedManyWithoutProvaPraticaInput = {
    create?: XOR<RecursoCreateWithoutProvaPraticaInput, RecursoUncheckedCreateWithoutProvaPraticaInput> | RecursoCreateWithoutProvaPraticaInput[] | RecursoUncheckedCreateWithoutProvaPraticaInput[]
    connectOrCreate?: RecursoCreateOrConnectWithoutProvaPraticaInput | RecursoCreateOrConnectWithoutProvaPraticaInput[]
    createMany?: RecursoCreateManyProvaPraticaInputEnvelope
    connect?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
  }

  export type BlocoProvaUncheckedCreateNestedManyWithoutProvaPraticaInput = {
    create?: XOR<BlocoProvaCreateWithoutProvaPraticaInput, BlocoProvaUncheckedCreateWithoutProvaPraticaInput> | BlocoProvaCreateWithoutProvaPraticaInput[] | BlocoProvaUncheckedCreateWithoutProvaPraticaInput[]
    connectOrCreate?: BlocoProvaCreateOrConnectWithoutProvaPraticaInput | BlocoProvaCreateOrConnectWithoutProvaPraticaInput[]
    createMany?: BlocoProvaCreateManyProvaPraticaInputEnvelope
    connect?: BlocoProvaWhereUniqueInput | BlocoProvaWhereUniqueInput[]
  }

  export type CategoriaUncheckedCreateNestedManyWithoutProvaPraticaInput = {
    create?: XOR<CategoriaCreateWithoutProvaPraticaInput, CategoriaUncheckedCreateWithoutProvaPraticaInput> | CategoriaCreateWithoutProvaPraticaInput[] | CategoriaUncheckedCreateWithoutProvaPraticaInput[]
    connectOrCreate?: CategoriaCreateOrConnectWithoutProvaPraticaInput | CategoriaCreateOrConnectWithoutProvaPraticaInput[]
    createMany?: CategoriaCreateManyProvaPraticaInputEnvelope
    connect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
  }

  export type RecursoUncheckedCreateNestedManyWithoutProvaPraticaInput = {
    create?: XOR<RecursoCreateWithoutProvaPraticaInput, RecursoUncheckedCreateWithoutProvaPraticaInput> | RecursoCreateWithoutProvaPraticaInput[] | RecursoUncheckedCreateWithoutProvaPraticaInput[]
    connectOrCreate?: RecursoCreateOrConnectWithoutProvaPraticaInput | RecursoCreateOrConnectWithoutProvaPraticaInput[]
    createMany?: RecursoCreateManyProvaPraticaInputEnvelope
    connect?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
  }

  export type ProvaUpdateOneWithoutProvaPraticaNestedInput = {
    create?: XOR<ProvaCreateWithoutProvaPraticaInput, ProvaUncheckedCreateWithoutProvaPraticaInput>
    connectOrCreate?: ProvaCreateOrConnectWithoutProvaPraticaInput
    upsert?: ProvaUpsertWithoutProvaPraticaInput
    disconnect?: ProvaWhereInput | boolean
    delete?: ProvaWhereInput | boolean
    connect?: ProvaWhereUniqueInput
    update?: XOR<XOR<ProvaUpdateToOneWithWhereWithoutProvaPraticaInput, ProvaUpdateWithoutProvaPraticaInput>, ProvaUncheckedUpdateWithoutProvaPraticaInput>
  }

  export type BlocoProvaUpdateManyWithoutProvaPraticaNestedInput = {
    create?: XOR<BlocoProvaCreateWithoutProvaPraticaInput, BlocoProvaUncheckedCreateWithoutProvaPraticaInput> | BlocoProvaCreateWithoutProvaPraticaInput[] | BlocoProvaUncheckedCreateWithoutProvaPraticaInput[]
    connectOrCreate?: BlocoProvaCreateOrConnectWithoutProvaPraticaInput | BlocoProvaCreateOrConnectWithoutProvaPraticaInput[]
    upsert?: BlocoProvaUpsertWithWhereUniqueWithoutProvaPraticaInput | BlocoProvaUpsertWithWhereUniqueWithoutProvaPraticaInput[]
    createMany?: BlocoProvaCreateManyProvaPraticaInputEnvelope
    set?: BlocoProvaWhereUniqueInput | BlocoProvaWhereUniqueInput[]
    disconnect?: BlocoProvaWhereUniqueInput | BlocoProvaWhereUniqueInput[]
    delete?: BlocoProvaWhereUniqueInput | BlocoProvaWhereUniqueInput[]
    connect?: BlocoProvaWhereUniqueInput | BlocoProvaWhereUniqueInput[]
    update?: BlocoProvaUpdateWithWhereUniqueWithoutProvaPraticaInput | BlocoProvaUpdateWithWhereUniqueWithoutProvaPraticaInput[]
    updateMany?: BlocoProvaUpdateManyWithWhereWithoutProvaPraticaInput | BlocoProvaUpdateManyWithWhereWithoutProvaPraticaInput[]
    deleteMany?: BlocoProvaScalarWhereInput | BlocoProvaScalarWhereInput[]
  }

  export type CategoriaUpdateManyWithoutProvaPraticaNestedInput = {
    create?: XOR<CategoriaCreateWithoutProvaPraticaInput, CategoriaUncheckedCreateWithoutProvaPraticaInput> | CategoriaCreateWithoutProvaPraticaInput[] | CategoriaUncheckedCreateWithoutProvaPraticaInput[]
    connectOrCreate?: CategoriaCreateOrConnectWithoutProvaPraticaInput | CategoriaCreateOrConnectWithoutProvaPraticaInput[]
    upsert?: CategoriaUpsertWithWhereUniqueWithoutProvaPraticaInput | CategoriaUpsertWithWhereUniqueWithoutProvaPraticaInput[]
    createMany?: CategoriaCreateManyProvaPraticaInputEnvelope
    set?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    disconnect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    delete?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    connect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    update?: CategoriaUpdateWithWhereUniqueWithoutProvaPraticaInput | CategoriaUpdateWithWhereUniqueWithoutProvaPraticaInput[]
    updateMany?: CategoriaUpdateManyWithWhereWithoutProvaPraticaInput | CategoriaUpdateManyWithWhereWithoutProvaPraticaInput[]
    deleteMany?: CategoriaScalarWhereInput | CategoriaScalarWhereInput[]
  }

  export type RecursoUpdateManyWithoutProvaPraticaNestedInput = {
    create?: XOR<RecursoCreateWithoutProvaPraticaInput, RecursoUncheckedCreateWithoutProvaPraticaInput> | RecursoCreateWithoutProvaPraticaInput[] | RecursoUncheckedCreateWithoutProvaPraticaInput[]
    connectOrCreate?: RecursoCreateOrConnectWithoutProvaPraticaInput | RecursoCreateOrConnectWithoutProvaPraticaInput[]
    upsert?: RecursoUpsertWithWhereUniqueWithoutProvaPraticaInput | RecursoUpsertWithWhereUniqueWithoutProvaPraticaInput[]
    createMany?: RecursoCreateManyProvaPraticaInputEnvelope
    set?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    disconnect?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    delete?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    connect?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    update?: RecursoUpdateWithWhereUniqueWithoutProvaPraticaInput | RecursoUpdateWithWhereUniqueWithoutProvaPraticaInput[]
    updateMany?: RecursoUpdateManyWithWhereWithoutProvaPraticaInput | RecursoUpdateManyWithWhereWithoutProvaPraticaInput[]
    deleteMany?: RecursoScalarWhereInput | RecursoScalarWhereInput[]
  }

  export type BlocoProvaUncheckedUpdateManyWithoutProvaPraticaNestedInput = {
    create?: XOR<BlocoProvaCreateWithoutProvaPraticaInput, BlocoProvaUncheckedCreateWithoutProvaPraticaInput> | BlocoProvaCreateWithoutProvaPraticaInput[] | BlocoProvaUncheckedCreateWithoutProvaPraticaInput[]
    connectOrCreate?: BlocoProvaCreateOrConnectWithoutProvaPraticaInput | BlocoProvaCreateOrConnectWithoutProvaPraticaInput[]
    upsert?: BlocoProvaUpsertWithWhereUniqueWithoutProvaPraticaInput | BlocoProvaUpsertWithWhereUniqueWithoutProvaPraticaInput[]
    createMany?: BlocoProvaCreateManyProvaPraticaInputEnvelope
    set?: BlocoProvaWhereUniqueInput | BlocoProvaWhereUniqueInput[]
    disconnect?: BlocoProvaWhereUniqueInput | BlocoProvaWhereUniqueInput[]
    delete?: BlocoProvaWhereUniqueInput | BlocoProvaWhereUniqueInput[]
    connect?: BlocoProvaWhereUniqueInput | BlocoProvaWhereUniqueInput[]
    update?: BlocoProvaUpdateWithWhereUniqueWithoutProvaPraticaInput | BlocoProvaUpdateWithWhereUniqueWithoutProvaPraticaInput[]
    updateMany?: BlocoProvaUpdateManyWithWhereWithoutProvaPraticaInput | BlocoProvaUpdateManyWithWhereWithoutProvaPraticaInput[]
    deleteMany?: BlocoProvaScalarWhereInput | BlocoProvaScalarWhereInput[]
  }

  export type CategoriaUncheckedUpdateManyWithoutProvaPraticaNestedInput = {
    create?: XOR<CategoriaCreateWithoutProvaPraticaInput, CategoriaUncheckedCreateWithoutProvaPraticaInput> | CategoriaCreateWithoutProvaPraticaInput[] | CategoriaUncheckedCreateWithoutProvaPraticaInput[]
    connectOrCreate?: CategoriaCreateOrConnectWithoutProvaPraticaInput | CategoriaCreateOrConnectWithoutProvaPraticaInput[]
    upsert?: CategoriaUpsertWithWhereUniqueWithoutProvaPraticaInput | CategoriaUpsertWithWhereUniqueWithoutProvaPraticaInput[]
    createMany?: CategoriaCreateManyProvaPraticaInputEnvelope
    set?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    disconnect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    delete?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    connect?: CategoriaWhereUniqueInput | CategoriaWhereUniqueInput[]
    update?: CategoriaUpdateWithWhereUniqueWithoutProvaPraticaInput | CategoriaUpdateWithWhereUniqueWithoutProvaPraticaInput[]
    updateMany?: CategoriaUpdateManyWithWhereWithoutProvaPraticaInput | CategoriaUpdateManyWithWhereWithoutProvaPraticaInput[]
    deleteMany?: CategoriaScalarWhereInput | CategoriaScalarWhereInput[]
  }

  export type RecursoUncheckedUpdateManyWithoutProvaPraticaNestedInput = {
    create?: XOR<RecursoCreateWithoutProvaPraticaInput, RecursoUncheckedCreateWithoutProvaPraticaInput> | RecursoCreateWithoutProvaPraticaInput[] | RecursoUncheckedCreateWithoutProvaPraticaInput[]
    connectOrCreate?: RecursoCreateOrConnectWithoutProvaPraticaInput | RecursoCreateOrConnectWithoutProvaPraticaInput[]
    upsert?: RecursoUpsertWithWhereUniqueWithoutProvaPraticaInput | RecursoUpsertWithWhereUniqueWithoutProvaPraticaInput[]
    createMany?: RecursoCreateManyProvaPraticaInputEnvelope
    set?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    disconnect?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    delete?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    connect?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    update?: RecursoUpdateWithWhereUniqueWithoutProvaPraticaInput | RecursoUpdateWithWhereUniqueWithoutProvaPraticaInput[]
    updateMany?: RecursoUpdateManyWithWhereWithoutProvaPraticaInput | RecursoUpdateManyWithWhereWithoutProvaPraticaInput[]
    deleteMany?: RecursoScalarWhereInput | RecursoScalarWhereInput[]
  }

  export type ProvaPraticaCreateNestedOneWithoutBlocosProvasInput = {
    create?: XOR<ProvaPraticaCreateWithoutBlocosProvasInput, ProvaPraticaUncheckedCreateWithoutBlocosProvasInput>
    connectOrCreate?: ProvaPraticaCreateOrConnectWithoutBlocosProvasInput
    connect?: ProvaPraticaWhereUniqueInput
  }

  export type QuesitosCreateNestedManyWithoutBlocoProvaInput = {
    create?: XOR<QuesitosCreateWithoutBlocoProvaInput, QuesitosUncheckedCreateWithoutBlocoProvaInput> | QuesitosCreateWithoutBlocoProvaInput[] | QuesitosUncheckedCreateWithoutBlocoProvaInput[]
    connectOrCreate?: QuesitosCreateOrConnectWithoutBlocoProvaInput | QuesitosCreateOrConnectWithoutBlocoProvaInput[]
    createMany?: QuesitosCreateManyBlocoProvaInputEnvelope
    connect?: QuesitosWhereUniqueInput | QuesitosWhereUniqueInput[]
  }

  export type AvaliacaoCreateNestedManyWithoutBlocoProvaInput = {
    create?: XOR<AvaliacaoCreateWithoutBlocoProvaInput, AvaliacaoUncheckedCreateWithoutBlocoProvaInput> | AvaliacaoCreateWithoutBlocoProvaInput[] | AvaliacaoUncheckedCreateWithoutBlocoProvaInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutBlocoProvaInput | AvaliacaoCreateOrConnectWithoutBlocoProvaInput[]
    createMany?: AvaliacaoCreateManyBlocoProvaInputEnvelope
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
  }

  export type QuesitosUncheckedCreateNestedManyWithoutBlocoProvaInput = {
    create?: XOR<QuesitosCreateWithoutBlocoProvaInput, QuesitosUncheckedCreateWithoutBlocoProvaInput> | QuesitosCreateWithoutBlocoProvaInput[] | QuesitosUncheckedCreateWithoutBlocoProvaInput[]
    connectOrCreate?: QuesitosCreateOrConnectWithoutBlocoProvaInput | QuesitosCreateOrConnectWithoutBlocoProvaInput[]
    createMany?: QuesitosCreateManyBlocoProvaInputEnvelope
    connect?: QuesitosWhereUniqueInput | QuesitosWhereUniqueInput[]
  }

  export type AvaliacaoUncheckedCreateNestedManyWithoutBlocoProvaInput = {
    create?: XOR<AvaliacaoCreateWithoutBlocoProvaInput, AvaliacaoUncheckedCreateWithoutBlocoProvaInput> | AvaliacaoCreateWithoutBlocoProvaInput[] | AvaliacaoUncheckedCreateWithoutBlocoProvaInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutBlocoProvaInput | AvaliacaoCreateOrConnectWithoutBlocoProvaInput[]
    createMany?: AvaliacaoCreateManyBlocoProvaInputEnvelope
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
  }

  export type ProvaPraticaUpdateOneWithoutBlocosProvasNestedInput = {
    create?: XOR<ProvaPraticaCreateWithoutBlocosProvasInput, ProvaPraticaUncheckedCreateWithoutBlocosProvasInput>
    connectOrCreate?: ProvaPraticaCreateOrConnectWithoutBlocosProvasInput
    upsert?: ProvaPraticaUpsertWithoutBlocosProvasInput
    disconnect?: ProvaPraticaWhereInput | boolean
    delete?: ProvaPraticaWhereInput | boolean
    connect?: ProvaPraticaWhereUniqueInput
    update?: XOR<XOR<ProvaPraticaUpdateToOneWithWhereWithoutBlocosProvasInput, ProvaPraticaUpdateWithoutBlocosProvasInput>, ProvaPraticaUncheckedUpdateWithoutBlocosProvasInput>
  }

  export type QuesitosUpdateManyWithoutBlocoProvaNestedInput = {
    create?: XOR<QuesitosCreateWithoutBlocoProvaInput, QuesitosUncheckedCreateWithoutBlocoProvaInput> | QuesitosCreateWithoutBlocoProvaInput[] | QuesitosUncheckedCreateWithoutBlocoProvaInput[]
    connectOrCreate?: QuesitosCreateOrConnectWithoutBlocoProvaInput | QuesitosCreateOrConnectWithoutBlocoProvaInput[]
    upsert?: QuesitosUpsertWithWhereUniqueWithoutBlocoProvaInput | QuesitosUpsertWithWhereUniqueWithoutBlocoProvaInput[]
    createMany?: QuesitosCreateManyBlocoProvaInputEnvelope
    set?: QuesitosWhereUniqueInput | QuesitosWhereUniqueInput[]
    disconnect?: QuesitosWhereUniqueInput | QuesitosWhereUniqueInput[]
    delete?: QuesitosWhereUniqueInput | QuesitosWhereUniqueInput[]
    connect?: QuesitosWhereUniqueInput | QuesitosWhereUniqueInput[]
    update?: QuesitosUpdateWithWhereUniqueWithoutBlocoProvaInput | QuesitosUpdateWithWhereUniqueWithoutBlocoProvaInput[]
    updateMany?: QuesitosUpdateManyWithWhereWithoutBlocoProvaInput | QuesitosUpdateManyWithWhereWithoutBlocoProvaInput[]
    deleteMany?: QuesitosScalarWhereInput | QuesitosScalarWhereInput[]
  }

  export type AvaliacaoUpdateManyWithoutBlocoProvaNestedInput = {
    create?: XOR<AvaliacaoCreateWithoutBlocoProvaInput, AvaliacaoUncheckedCreateWithoutBlocoProvaInput> | AvaliacaoCreateWithoutBlocoProvaInput[] | AvaliacaoUncheckedCreateWithoutBlocoProvaInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutBlocoProvaInput | AvaliacaoCreateOrConnectWithoutBlocoProvaInput[]
    upsert?: AvaliacaoUpsertWithWhereUniqueWithoutBlocoProvaInput | AvaliacaoUpsertWithWhereUniqueWithoutBlocoProvaInput[]
    createMany?: AvaliacaoCreateManyBlocoProvaInputEnvelope
    set?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    disconnect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    delete?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    update?: AvaliacaoUpdateWithWhereUniqueWithoutBlocoProvaInput | AvaliacaoUpdateWithWhereUniqueWithoutBlocoProvaInput[]
    updateMany?: AvaliacaoUpdateManyWithWhereWithoutBlocoProvaInput | AvaliacaoUpdateManyWithWhereWithoutBlocoProvaInput[]
    deleteMany?: AvaliacaoScalarWhereInput | AvaliacaoScalarWhereInput[]
  }

  export type QuesitosUncheckedUpdateManyWithoutBlocoProvaNestedInput = {
    create?: XOR<QuesitosCreateWithoutBlocoProvaInput, QuesitosUncheckedCreateWithoutBlocoProvaInput> | QuesitosCreateWithoutBlocoProvaInput[] | QuesitosUncheckedCreateWithoutBlocoProvaInput[]
    connectOrCreate?: QuesitosCreateOrConnectWithoutBlocoProvaInput | QuesitosCreateOrConnectWithoutBlocoProvaInput[]
    upsert?: QuesitosUpsertWithWhereUniqueWithoutBlocoProvaInput | QuesitosUpsertWithWhereUniqueWithoutBlocoProvaInput[]
    createMany?: QuesitosCreateManyBlocoProvaInputEnvelope
    set?: QuesitosWhereUniqueInput | QuesitosWhereUniqueInput[]
    disconnect?: QuesitosWhereUniqueInput | QuesitosWhereUniqueInput[]
    delete?: QuesitosWhereUniqueInput | QuesitosWhereUniqueInput[]
    connect?: QuesitosWhereUniqueInput | QuesitosWhereUniqueInput[]
    update?: QuesitosUpdateWithWhereUniqueWithoutBlocoProvaInput | QuesitosUpdateWithWhereUniqueWithoutBlocoProvaInput[]
    updateMany?: QuesitosUpdateManyWithWhereWithoutBlocoProvaInput | QuesitosUpdateManyWithWhereWithoutBlocoProvaInput[]
    deleteMany?: QuesitosScalarWhereInput | QuesitosScalarWhereInput[]
  }

  export type AvaliacaoUncheckedUpdateManyWithoutBlocoProvaNestedInput = {
    create?: XOR<AvaliacaoCreateWithoutBlocoProvaInput, AvaliacaoUncheckedCreateWithoutBlocoProvaInput> | AvaliacaoCreateWithoutBlocoProvaInput[] | AvaliacaoUncheckedCreateWithoutBlocoProvaInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutBlocoProvaInput | AvaliacaoCreateOrConnectWithoutBlocoProvaInput[]
    upsert?: AvaliacaoUpsertWithWhereUniqueWithoutBlocoProvaInput | AvaliacaoUpsertWithWhereUniqueWithoutBlocoProvaInput[]
    createMany?: AvaliacaoCreateManyBlocoProvaInputEnvelope
    set?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    disconnect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    delete?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    update?: AvaliacaoUpdateWithWhereUniqueWithoutBlocoProvaInput | AvaliacaoUpdateWithWhereUniqueWithoutBlocoProvaInput[]
    updateMany?: AvaliacaoUpdateManyWithWhereWithoutBlocoProvaInput | AvaliacaoUpdateManyWithWhereWithoutBlocoProvaInput[]
    deleteMany?: AvaliacaoScalarWhereInput | AvaliacaoScalarWhereInput[]
  }

  export type BlocoProvaCreateNestedOneWithoutQuesitosInput = {
    create?: XOR<BlocoProvaCreateWithoutQuesitosInput, BlocoProvaUncheckedCreateWithoutQuesitosInput>
    connectOrCreate?: BlocoProvaCreateOrConnectWithoutQuesitosInput
    connect?: BlocoProvaWhereUniqueInput
  }

  export type ProvaTeoricaCreateNestedOneWithoutQuesitosInput = {
    create?: XOR<ProvaTeoricaCreateWithoutQuesitosInput, ProvaTeoricaUncheckedCreateWithoutQuesitosInput>
    connectOrCreate?: ProvaTeoricaCreateOrConnectWithoutQuesitosInput
    connect?: ProvaTeoricaWhereUniqueInput
  }

  export type SubQuesitosCreateNestedManyWithoutQuesitoInput = {
    create?: XOR<SubQuesitosCreateWithoutQuesitoInput, SubQuesitosUncheckedCreateWithoutQuesitoInput> | SubQuesitosCreateWithoutQuesitoInput[] | SubQuesitosUncheckedCreateWithoutQuesitoInput[]
    connectOrCreate?: SubQuesitosCreateOrConnectWithoutQuesitoInput | SubQuesitosCreateOrConnectWithoutQuesitoInput[]
    createMany?: SubQuesitosCreateManyQuesitoInputEnvelope
    connect?: SubQuesitosWhereUniqueInput | SubQuesitosWhereUniqueInput[]
  }

  export type RecursoCreateNestedManyWithoutQuesitoInput = {
    create?: XOR<RecursoCreateWithoutQuesitoInput, RecursoUncheckedCreateWithoutQuesitoInput> | RecursoCreateWithoutQuesitoInput[] | RecursoUncheckedCreateWithoutQuesitoInput[]
    connectOrCreate?: RecursoCreateOrConnectWithoutQuesitoInput | RecursoCreateOrConnectWithoutQuesitoInput[]
    createMany?: RecursoCreateManyQuesitoInputEnvelope
    connect?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
  }

  export type PreferenciaSorteioDancaCreateNestedOneWithoutQuesitosInput = {
    create?: XOR<PreferenciaSorteioDancaCreateWithoutQuesitosInput, PreferenciaSorteioDancaUncheckedCreateWithoutQuesitosInput>
    connectOrCreate?: PreferenciaSorteioDancaCreateOrConnectWithoutQuesitosInput
    connect?: PreferenciaSorteioDancaWhereUniqueInput
  }

  export type AvaliacaoCreateNestedOneWithoutQuesitosInput = {
    create?: XOR<AvaliacaoCreateWithoutQuesitosInput, AvaliacaoUncheckedCreateWithoutQuesitosInput>
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutQuesitosInput
    connect?: AvaliacaoWhereUniqueInput
  }

  export type SubQuesitosUncheckedCreateNestedManyWithoutQuesitoInput = {
    create?: XOR<SubQuesitosCreateWithoutQuesitoInput, SubQuesitosUncheckedCreateWithoutQuesitoInput> | SubQuesitosCreateWithoutQuesitoInput[] | SubQuesitosUncheckedCreateWithoutQuesitoInput[]
    connectOrCreate?: SubQuesitosCreateOrConnectWithoutQuesitoInput | SubQuesitosCreateOrConnectWithoutQuesitoInput[]
    createMany?: SubQuesitosCreateManyQuesitoInputEnvelope
    connect?: SubQuesitosWhereUniqueInput | SubQuesitosWhereUniqueInput[]
  }

  export type RecursoUncheckedCreateNestedManyWithoutQuesitoInput = {
    create?: XOR<RecursoCreateWithoutQuesitoInput, RecursoUncheckedCreateWithoutQuesitoInput> | RecursoCreateWithoutQuesitoInput[] | RecursoUncheckedCreateWithoutQuesitoInput[]
    connectOrCreate?: RecursoCreateOrConnectWithoutQuesitoInput | RecursoCreateOrConnectWithoutQuesitoInput[]
    createMany?: RecursoCreateManyQuesitoInputEnvelope
    connect?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type BlocoProvaUpdateOneWithoutQuesitosNestedInput = {
    create?: XOR<BlocoProvaCreateWithoutQuesitosInput, BlocoProvaUncheckedCreateWithoutQuesitosInput>
    connectOrCreate?: BlocoProvaCreateOrConnectWithoutQuesitosInput
    upsert?: BlocoProvaUpsertWithoutQuesitosInput
    disconnect?: BlocoProvaWhereInput | boolean
    delete?: BlocoProvaWhereInput | boolean
    connect?: BlocoProvaWhereUniqueInput
    update?: XOR<XOR<BlocoProvaUpdateToOneWithWhereWithoutQuesitosInput, BlocoProvaUpdateWithoutQuesitosInput>, BlocoProvaUncheckedUpdateWithoutQuesitosInput>
  }

  export type ProvaTeoricaUpdateOneWithoutQuesitosNestedInput = {
    create?: XOR<ProvaTeoricaCreateWithoutQuesitosInput, ProvaTeoricaUncheckedCreateWithoutQuesitosInput>
    connectOrCreate?: ProvaTeoricaCreateOrConnectWithoutQuesitosInput
    upsert?: ProvaTeoricaUpsertWithoutQuesitosInput
    disconnect?: ProvaTeoricaWhereInput | boolean
    delete?: ProvaTeoricaWhereInput | boolean
    connect?: ProvaTeoricaWhereUniqueInput
    update?: XOR<XOR<ProvaTeoricaUpdateToOneWithWhereWithoutQuesitosInput, ProvaTeoricaUpdateWithoutQuesitosInput>, ProvaTeoricaUncheckedUpdateWithoutQuesitosInput>
  }

  export type SubQuesitosUpdateManyWithoutQuesitoNestedInput = {
    create?: XOR<SubQuesitosCreateWithoutQuesitoInput, SubQuesitosUncheckedCreateWithoutQuesitoInput> | SubQuesitosCreateWithoutQuesitoInput[] | SubQuesitosUncheckedCreateWithoutQuesitoInput[]
    connectOrCreate?: SubQuesitosCreateOrConnectWithoutQuesitoInput | SubQuesitosCreateOrConnectWithoutQuesitoInput[]
    upsert?: SubQuesitosUpsertWithWhereUniqueWithoutQuesitoInput | SubQuesitosUpsertWithWhereUniqueWithoutQuesitoInput[]
    createMany?: SubQuesitosCreateManyQuesitoInputEnvelope
    set?: SubQuesitosWhereUniqueInput | SubQuesitosWhereUniqueInput[]
    disconnect?: SubQuesitosWhereUniqueInput | SubQuesitosWhereUniqueInput[]
    delete?: SubQuesitosWhereUniqueInput | SubQuesitosWhereUniqueInput[]
    connect?: SubQuesitosWhereUniqueInput | SubQuesitosWhereUniqueInput[]
    update?: SubQuesitosUpdateWithWhereUniqueWithoutQuesitoInput | SubQuesitosUpdateWithWhereUniqueWithoutQuesitoInput[]
    updateMany?: SubQuesitosUpdateManyWithWhereWithoutQuesitoInput | SubQuesitosUpdateManyWithWhereWithoutQuesitoInput[]
    deleteMany?: SubQuesitosScalarWhereInput | SubQuesitosScalarWhereInput[]
  }

  export type RecursoUpdateManyWithoutQuesitoNestedInput = {
    create?: XOR<RecursoCreateWithoutQuesitoInput, RecursoUncheckedCreateWithoutQuesitoInput> | RecursoCreateWithoutQuesitoInput[] | RecursoUncheckedCreateWithoutQuesitoInput[]
    connectOrCreate?: RecursoCreateOrConnectWithoutQuesitoInput | RecursoCreateOrConnectWithoutQuesitoInput[]
    upsert?: RecursoUpsertWithWhereUniqueWithoutQuesitoInput | RecursoUpsertWithWhereUniqueWithoutQuesitoInput[]
    createMany?: RecursoCreateManyQuesitoInputEnvelope
    set?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    disconnect?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    delete?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    connect?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    update?: RecursoUpdateWithWhereUniqueWithoutQuesitoInput | RecursoUpdateWithWhereUniqueWithoutQuesitoInput[]
    updateMany?: RecursoUpdateManyWithWhereWithoutQuesitoInput | RecursoUpdateManyWithWhereWithoutQuesitoInput[]
    deleteMany?: RecursoScalarWhereInput | RecursoScalarWhereInput[]
  }

  export type PreferenciaSorteioDancaUpdateOneWithoutQuesitosNestedInput = {
    create?: XOR<PreferenciaSorteioDancaCreateWithoutQuesitosInput, PreferenciaSorteioDancaUncheckedCreateWithoutQuesitosInput>
    connectOrCreate?: PreferenciaSorteioDancaCreateOrConnectWithoutQuesitosInput
    upsert?: PreferenciaSorteioDancaUpsertWithoutQuesitosInput
    disconnect?: PreferenciaSorteioDancaWhereInput | boolean
    delete?: PreferenciaSorteioDancaWhereInput | boolean
    connect?: PreferenciaSorteioDancaWhereUniqueInput
    update?: XOR<XOR<PreferenciaSorteioDancaUpdateToOneWithWhereWithoutQuesitosInput, PreferenciaSorteioDancaUpdateWithoutQuesitosInput>, PreferenciaSorteioDancaUncheckedUpdateWithoutQuesitosInput>
  }

  export type AvaliacaoUpdateOneWithoutQuesitosNestedInput = {
    create?: XOR<AvaliacaoCreateWithoutQuesitosInput, AvaliacaoUncheckedCreateWithoutQuesitosInput>
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutQuesitosInput
    upsert?: AvaliacaoUpsertWithoutQuesitosInput
    disconnect?: AvaliacaoWhereInput | boolean
    delete?: AvaliacaoWhereInput | boolean
    connect?: AvaliacaoWhereUniqueInput
    update?: XOR<XOR<AvaliacaoUpdateToOneWithWhereWithoutQuesitosInput, AvaliacaoUpdateWithoutQuesitosInput>, AvaliacaoUncheckedUpdateWithoutQuesitosInput>
  }

  export type SubQuesitosUncheckedUpdateManyWithoutQuesitoNestedInput = {
    create?: XOR<SubQuesitosCreateWithoutQuesitoInput, SubQuesitosUncheckedCreateWithoutQuesitoInput> | SubQuesitosCreateWithoutQuesitoInput[] | SubQuesitosUncheckedCreateWithoutQuesitoInput[]
    connectOrCreate?: SubQuesitosCreateOrConnectWithoutQuesitoInput | SubQuesitosCreateOrConnectWithoutQuesitoInput[]
    upsert?: SubQuesitosUpsertWithWhereUniqueWithoutQuesitoInput | SubQuesitosUpsertWithWhereUniqueWithoutQuesitoInput[]
    createMany?: SubQuesitosCreateManyQuesitoInputEnvelope
    set?: SubQuesitosWhereUniqueInput | SubQuesitosWhereUniqueInput[]
    disconnect?: SubQuesitosWhereUniqueInput | SubQuesitosWhereUniqueInput[]
    delete?: SubQuesitosWhereUniqueInput | SubQuesitosWhereUniqueInput[]
    connect?: SubQuesitosWhereUniqueInput | SubQuesitosWhereUniqueInput[]
    update?: SubQuesitosUpdateWithWhereUniqueWithoutQuesitoInput | SubQuesitosUpdateWithWhereUniqueWithoutQuesitoInput[]
    updateMany?: SubQuesitosUpdateManyWithWhereWithoutQuesitoInput | SubQuesitosUpdateManyWithWhereWithoutQuesitoInput[]
    deleteMany?: SubQuesitosScalarWhereInput | SubQuesitosScalarWhereInput[]
  }

  export type RecursoUncheckedUpdateManyWithoutQuesitoNestedInput = {
    create?: XOR<RecursoCreateWithoutQuesitoInput, RecursoUncheckedCreateWithoutQuesitoInput> | RecursoCreateWithoutQuesitoInput[] | RecursoUncheckedCreateWithoutQuesitoInput[]
    connectOrCreate?: RecursoCreateOrConnectWithoutQuesitoInput | RecursoCreateOrConnectWithoutQuesitoInput[]
    upsert?: RecursoUpsertWithWhereUniqueWithoutQuesitoInput | RecursoUpsertWithWhereUniqueWithoutQuesitoInput[]
    createMany?: RecursoCreateManyQuesitoInputEnvelope
    set?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    disconnect?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    delete?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    connect?: RecursoWhereUniqueInput | RecursoWhereUniqueInput[]
    update?: RecursoUpdateWithWhereUniqueWithoutQuesitoInput | RecursoUpdateWithWhereUniqueWithoutQuesitoInput[]
    updateMany?: RecursoUpdateManyWithWhereWithoutQuesitoInput | RecursoUpdateManyWithWhereWithoutQuesitoInput[]
    deleteMany?: RecursoScalarWhereInput | RecursoScalarWhereInput[]
  }

  export type QuesitosCreateNestedOneWithoutSubeQuesitosInput = {
    create?: XOR<QuesitosCreateWithoutSubeQuesitosInput, QuesitosUncheckedCreateWithoutSubeQuesitosInput>
    connectOrCreate?: QuesitosCreateOrConnectWithoutSubeQuesitosInput
    connect?: QuesitosWhereUniqueInput
  }

  export type SubQuesitosCreateNestedManyWithoutSubequesitosPaiInput = {
    create?: XOR<SubQuesitosCreateWithoutSubequesitosPaiInput, SubQuesitosUncheckedCreateWithoutSubequesitosPaiInput> | SubQuesitosCreateWithoutSubequesitosPaiInput[] | SubQuesitosUncheckedCreateWithoutSubequesitosPaiInput[]
    connectOrCreate?: SubQuesitosCreateOrConnectWithoutSubequesitosPaiInput | SubQuesitosCreateOrConnectWithoutSubequesitosPaiInput[]
    connect?: SubQuesitosWhereUniqueInput | SubQuesitosWhereUniqueInput[]
  }

  export type SubQuesitosCreateNestedManyWithoutSubequesitosFilhosInput = {
    create?: XOR<SubQuesitosCreateWithoutSubequesitosFilhosInput, SubQuesitosUncheckedCreateWithoutSubequesitosFilhosInput> | SubQuesitosCreateWithoutSubequesitosFilhosInput[] | SubQuesitosUncheckedCreateWithoutSubequesitosFilhosInput[]
    connectOrCreate?: SubQuesitosCreateOrConnectWithoutSubequesitosFilhosInput | SubQuesitosCreateOrConnectWithoutSubequesitosFilhosInput[]
    connect?: SubQuesitosWhereUniqueInput | SubQuesitosWhereUniqueInput[]
  }

  export type SubQuesitosUncheckedCreateNestedManyWithoutSubequesitosPaiInput = {
    create?: XOR<SubQuesitosCreateWithoutSubequesitosPaiInput, SubQuesitosUncheckedCreateWithoutSubequesitosPaiInput> | SubQuesitosCreateWithoutSubequesitosPaiInput[] | SubQuesitosUncheckedCreateWithoutSubequesitosPaiInput[]
    connectOrCreate?: SubQuesitosCreateOrConnectWithoutSubequesitosPaiInput | SubQuesitosCreateOrConnectWithoutSubequesitosPaiInput[]
    connect?: SubQuesitosWhereUniqueInput | SubQuesitosWhereUniqueInput[]
  }

  export type SubQuesitosUncheckedCreateNestedManyWithoutSubequesitosFilhosInput = {
    create?: XOR<SubQuesitosCreateWithoutSubequesitosFilhosInput, SubQuesitosUncheckedCreateWithoutSubequesitosFilhosInput> | SubQuesitosCreateWithoutSubequesitosFilhosInput[] | SubQuesitosUncheckedCreateWithoutSubequesitosFilhosInput[]
    connectOrCreate?: SubQuesitosCreateOrConnectWithoutSubequesitosFilhosInput | SubQuesitosCreateOrConnectWithoutSubequesitosFilhosInput[]
    connect?: SubQuesitosWhereUniqueInput | SubQuesitosWhereUniqueInput[]
  }

  export type QuesitosUpdateOneRequiredWithoutSubeQuesitosNestedInput = {
    create?: XOR<QuesitosCreateWithoutSubeQuesitosInput, QuesitosUncheckedCreateWithoutSubeQuesitosInput>
    connectOrCreate?: QuesitosCreateOrConnectWithoutSubeQuesitosInput
    upsert?: QuesitosUpsertWithoutSubeQuesitosInput
    connect?: QuesitosWhereUniqueInput
    update?: XOR<XOR<QuesitosUpdateToOneWithWhereWithoutSubeQuesitosInput, QuesitosUpdateWithoutSubeQuesitosInput>, QuesitosUncheckedUpdateWithoutSubeQuesitosInput>
  }

  export type SubQuesitosUpdateManyWithoutSubequesitosPaiNestedInput = {
    create?: XOR<SubQuesitosCreateWithoutSubequesitosPaiInput, SubQuesitosUncheckedCreateWithoutSubequesitosPaiInput> | SubQuesitosCreateWithoutSubequesitosPaiInput[] | SubQuesitosUncheckedCreateWithoutSubequesitosPaiInput[]
    connectOrCreate?: SubQuesitosCreateOrConnectWithoutSubequesitosPaiInput | SubQuesitosCreateOrConnectWithoutSubequesitosPaiInput[]
    upsert?: SubQuesitosUpsertWithWhereUniqueWithoutSubequesitosPaiInput | SubQuesitosUpsertWithWhereUniqueWithoutSubequesitosPaiInput[]
    set?: SubQuesitosWhereUniqueInput | SubQuesitosWhereUniqueInput[]
    disconnect?: SubQuesitosWhereUniqueInput | SubQuesitosWhereUniqueInput[]
    delete?: SubQuesitosWhereUniqueInput | SubQuesitosWhereUniqueInput[]
    connect?: SubQuesitosWhereUniqueInput | SubQuesitosWhereUniqueInput[]
    update?: SubQuesitosUpdateWithWhereUniqueWithoutSubequesitosPaiInput | SubQuesitosUpdateWithWhereUniqueWithoutSubequesitosPaiInput[]
    updateMany?: SubQuesitosUpdateManyWithWhereWithoutSubequesitosPaiInput | SubQuesitosUpdateManyWithWhereWithoutSubequesitosPaiInput[]
    deleteMany?: SubQuesitosScalarWhereInput | SubQuesitosScalarWhereInput[]
  }

  export type SubQuesitosUpdateManyWithoutSubequesitosFilhosNestedInput = {
    create?: XOR<SubQuesitosCreateWithoutSubequesitosFilhosInput, SubQuesitosUncheckedCreateWithoutSubequesitosFilhosInput> | SubQuesitosCreateWithoutSubequesitosFilhosInput[] | SubQuesitosUncheckedCreateWithoutSubequesitosFilhosInput[]
    connectOrCreate?: SubQuesitosCreateOrConnectWithoutSubequesitosFilhosInput | SubQuesitosCreateOrConnectWithoutSubequesitosFilhosInput[]
    upsert?: SubQuesitosUpsertWithWhereUniqueWithoutSubequesitosFilhosInput | SubQuesitosUpsertWithWhereUniqueWithoutSubequesitosFilhosInput[]
    set?: SubQuesitosWhereUniqueInput | SubQuesitosWhereUniqueInput[]
    disconnect?: SubQuesitosWhereUniqueInput | SubQuesitosWhereUniqueInput[]
    delete?: SubQuesitosWhereUniqueInput | SubQuesitosWhereUniqueInput[]
    connect?: SubQuesitosWhereUniqueInput | SubQuesitosWhereUniqueInput[]
    update?: SubQuesitosUpdateWithWhereUniqueWithoutSubequesitosFilhosInput | SubQuesitosUpdateWithWhereUniqueWithoutSubequesitosFilhosInput[]
    updateMany?: SubQuesitosUpdateManyWithWhereWithoutSubequesitosFilhosInput | SubQuesitosUpdateManyWithWhereWithoutSubequesitosFilhosInput[]
    deleteMany?: SubQuesitosScalarWhereInput | SubQuesitosScalarWhereInput[]
  }

  export type SubQuesitosUncheckedUpdateManyWithoutSubequesitosPaiNestedInput = {
    create?: XOR<SubQuesitosCreateWithoutSubequesitosPaiInput, SubQuesitosUncheckedCreateWithoutSubequesitosPaiInput> | SubQuesitosCreateWithoutSubequesitosPaiInput[] | SubQuesitosUncheckedCreateWithoutSubequesitosPaiInput[]
    connectOrCreate?: SubQuesitosCreateOrConnectWithoutSubequesitosPaiInput | SubQuesitosCreateOrConnectWithoutSubequesitosPaiInput[]
    upsert?: SubQuesitosUpsertWithWhereUniqueWithoutSubequesitosPaiInput | SubQuesitosUpsertWithWhereUniqueWithoutSubequesitosPaiInput[]
    set?: SubQuesitosWhereUniqueInput | SubQuesitosWhereUniqueInput[]
    disconnect?: SubQuesitosWhereUniqueInput | SubQuesitosWhereUniqueInput[]
    delete?: SubQuesitosWhereUniqueInput | SubQuesitosWhereUniqueInput[]
    connect?: SubQuesitosWhereUniqueInput | SubQuesitosWhereUniqueInput[]
    update?: SubQuesitosUpdateWithWhereUniqueWithoutSubequesitosPaiInput | SubQuesitosUpdateWithWhereUniqueWithoutSubequesitosPaiInput[]
    updateMany?: SubQuesitosUpdateManyWithWhereWithoutSubequesitosPaiInput | SubQuesitosUpdateManyWithWhereWithoutSubequesitosPaiInput[]
    deleteMany?: SubQuesitosScalarWhereInput | SubQuesitosScalarWhereInput[]
  }

  export type SubQuesitosUncheckedUpdateManyWithoutSubequesitosFilhosNestedInput = {
    create?: XOR<SubQuesitosCreateWithoutSubequesitosFilhosInput, SubQuesitosUncheckedCreateWithoutSubequesitosFilhosInput> | SubQuesitosCreateWithoutSubequesitosFilhosInput[] | SubQuesitosUncheckedCreateWithoutSubequesitosFilhosInput[]
    connectOrCreate?: SubQuesitosCreateOrConnectWithoutSubequesitosFilhosInput | SubQuesitosCreateOrConnectWithoutSubequesitosFilhosInput[]
    upsert?: SubQuesitosUpsertWithWhereUniqueWithoutSubequesitosFilhosInput | SubQuesitosUpsertWithWhereUniqueWithoutSubequesitosFilhosInput[]
    set?: SubQuesitosWhereUniqueInput | SubQuesitosWhereUniqueInput[]
    disconnect?: SubQuesitosWhereUniqueInput | SubQuesitosWhereUniqueInput[]
    delete?: SubQuesitosWhereUniqueInput | SubQuesitosWhereUniqueInput[]
    connect?: SubQuesitosWhereUniqueInput | SubQuesitosWhereUniqueInput[]
    update?: SubQuesitosUpdateWithWhereUniqueWithoutSubequesitosFilhosInput | SubQuesitosUpdateWithWhereUniqueWithoutSubequesitosFilhosInput[]
    updateMany?: SubQuesitosUpdateManyWithWhereWithoutSubequesitosFilhosInput | SubQuesitosUpdateManyWithWhereWithoutSubequesitosFilhosInput[]
    deleteMany?: SubQuesitosScalarWhereInput | SubQuesitosScalarWhereInput[]
  }

  export type CandidatoCreateNestedOneWithoutRecursoInput = {
    create?: XOR<CandidatoCreateWithoutRecursoInput, CandidatoUncheckedCreateWithoutRecursoInput>
    connectOrCreate?: CandidatoCreateOrConnectWithoutRecursoInput
    connect?: CandidatoWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutRecursosInput = {
    create?: XOR<UsuarioCreateWithoutRecursosInput, UsuarioUncheckedCreateWithoutRecursosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutRecursosInput
    connect?: UsuarioWhereUniqueInput
  }

  export type QuesitosCreateNestedOneWithoutRecursosInput = {
    create?: XOR<QuesitosCreateWithoutRecursosInput, QuesitosUncheckedCreateWithoutRecursosInput>
    connectOrCreate?: QuesitosCreateOrConnectWithoutRecursosInput
    connect?: QuesitosWhereUniqueInput
  }

  export type ProvaTeoricaCreateNestedOneWithoutRecursoInput = {
    create?: XOR<ProvaTeoricaCreateWithoutRecursoInput, ProvaTeoricaUncheckedCreateWithoutRecursoInput>
    connectOrCreate?: ProvaTeoricaCreateOrConnectWithoutRecursoInput
    connect?: ProvaTeoricaWhereUniqueInput
  }

  export type ProvaPraticaCreateNestedOneWithoutRecursoInput = {
    create?: XOR<ProvaPraticaCreateWithoutRecursoInput, ProvaPraticaUncheckedCreateWithoutRecursoInput>
    connectOrCreate?: ProvaPraticaCreateOrConnectWithoutRecursoInput
    connect?: ProvaPraticaWhereUniqueInput
  }

  export type ProvaCreateNestedOneWithoutRecursosInput = {
    create?: XOR<ProvaCreateWithoutRecursosInput, ProvaUncheckedCreateWithoutRecursosInput>
    connectOrCreate?: ProvaCreateOrConnectWithoutRecursosInput
    connect?: ProvaWhereUniqueInput
  }

  export type CandidatoUpdateOneRequiredWithoutRecursoNestedInput = {
    create?: XOR<CandidatoCreateWithoutRecursoInput, CandidatoUncheckedCreateWithoutRecursoInput>
    connectOrCreate?: CandidatoCreateOrConnectWithoutRecursoInput
    upsert?: CandidatoUpsertWithoutRecursoInput
    connect?: CandidatoWhereUniqueInput
    update?: XOR<XOR<CandidatoUpdateToOneWithWhereWithoutRecursoInput, CandidatoUpdateWithoutRecursoInput>, CandidatoUncheckedUpdateWithoutRecursoInput>
  }

  export type UsuarioUpdateOneRequiredWithoutRecursosNestedInput = {
    create?: XOR<UsuarioCreateWithoutRecursosInput, UsuarioUncheckedCreateWithoutRecursosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutRecursosInput
    upsert?: UsuarioUpsertWithoutRecursosInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutRecursosInput, UsuarioUpdateWithoutRecursosInput>, UsuarioUncheckedUpdateWithoutRecursosInput>
  }

  export type QuesitosUpdateOneRequiredWithoutRecursosNestedInput = {
    create?: XOR<QuesitosCreateWithoutRecursosInput, QuesitosUncheckedCreateWithoutRecursosInput>
    connectOrCreate?: QuesitosCreateOrConnectWithoutRecursosInput
    upsert?: QuesitosUpsertWithoutRecursosInput
    connect?: QuesitosWhereUniqueInput
    update?: XOR<XOR<QuesitosUpdateToOneWithWhereWithoutRecursosInput, QuesitosUpdateWithoutRecursosInput>, QuesitosUncheckedUpdateWithoutRecursosInput>
  }

  export type ProvaTeoricaUpdateOneWithoutRecursoNestedInput = {
    create?: XOR<ProvaTeoricaCreateWithoutRecursoInput, ProvaTeoricaUncheckedCreateWithoutRecursoInput>
    connectOrCreate?: ProvaTeoricaCreateOrConnectWithoutRecursoInput
    upsert?: ProvaTeoricaUpsertWithoutRecursoInput
    disconnect?: ProvaTeoricaWhereInput | boolean
    delete?: ProvaTeoricaWhereInput | boolean
    connect?: ProvaTeoricaWhereUniqueInput
    update?: XOR<XOR<ProvaTeoricaUpdateToOneWithWhereWithoutRecursoInput, ProvaTeoricaUpdateWithoutRecursoInput>, ProvaTeoricaUncheckedUpdateWithoutRecursoInput>
  }

  export type ProvaPraticaUpdateOneWithoutRecursoNestedInput = {
    create?: XOR<ProvaPraticaCreateWithoutRecursoInput, ProvaPraticaUncheckedCreateWithoutRecursoInput>
    connectOrCreate?: ProvaPraticaCreateOrConnectWithoutRecursoInput
    upsert?: ProvaPraticaUpsertWithoutRecursoInput
    disconnect?: ProvaPraticaWhereInput | boolean
    delete?: ProvaPraticaWhereInput | boolean
    connect?: ProvaPraticaWhereUniqueInput
    update?: XOR<XOR<ProvaPraticaUpdateToOneWithWhereWithoutRecursoInput, ProvaPraticaUpdateWithoutRecursoInput>, ProvaPraticaUncheckedUpdateWithoutRecursoInput>
  }

  export type ProvaUpdateOneWithoutRecursosNestedInput = {
    create?: XOR<ProvaCreateWithoutRecursosInput, ProvaUncheckedCreateWithoutRecursosInput>
    connectOrCreate?: ProvaCreateOrConnectWithoutRecursosInput
    upsert?: ProvaUpsertWithoutRecursosInput
    disconnect?: ProvaWhereInput | boolean
    delete?: ProvaWhereInput | boolean
    connect?: ProvaWhereUniqueInput
    update?: XOR<XOR<ProvaUpdateToOneWithWhereWithoutRecursosInput, ProvaUpdateWithoutRecursosInput>, ProvaUncheckedUpdateWithoutRecursosInput>
  }

  export type PreferenciaSorteioDancaCreateNestedManyWithoutSorteioDancaInput = {
    create?: XOR<PreferenciaSorteioDancaCreateWithoutSorteioDancaInput, PreferenciaSorteioDancaUncheckedCreateWithoutSorteioDancaInput> | PreferenciaSorteioDancaCreateWithoutSorteioDancaInput[] | PreferenciaSorteioDancaUncheckedCreateWithoutSorteioDancaInput[]
    connectOrCreate?: PreferenciaSorteioDancaCreateOrConnectWithoutSorteioDancaInput | PreferenciaSorteioDancaCreateOrConnectWithoutSorteioDancaInput[]
    createMany?: PreferenciaSorteioDancaCreateManySorteioDancaInputEnvelope
    connect?: PreferenciaSorteioDancaWhereUniqueInput | PreferenciaSorteioDancaWhereUniqueInput[]
  }

  export type CandidatoCreateNestedOneWithoutSorteioDancaInput = {
    create?: XOR<CandidatoCreateWithoutSorteioDancaInput, CandidatoUncheckedCreateWithoutSorteioDancaInput>
    connectOrCreate?: CandidatoCreateOrConnectWithoutSorteioDancaInput
    connect?: CandidatoWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutSorteioDancaInput = {
    create?: XOR<UsuarioCreateWithoutSorteioDancaInput, UsuarioUncheckedCreateWithoutSorteioDancaInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutSorteioDancaInput
    connect?: UsuarioWhereUniqueInput
  }

  export type PreferenciaSorteioDancaUncheckedCreateNestedManyWithoutSorteioDancaInput = {
    create?: XOR<PreferenciaSorteioDancaCreateWithoutSorteioDancaInput, PreferenciaSorteioDancaUncheckedCreateWithoutSorteioDancaInput> | PreferenciaSorteioDancaCreateWithoutSorteioDancaInput[] | PreferenciaSorteioDancaUncheckedCreateWithoutSorteioDancaInput[]
    connectOrCreate?: PreferenciaSorteioDancaCreateOrConnectWithoutSorteioDancaInput | PreferenciaSorteioDancaCreateOrConnectWithoutSorteioDancaInput[]
    createMany?: PreferenciaSorteioDancaCreateManySorteioDancaInputEnvelope
    connect?: PreferenciaSorteioDancaWhereUniqueInput | PreferenciaSorteioDancaWhereUniqueInput[]
  }

  export type PreferenciaSorteioDancaUpdateManyWithoutSorteioDancaNestedInput = {
    create?: XOR<PreferenciaSorteioDancaCreateWithoutSorteioDancaInput, PreferenciaSorteioDancaUncheckedCreateWithoutSorteioDancaInput> | PreferenciaSorteioDancaCreateWithoutSorteioDancaInput[] | PreferenciaSorteioDancaUncheckedCreateWithoutSorteioDancaInput[]
    connectOrCreate?: PreferenciaSorteioDancaCreateOrConnectWithoutSorteioDancaInput | PreferenciaSorteioDancaCreateOrConnectWithoutSorteioDancaInput[]
    upsert?: PreferenciaSorteioDancaUpsertWithWhereUniqueWithoutSorteioDancaInput | PreferenciaSorteioDancaUpsertWithWhereUniqueWithoutSorteioDancaInput[]
    createMany?: PreferenciaSorteioDancaCreateManySorteioDancaInputEnvelope
    set?: PreferenciaSorteioDancaWhereUniqueInput | PreferenciaSorteioDancaWhereUniqueInput[]
    disconnect?: PreferenciaSorteioDancaWhereUniqueInput | PreferenciaSorteioDancaWhereUniqueInput[]
    delete?: PreferenciaSorteioDancaWhereUniqueInput | PreferenciaSorteioDancaWhereUniqueInput[]
    connect?: PreferenciaSorteioDancaWhereUniqueInput | PreferenciaSorteioDancaWhereUniqueInput[]
    update?: PreferenciaSorteioDancaUpdateWithWhereUniqueWithoutSorteioDancaInput | PreferenciaSorteioDancaUpdateWithWhereUniqueWithoutSorteioDancaInput[]
    updateMany?: PreferenciaSorteioDancaUpdateManyWithWhereWithoutSorteioDancaInput | PreferenciaSorteioDancaUpdateManyWithWhereWithoutSorteioDancaInput[]
    deleteMany?: PreferenciaSorteioDancaScalarWhereInput | PreferenciaSorteioDancaScalarWhereInput[]
  }

  export type CandidatoUpdateOneRequiredWithoutSorteioDancaNestedInput = {
    create?: XOR<CandidatoCreateWithoutSorteioDancaInput, CandidatoUncheckedCreateWithoutSorteioDancaInput>
    connectOrCreate?: CandidatoCreateOrConnectWithoutSorteioDancaInput
    upsert?: CandidatoUpsertWithoutSorteioDancaInput
    connect?: CandidatoWhereUniqueInput
    update?: XOR<XOR<CandidatoUpdateToOneWithWhereWithoutSorteioDancaInput, CandidatoUpdateWithoutSorteioDancaInput>, CandidatoUncheckedUpdateWithoutSorteioDancaInput>
  }

  export type UsuarioUpdateOneRequiredWithoutSorteioDancaNestedInput = {
    create?: XOR<UsuarioCreateWithoutSorteioDancaInput, UsuarioUncheckedCreateWithoutSorteioDancaInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutSorteioDancaInput
    upsert?: UsuarioUpsertWithoutSorteioDancaInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutSorteioDancaInput, UsuarioUpdateWithoutSorteioDancaInput>, UsuarioUncheckedUpdateWithoutSorteioDancaInput>
  }

  export type PreferenciaSorteioDancaUncheckedUpdateManyWithoutSorteioDancaNestedInput = {
    create?: XOR<PreferenciaSorteioDancaCreateWithoutSorteioDancaInput, PreferenciaSorteioDancaUncheckedCreateWithoutSorteioDancaInput> | PreferenciaSorteioDancaCreateWithoutSorteioDancaInput[] | PreferenciaSorteioDancaUncheckedCreateWithoutSorteioDancaInput[]
    connectOrCreate?: PreferenciaSorteioDancaCreateOrConnectWithoutSorteioDancaInput | PreferenciaSorteioDancaCreateOrConnectWithoutSorteioDancaInput[]
    upsert?: PreferenciaSorteioDancaUpsertWithWhereUniqueWithoutSorteioDancaInput | PreferenciaSorteioDancaUpsertWithWhereUniqueWithoutSorteioDancaInput[]
    createMany?: PreferenciaSorteioDancaCreateManySorteioDancaInputEnvelope
    set?: PreferenciaSorteioDancaWhereUniqueInput | PreferenciaSorteioDancaWhereUniqueInput[]
    disconnect?: PreferenciaSorteioDancaWhereUniqueInput | PreferenciaSorteioDancaWhereUniqueInput[]
    delete?: PreferenciaSorteioDancaWhereUniqueInput | PreferenciaSorteioDancaWhereUniqueInput[]
    connect?: PreferenciaSorteioDancaWhereUniqueInput | PreferenciaSorteioDancaWhereUniqueInput[]
    update?: PreferenciaSorteioDancaUpdateWithWhereUniqueWithoutSorteioDancaInput | PreferenciaSorteioDancaUpdateWithWhereUniqueWithoutSorteioDancaInput[]
    updateMany?: PreferenciaSorteioDancaUpdateManyWithWhereWithoutSorteioDancaInput | PreferenciaSorteioDancaUpdateManyWithWhereWithoutSorteioDancaInput[]
    deleteMany?: PreferenciaSorteioDancaScalarWhereInput | PreferenciaSorteioDancaScalarWhereInput[]
  }

  export type AvaliacaoCreateNestedManyWithoutFichaCandidatoInput = {
    create?: XOR<AvaliacaoCreateWithoutFichaCandidatoInput, AvaliacaoUncheckedCreateWithoutFichaCandidatoInput> | AvaliacaoCreateWithoutFichaCandidatoInput[] | AvaliacaoUncheckedCreateWithoutFichaCandidatoInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutFichaCandidatoInput | AvaliacaoCreateOrConnectWithoutFichaCandidatoInput[]
    createMany?: AvaliacaoCreateManyFichaCandidatoInputEnvelope
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
  }

  export type AvaliacaoUncheckedCreateNestedManyWithoutFichaCandidatoInput = {
    create?: XOR<AvaliacaoCreateWithoutFichaCandidatoInput, AvaliacaoUncheckedCreateWithoutFichaCandidatoInput> | AvaliacaoCreateWithoutFichaCandidatoInput[] | AvaliacaoUncheckedCreateWithoutFichaCandidatoInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutFichaCandidatoInput | AvaliacaoCreateOrConnectWithoutFichaCandidatoInput[]
    createMany?: AvaliacaoCreateManyFichaCandidatoInputEnvelope
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
  }

  export type AvaliacaoUpdateManyWithoutFichaCandidatoNestedInput = {
    create?: XOR<AvaliacaoCreateWithoutFichaCandidatoInput, AvaliacaoUncheckedCreateWithoutFichaCandidatoInput> | AvaliacaoCreateWithoutFichaCandidatoInput[] | AvaliacaoUncheckedCreateWithoutFichaCandidatoInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutFichaCandidatoInput | AvaliacaoCreateOrConnectWithoutFichaCandidatoInput[]
    upsert?: AvaliacaoUpsertWithWhereUniqueWithoutFichaCandidatoInput | AvaliacaoUpsertWithWhereUniqueWithoutFichaCandidatoInput[]
    createMany?: AvaliacaoCreateManyFichaCandidatoInputEnvelope
    set?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    disconnect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    delete?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    update?: AvaliacaoUpdateWithWhereUniqueWithoutFichaCandidatoInput | AvaliacaoUpdateWithWhereUniqueWithoutFichaCandidatoInput[]
    updateMany?: AvaliacaoUpdateManyWithWhereWithoutFichaCandidatoInput | AvaliacaoUpdateManyWithWhereWithoutFichaCandidatoInput[]
    deleteMany?: AvaliacaoScalarWhereInput | AvaliacaoScalarWhereInput[]
  }

  export type AvaliacaoUncheckedUpdateManyWithoutFichaCandidatoNestedInput = {
    create?: XOR<AvaliacaoCreateWithoutFichaCandidatoInput, AvaliacaoUncheckedCreateWithoutFichaCandidatoInput> | AvaliacaoCreateWithoutFichaCandidatoInput[] | AvaliacaoUncheckedCreateWithoutFichaCandidatoInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutFichaCandidatoInput | AvaliacaoCreateOrConnectWithoutFichaCandidatoInput[]
    upsert?: AvaliacaoUpsertWithWhereUniqueWithoutFichaCandidatoInput | AvaliacaoUpsertWithWhereUniqueWithoutFichaCandidatoInput[]
    createMany?: AvaliacaoCreateManyFichaCandidatoInputEnvelope
    set?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    disconnect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    delete?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    update?: AvaliacaoUpdateWithWhereUniqueWithoutFichaCandidatoInput | AvaliacaoUpdateWithWhereUniqueWithoutFichaCandidatoInput[]
    updateMany?: AvaliacaoUpdateManyWithWhereWithoutFichaCandidatoInput | AvaliacaoUpdateManyWithWhereWithoutFichaCandidatoInput[]
    deleteMany?: AvaliacaoScalarWhereInput | AvaliacaoScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumProvaCampeiraEsportivaNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ProvaCampeiraEsportiva | EnumProvaCampeiraEsportivaFieldRefInput<$PrismaModel> | null
    in?: $Enums.ProvaCampeiraEsportiva[] | ListEnumProvaCampeiraEsportivaFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ProvaCampeiraEsportiva[] | ListEnumProvaCampeiraEsportivaFieldRefInput<$PrismaModel> | null
    not?: NestedEnumProvaCampeiraEsportivaNullableFilter<$PrismaModel> | $Enums.ProvaCampeiraEsportiva | null
  }

  export type NestedBytesNullableFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel> | null
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Bytes | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumProvaCampeiraEsportivaNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProvaCampeiraEsportiva | EnumProvaCampeiraEsportivaFieldRefInput<$PrismaModel> | null
    in?: $Enums.ProvaCampeiraEsportiva[] | ListEnumProvaCampeiraEsportivaFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ProvaCampeiraEsportiva[] | ListEnumProvaCampeiraEsportivaFieldRefInput<$PrismaModel> | null
    not?: NestedEnumProvaCampeiraEsportivaNullableWithAggregatesFilter<$PrismaModel> | $Enums.ProvaCampeiraEsportiva | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumProvaCampeiraEsportivaNullableFilter<$PrismaModel>
    _max?: NestedEnumProvaCampeiraEsportivaNullableFilter<$PrismaModel>
  }

  export type NestedBytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel> | null
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Bytes | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumFuncaoFilter<$PrismaModel = never> = {
    equals?: $Enums.Funcao | EnumFuncaoFieldRefInput<$PrismaModel>
    in?: $Enums.Funcao[] | ListEnumFuncaoFieldRefInput<$PrismaModel>
    notIn?: $Enums.Funcao[] | ListEnumFuncaoFieldRefInput<$PrismaModel>
    not?: NestedEnumFuncaoFilter<$PrismaModel> | $Enums.Funcao
  }

  export type NestedEnumCredenciamentoFilter<$PrismaModel = never> = {
    equals?: $Enums.Credenciamento | EnumCredenciamentoFieldRefInput<$PrismaModel>
    in?: $Enums.Credenciamento[] | ListEnumCredenciamentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.Credenciamento[] | ListEnumCredenciamentoFieldRefInput<$PrismaModel>
    not?: NestedEnumCredenciamentoFilter<$PrismaModel> | $Enums.Credenciamento
  }

  export type NestedEnumFuncaoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Funcao | EnumFuncaoFieldRefInput<$PrismaModel>
    in?: $Enums.Funcao[] | ListEnumFuncaoFieldRefInput<$PrismaModel>
    notIn?: $Enums.Funcao[] | ListEnumFuncaoFieldRefInput<$PrismaModel>
    not?: NestedEnumFuncaoWithAggregatesFilter<$PrismaModel> | $Enums.Funcao
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFuncaoFilter<$PrismaModel>
    _max?: NestedEnumFuncaoFilter<$PrismaModel>
  }

  export type NestedEnumCredenciamentoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Credenciamento | EnumCredenciamentoFieldRefInput<$PrismaModel>
    in?: $Enums.Credenciamento[] | ListEnumCredenciamentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.Credenciamento[] | ListEnumCredenciamentoFieldRefInput<$PrismaModel>
    not?: NestedEnumCredenciamentoWithAggregatesFilter<$PrismaModel> | $Enums.Credenciamento
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCredenciamentoFilter<$PrismaModel>
    _max?: NestedEnumCredenciamentoFilter<$PrismaModel>
  }

  export type NestedEnumDancaSalaoTradicionalFilter<$PrismaModel = never> = {
    equals?: $Enums.DancaSalaoTradicional | EnumDancaSalaoTradicionalFieldRefInput<$PrismaModel>
    in?: $Enums.DancaSalaoTradicional[] | ListEnumDancaSalaoTradicionalFieldRefInput<$PrismaModel>
    notIn?: $Enums.DancaSalaoTradicional[] | ListEnumDancaSalaoTradicionalFieldRefInput<$PrismaModel>
    not?: NestedEnumDancaSalaoTradicionalFilter<$PrismaModel> | $Enums.DancaSalaoTradicional
  }

  export type NestedEnumDancaSalaoTradicionalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DancaSalaoTradicional | EnumDancaSalaoTradicionalFieldRefInput<$PrismaModel>
    in?: $Enums.DancaSalaoTradicional[] | ListEnumDancaSalaoTradicionalFieldRefInput<$PrismaModel>
    notIn?: $Enums.DancaSalaoTradicional[] | ListEnumDancaSalaoTradicionalFieldRefInput<$PrismaModel>
    not?: NestedEnumDancaSalaoTradicionalWithAggregatesFilter<$PrismaModel> | $Enums.DancaSalaoTradicional
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDancaSalaoTradicionalFilter<$PrismaModel>
    _max?: NestedEnumDancaSalaoTradicionalFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBytesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel>
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Bytes
  }

  export type NestedBytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel>
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Bytes
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type CTGCreateWithoutCandidatoInput = {
    nomeCTG: string
    RT: RTCreateNestedOneWithoutCTGsInput
    Usuario?: UsuarioCreateNestedManyWithoutCTGInput
  }

  export type CTGUncheckedCreateWithoutCandidatoInput = {
    idCTG?: number
    nomeCTG: string
    RTid: number
    Usuario?: UsuarioUncheckedCreateNestedManyWithoutCTGInput
  }

  export type CTGCreateOrConnectWithoutCandidatoInput = {
    where: CTGWhereUniqueInput
    create: XOR<CTGCreateWithoutCandidatoInput, CTGUncheckedCreateWithoutCandidatoInput>
  }

  export type PreferenciaSorteioDancaCreateWithoutCandidatoInput = {
    nomeSorteioDanca: $Enums.DancaSalaoTradicional
    SorteioDanca?: SorteioDancaCreateNestedOneWithoutPreferenciaSorteioDancaIdsInput
    quesitos?: QuesitosCreateNestedManyWithoutPreferenciaSorteioDancaInput
  }

  export type PreferenciaSorteioDancaUncheckedCreateWithoutCandidatoInput = {
    idPreferencia?: number
    nomeSorteioDanca: $Enums.DancaSalaoTradicional
    sorteioDancaId?: number | null
    quesitos?: QuesitosUncheckedCreateNestedManyWithoutPreferenciaSorteioDancaInput
  }

  export type PreferenciaSorteioDancaCreateOrConnectWithoutCandidatoInput = {
    where: PreferenciaSorteioDancaWhereUniqueInput
    create: XOR<PreferenciaSorteioDancaCreateWithoutCandidatoInput, PreferenciaSorteioDancaUncheckedCreateWithoutCandidatoInput>
  }

  export type PreferenciaSorteioDancaCreateManyCandidatoInputEnvelope = {
    data: PreferenciaSorteioDancaCreateManyCandidatoInput | PreferenciaSorteioDancaCreateManyCandidatoInput[]
    skipDuplicates?: boolean
  }

  export type CategoriaCreateWithoutCandidatosInput = {
    nomeCategoria: string
    escolaridade: string
    sorteioDanca: number
    idadeInicial: number
    idadeLimite?: number | null
    Prova?: ProvaCreateNestedOneWithoutCategoriasInput
    ProvaTeorica?: ProvaTeoricaCreateNestedOneWithoutCategoriaInput
    ProvaPratica?: ProvaPraticaCreateNestedOneWithoutCategoriaInput
  }

  export type CategoriaUncheckedCreateWithoutCandidatosInput = {
    idCategoria?: number
    nomeCategoria: string
    escolaridade: string
    sorteioDanca: number
    idadeInicial: number
    idadeLimite?: number | null
    provaId?: number | null
    provaTeoricaId?: number | null
    provaPraticaId?: number | null
  }

  export type CategoriaCreateOrConnectWithoutCandidatosInput = {
    where: CategoriaWhereUniqueInput
    create: XOR<CategoriaCreateWithoutCandidatosInput, CategoriaUncheckedCreateWithoutCandidatosInput>
  }

  export type AvaliacaoCreateWithoutCandidatoInput = {
    dataAvaliacao?: Date | string
    nota: number
    Comissao: ComissaoCreateNestedOneWithoutAvalicaoInput
    Usuario: UsuarioCreateNestedOneWithoutAvalicoesInput
    Prova?: ProvaCreateNestedOneWithoutAvaliacaoInput
    BlocoProva?: BlocoProvaCreateNestedOneWithoutAvaliacaoInput
    quesitos?: QuesitosCreateNestedManyWithoutAvaliacaoInput
    FichaCandidato?: FichaCandidatoCreateNestedOneWithoutAvaliacoesInput
  }

  export type AvaliacaoUncheckedCreateWithoutCandidatoInput = {
    idAvalicao?: number
    dataAvaliacao?: Date | string
    comissaoId: number
    avaliadorId: number
    provaId: number
    blocoProvaId?: number | null
    nota: number
    fichaCandidatoIdFicha?: number | null
    quesitos?: QuesitosUncheckedCreateNestedManyWithoutAvaliacaoInput
  }

  export type AvaliacaoCreateOrConnectWithoutCandidatoInput = {
    where: AvaliacaoWhereUniqueInput
    create: XOR<AvaliacaoCreateWithoutCandidatoInput, AvaliacaoUncheckedCreateWithoutCandidatoInput>
  }

  export type AvaliacaoCreateManyCandidatoInputEnvelope = {
    data: AvaliacaoCreateManyCandidatoInput | AvaliacaoCreateManyCandidatoInput[]
    skipDuplicates?: boolean
  }

  export type SorteioDancaCreateWithoutCandidatoInput = {
    resultadoSorteio: number
    dataSorteio?: Date | string
    tipoDanca: $Enums.DancaSalaoTradicional
    preferenciaSorteioDancaIds?: PreferenciaSorteioDancaCreateNestedManyWithoutSorteioDancaInput
    Usuario: UsuarioCreateNestedOneWithoutSorteioDancaInput
  }

  export type SorteioDancaUncheckedCreateWithoutCandidatoInput = {
    idSorteio?: number
    resultadoSorteio: number
    dataSorteio?: Date | string
    tipoDanca: $Enums.DancaSalaoTradicional
    usuarioId: number
    preferenciaSorteioDancaIds?: PreferenciaSorteioDancaUncheckedCreateNestedManyWithoutSorteioDancaInput
  }

  export type SorteioDancaCreateOrConnectWithoutCandidatoInput = {
    where: SorteioDancaWhereUniqueInput
    create: XOR<SorteioDancaCreateWithoutCandidatoInput, SorteioDancaUncheckedCreateWithoutCandidatoInput>
  }

  export type SorteioDancaCreateManyCandidatoInputEnvelope = {
    data: SorteioDancaCreateManyCandidatoInput | SorteioDancaCreateManyCandidatoInput[]
    skipDuplicates?: boolean
  }

  export type RecursoCreateWithoutCandidatoInput = {
    nomeRecurso: string
    justificativa: string
    status: boolean
    dataRecurso?: Date | string
    arquivos: Bytes
    Usuario: UsuarioCreateNestedOneWithoutRecursosInput
    Quesito: QuesitosCreateNestedOneWithoutRecursosInput
    ProvaTeorica?: ProvaTeoricaCreateNestedOneWithoutRecursoInput
    ProvaPratica?: ProvaPraticaCreateNestedOneWithoutRecursoInput
    Prova?: ProvaCreateNestedOneWithoutRecursosInput
  }

  export type RecursoUncheckedCreateWithoutCandidatoInput = {
    idRecurso?: number
    nomeRecurso: string
    justificativa: string
    status: boolean
    dataRecurso?: Date | string
    arquivos: Bytes
    avaliador: number
    quesitoRecurso: number
    provaTeoricaIdprovaTeorica?: number | null
    provaPraticaIdProvaPratica?: number | null
    provaIdProva?: number | null
  }

  export type RecursoCreateOrConnectWithoutCandidatoInput = {
    where: RecursoWhereUniqueInput
    create: XOR<RecursoCreateWithoutCandidatoInput, RecursoUncheckedCreateWithoutCandidatoInput>
  }

  export type RecursoCreateManyCandidatoInputEnvelope = {
    data: RecursoCreateManyCandidatoInput | RecursoCreateManyCandidatoInput[]
    skipDuplicates?: boolean
  }

  export type ConcursoCreateWithoutCandidatosInput = {
    nomeConcurso: string
    lancamentoEdital: Date | string
    inscricoesInicio: Date | string
    inscricoesFinal: Date | string
    dataProvaEscrita: Date | string
    dataProvasPraticas: Date | string
    dataResultado: Date | string
    local: string
    anexoEdital?: Bytes | null
    comissoes?: ComissaoCreateNestedManyWithoutConcursoInput
  }

  export type ConcursoUncheckedCreateWithoutCandidatosInput = {
    idConcurso?: number
    nomeConcurso: string
    lancamentoEdital: Date | string
    inscricoesInicio: Date | string
    inscricoesFinal: Date | string
    dataProvaEscrita: Date | string
    dataProvasPraticas: Date | string
    dataResultado: Date | string
    local: string
    anexoEdital?: Bytes | null
    comissoes?: ComissaoUncheckedCreateNestedManyWithoutConcursoInput
  }

  export type ConcursoCreateOrConnectWithoutCandidatosInput = {
    where: ConcursoWhereUniqueInput
    create: XOR<ConcursoCreateWithoutCandidatosInput, ConcursoUncheckedCreateWithoutCandidatosInput>
  }

  export type CTGUpsertWithoutCandidatoInput = {
    update: XOR<CTGUpdateWithoutCandidatoInput, CTGUncheckedUpdateWithoutCandidatoInput>
    create: XOR<CTGCreateWithoutCandidatoInput, CTGUncheckedCreateWithoutCandidatoInput>
    where?: CTGWhereInput
  }

  export type CTGUpdateToOneWithWhereWithoutCandidatoInput = {
    where?: CTGWhereInput
    data: XOR<CTGUpdateWithoutCandidatoInput, CTGUncheckedUpdateWithoutCandidatoInput>
  }

  export type CTGUpdateWithoutCandidatoInput = {
    nomeCTG?: StringFieldUpdateOperationsInput | string
    RT?: RTUpdateOneRequiredWithoutCTGsNestedInput
    Usuario?: UsuarioUpdateManyWithoutCTGNestedInput
  }

  export type CTGUncheckedUpdateWithoutCandidatoInput = {
    idCTG?: IntFieldUpdateOperationsInput | number
    nomeCTG?: StringFieldUpdateOperationsInput | string
    RTid?: IntFieldUpdateOperationsInput | number
    Usuario?: UsuarioUncheckedUpdateManyWithoutCTGNestedInput
  }

  export type PreferenciaSorteioDancaUpsertWithWhereUniqueWithoutCandidatoInput = {
    where: PreferenciaSorteioDancaWhereUniqueInput
    update: XOR<PreferenciaSorteioDancaUpdateWithoutCandidatoInput, PreferenciaSorteioDancaUncheckedUpdateWithoutCandidatoInput>
    create: XOR<PreferenciaSorteioDancaCreateWithoutCandidatoInput, PreferenciaSorteioDancaUncheckedCreateWithoutCandidatoInput>
  }

  export type PreferenciaSorteioDancaUpdateWithWhereUniqueWithoutCandidatoInput = {
    where: PreferenciaSorteioDancaWhereUniqueInput
    data: XOR<PreferenciaSorteioDancaUpdateWithoutCandidatoInput, PreferenciaSorteioDancaUncheckedUpdateWithoutCandidatoInput>
  }

  export type PreferenciaSorteioDancaUpdateManyWithWhereWithoutCandidatoInput = {
    where: PreferenciaSorteioDancaScalarWhereInput
    data: XOR<PreferenciaSorteioDancaUpdateManyMutationInput, PreferenciaSorteioDancaUncheckedUpdateManyWithoutCandidatoInput>
  }

  export type PreferenciaSorteioDancaScalarWhereInput = {
    AND?: PreferenciaSorteioDancaScalarWhereInput | PreferenciaSorteioDancaScalarWhereInput[]
    OR?: PreferenciaSorteioDancaScalarWhereInput[]
    NOT?: PreferenciaSorteioDancaScalarWhereInput | PreferenciaSorteioDancaScalarWhereInput[]
    idPreferencia?: IntFilter<"PreferenciaSorteioDanca"> | number
    nomeSorteioDanca?: EnumDancaSalaoTradicionalFilter<"PreferenciaSorteioDanca"> | $Enums.DancaSalaoTradicional
    candidatoId?: IntFilter<"PreferenciaSorteioDanca"> | number
    sorteioDancaId?: IntNullableFilter<"PreferenciaSorteioDanca"> | number | null
  }

  export type CategoriaUpsertWithoutCandidatosInput = {
    update: XOR<CategoriaUpdateWithoutCandidatosInput, CategoriaUncheckedUpdateWithoutCandidatosInput>
    create: XOR<CategoriaCreateWithoutCandidatosInput, CategoriaUncheckedCreateWithoutCandidatosInput>
    where?: CategoriaWhereInput
  }

  export type CategoriaUpdateToOneWithWhereWithoutCandidatosInput = {
    where?: CategoriaWhereInput
    data: XOR<CategoriaUpdateWithoutCandidatosInput, CategoriaUncheckedUpdateWithoutCandidatosInput>
  }

  export type CategoriaUpdateWithoutCandidatosInput = {
    nomeCategoria?: StringFieldUpdateOperationsInput | string
    escolaridade?: StringFieldUpdateOperationsInput | string
    sorteioDanca?: IntFieldUpdateOperationsInput | number
    idadeInicial?: IntFieldUpdateOperationsInput | number
    idadeLimite?: NullableIntFieldUpdateOperationsInput | number | null
    Prova?: ProvaUpdateOneWithoutCategoriasNestedInput
    ProvaTeorica?: ProvaTeoricaUpdateOneWithoutCategoriaNestedInput
    ProvaPratica?: ProvaPraticaUpdateOneWithoutCategoriaNestedInput
  }

  export type CategoriaUncheckedUpdateWithoutCandidatosInput = {
    idCategoria?: IntFieldUpdateOperationsInput | number
    nomeCategoria?: StringFieldUpdateOperationsInput | string
    escolaridade?: StringFieldUpdateOperationsInput | string
    sorteioDanca?: IntFieldUpdateOperationsInput | number
    idadeInicial?: IntFieldUpdateOperationsInput | number
    idadeLimite?: NullableIntFieldUpdateOperationsInput | number | null
    provaId?: NullableIntFieldUpdateOperationsInput | number | null
    provaTeoricaId?: NullableIntFieldUpdateOperationsInput | number | null
    provaPraticaId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AvaliacaoUpsertWithWhereUniqueWithoutCandidatoInput = {
    where: AvaliacaoWhereUniqueInput
    update: XOR<AvaliacaoUpdateWithoutCandidatoInput, AvaliacaoUncheckedUpdateWithoutCandidatoInput>
    create: XOR<AvaliacaoCreateWithoutCandidatoInput, AvaliacaoUncheckedCreateWithoutCandidatoInput>
  }

  export type AvaliacaoUpdateWithWhereUniqueWithoutCandidatoInput = {
    where: AvaliacaoWhereUniqueInput
    data: XOR<AvaliacaoUpdateWithoutCandidatoInput, AvaliacaoUncheckedUpdateWithoutCandidatoInput>
  }

  export type AvaliacaoUpdateManyWithWhereWithoutCandidatoInput = {
    where: AvaliacaoScalarWhereInput
    data: XOR<AvaliacaoUpdateManyMutationInput, AvaliacaoUncheckedUpdateManyWithoutCandidatoInput>
  }

  export type AvaliacaoScalarWhereInput = {
    AND?: AvaliacaoScalarWhereInput | AvaliacaoScalarWhereInput[]
    OR?: AvaliacaoScalarWhereInput[]
    NOT?: AvaliacaoScalarWhereInput | AvaliacaoScalarWhereInput[]
    idAvalicao?: IntFilter<"Avaliacao"> | number
    dataAvaliacao?: DateTimeFilter<"Avaliacao"> | Date | string
    comissaoId?: IntFilter<"Avaliacao"> | number
    avaliadorId?: IntFilter<"Avaliacao"> | number
    provaId?: IntFilter<"Avaliacao"> | number
    blocoProvaId?: IntNullableFilter<"Avaliacao"> | number | null
    nota?: FloatFilter<"Avaliacao"> | number
    candidatoId?: IntFilter<"Avaliacao"> | number
    fichaCandidatoIdFicha?: IntNullableFilter<"Avaliacao"> | number | null
  }

  export type SorteioDancaUpsertWithWhereUniqueWithoutCandidatoInput = {
    where: SorteioDancaWhereUniqueInput
    update: XOR<SorteioDancaUpdateWithoutCandidatoInput, SorteioDancaUncheckedUpdateWithoutCandidatoInput>
    create: XOR<SorteioDancaCreateWithoutCandidatoInput, SorteioDancaUncheckedCreateWithoutCandidatoInput>
  }

  export type SorteioDancaUpdateWithWhereUniqueWithoutCandidatoInput = {
    where: SorteioDancaWhereUniqueInput
    data: XOR<SorteioDancaUpdateWithoutCandidatoInput, SorteioDancaUncheckedUpdateWithoutCandidatoInput>
  }

  export type SorteioDancaUpdateManyWithWhereWithoutCandidatoInput = {
    where: SorteioDancaScalarWhereInput
    data: XOR<SorteioDancaUpdateManyMutationInput, SorteioDancaUncheckedUpdateManyWithoutCandidatoInput>
  }

  export type SorteioDancaScalarWhereInput = {
    AND?: SorteioDancaScalarWhereInput | SorteioDancaScalarWhereInput[]
    OR?: SorteioDancaScalarWhereInput[]
    NOT?: SorteioDancaScalarWhereInput | SorteioDancaScalarWhereInput[]
    idSorteio?: IntFilter<"SorteioDanca"> | number
    resultadoSorteio?: IntFilter<"SorteioDanca"> | number
    dataSorteio?: DateTimeFilter<"SorteioDanca"> | Date | string
    tipoDanca?: EnumDancaSalaoTradicionalFilter<"SorteioDanca"> | $Enums.DancaSalaoTradicional
    candidatoId?: IntFilter<"SorteioDanca"> | number
    usuarioId?: IntFilter<"SorteioDanca"> | number
  }

  export type RecursoUpsertWithWhereUniqueWithoutCandidatoInput = {
    where: RecursoWhereUniqueInput
    update: XOR<RecursoUpdateWithoutCandidatoInput, RecursoUncheckedUpdateWithoutCandidatoInput>
    create: XOR<RecursoCreateWithoutCandidatoInput, RecursoUncheckedCreateWithoutCandidatoInput>
  }

  export type RecursoUpdateWithWhereUniqueWithoutCandidatoInput = {
    where: RecursoWhereUniqueInput
    data: XOR<RecursoUpdateWithoutCandidatoInput, RecursoUncheckedUpdateWithoutCandidatoInput>
  }

  export type RecursoUpdateManyWithWhereWithoutCandidatoInput = {
    where: RecursoScalarWhereInput
    data: XOR<RecursoUpdateManyMutationInput, RecursoUncheckedUpdateManyWithoutCandidatoInput>
  }

  export type RecursoScalarWhereInput = {
    AND?: RecursoScalarWhereInput | RecursoScalarWhereInput[]
    OR?: RecursoScalarWhereInput[]
    NOT?: RecursoScalarWhereInput | RecursoScalarWhereInput[]
    idRecurso?: IntFilter<"Recurso"> | number
    nomeRecurso?: StringFilter<"Recurso"> | string
    justificativa?: StringFilter<"Recurso"> | string
    status?: BoolFilter<"Recurso"> | boolean
    dataRecurso?: DateTimeFilter<"Recurso"> | Date | string
    arquivos?: BytesFilter<"Recurso"> | Bytes
    candidato?: IntFilter<"Recurso"> | number
    avaliador?: IntFilter<"Recurso"> | number
    quesitoRecurso?: IntFilter<"Recurso"> | number
    provaTeoricaIdprovaTeorica?: IntNullableFilter<"Recurso"> | number | null
    provaPraticaIdProvaPratica?: IntNullableFilter<"Recurso"> | number | null
    provaIdProva?: IntNullableFilter<"Recurso"> | number | null
  }

  export type ConcursoUpsertWithoutCandidatosInput = {
    update: XOR<ConcursoUpdateWithoutCandidatosInput, ConcursoUncheckedUpdateWithoutCandidatosInput>
    create: XOR<ConcursoCreateWithoutCandidatosInput, ConcursoUncheckedCreateWithoutCandidatosInput>
    where?: ConcursoWhereInput
  }

  export type ConcursoUpdateToOneWithWhereWithoutCandidatosInput = {
    where?: ConcursoWhereInput
    data: XOR<ConcursoUpdateWithoutCandidatosInput, ConcursoUncheckedUpdateWithoutCandidatosInput>
  }

  export type ConcursoUpdateWithoutCandidatosInput = {
    nomeConcurso?: StringFieldUpdateOperationsInput | string
    lancamentoEdital?: DateTimeFieldUpdateOperationsInput | Date | string
    inscricoesInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    inscricoesFinal?: DateTimeFieldUpdateOperationsInput | Date | string
    dataProvaEscrita?: DateTimeFieldUpdateOperationsInput | Date | string
    dataProvasPraticas?: DateTimeFieldUpdateOperationsInput | Date | string
    dataResultado?: DateTimeFieldUpdateOperationsInput | Date | string
    local?: StringFieldUpdateOperationsInput | string
    anexoEdital?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    comissoes?: ComissaoUpdateManyWithoutConcursoNestedInput
  }

  export type ConcursoUncheckedUpdateWithoutCandidatosInput = {
    idConcurso?: IntFieldUpdateOperationsInput | number
    nomeConcurso?: StringFieldUpdateOperationsInput | string
    lancamentoEdital?: DateTimeFieldUpdateOperationsInput | Date | string
    inscricoesInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    inscricoesFinal?: DateTimeFieldUpdateOperationsInput | Date | string
    dataProvaEscrita?: DateTimeFieldUpdateOperationsInput | Date | string
    dataProvasPraticas?: DateTimeFieldUpdateOperationsInput | Date | string
    dataResultado?: DateTimeFieldUpdateOperationsInput | Date | string
    local?: StringFieldUpdateOperationsInput | string
    anexoEdital?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    comissoes?: ComissaoUncheckedUpdateManyWithoutConcursoNestedInput
  }

  export type CTGCreateWithoutUsuarioInput = {
    nomeCTG: string
    RT: RTCreateNestedOneWithoutCTGsInput
    Candidato?: CandidatoCreateNestedManyWithoutCTGInput
  }

  export type CTGUncheckedCreateWithoutUsuarioInput = {
    idCTG?: number
    nomeCTG: string
    RTid: number
    Candidato?: CandidatoUncheckedCreateNestedManyWithoutCTGInput
  }

  export type CTGCreateOrConnectWithoutUsuarioInput = {
    where: CTGWhereUniqueInput
    create: XOR<CTGCreateWithoutUsuarioInput, CTGUncheckedCreateWithoutUsuarioInput>
  }

  export type ComissaoUsuarioCreateWithoutUsuariosInput = {
    Comissao: ComissaoCreateNestedOneWithoutUsuariosInput
  }

  export type ComissaoUsuarioUncheckedCreateWithoutUsuariosInput = {
    idComissaoUsuario?: number
    comissaoId: number
  }

  export type ComissaoUsuarioCreateOrConnectWithoutUsuariosInput = {
    where: ComissaoUsuarioWhereUniqueInput
    create: XOR<ComissaoUsuarioCreateWithoutUsuariosInput, ComissaoUsuarioUncheckedCreateWithoutUsuariosInput>
  }

  export type AvaliacaoCreateWithoutUsuarioInput = {
    dataAvaliacao?: Date | string
    nota: number
    Comissao: ComissaoCreateNestedOneWithoutAvalicaoInput
    Prova?: ProvaCreateNestedOneWithoutAvaliacaoInput
    BlocoProva?: BlocoProvaCreateNestedOneWithoutAvaliacaoInput
    quesitos?: QuesitosCreateNestedManyWithoutAvaliacaoInput
    Candidato: CandidatoCreateNestedOneWithoutAvalicoesInput
    FichaCandidato?: FichaCandidatoCreateNestedOneWithoutAvaliacoesInput
  }

  export type AvaliacaoUncheckedCreateWithoutUsuarioInput = {
    idAvalicao?: number
    dataAvaliacao?: Date | string
    comissaoId: number
    provaId: number
    blocoProvaId?: number | null
    nota: number
    candidatoId: number
    fichaCandidatoIdFicha?: number | null
    quesitos?: QuesitosUncheckedCreateNestedManyWithoutAvaliacaoInput
  }

  export type AvaliacaoCreateOrConnectWithoutUsuarioInput = {
    where: AvaliacaoWhereUniqueInput
    create: XOR<AvaliacaoCreateWithoutUsuarioInput, AvaliacaoUncheckedCreateWithoutUsuarioInput>
  }

  export type AvaliacaoCreateManyUsuarioInputEnvelope = {
    data: AvaliacaoCreateManyUsuarioInput | AvaliacaoCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type RecursoCreateWithoutUsuarioInput = {
    nomeRecurso: string
    justificativa: string
    status: boolean
    dataRecurso?: Date | string
    arquivos: Bytes
    Candidato: CandidatoCreateNestedOneWithoutRecursoInput
    Quesito: QuesitosCreateNestedOneWithoutRecursosInput
    ProvaTeorica?: ProvaTeoricaCreateNestedOneWithoutRecursoInput
    ProvaPratica?: ProvaPraticaCreateNestedOneWithoutRecursoInput
    Prova?: ProvaCreateNestedOneWithoutRecursosInput
  }

  export type RecursoUncheckedCreateWithoutUsuarioInput = {
    idRecurso?: number
    nomeRecurso: string
    justificativa: string
    status: boolean
    dataRecurso?: Date | string
    arquivos: Bytes
    candidato: number
    quesitoRecurso: number
    provaTeoricaIdprovaTeorica?: number | null
    provaPraticaIdProvaPratica?: number | null
    provaIdProva?: number | null
  }

  export type RecursoCreateOrConnectWithoutUsuarioInput = {
    where: RecursoWhereUniqueInput
    create: XOR<RecursoCreateWithoutUsuarioInput, RecursoUncheckedCreateWithoutUsuarioInput>
  }

  export type RecursoCreateManyUsuarioInputEnvelope = {
    data: RecursoCreateManyUsuarioInput | RecursoCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type SorteioDancaCreateWithoutUsuarioInput = {
    resultadoSorteio: number
    dataSorteio?: Date | string
    tipoDanca: $Enums.DancaSalaoTradicional
    preferenciaSorteioDancaIds?: PreferenciaSorteioDancaCreateNestedManyWithoutSorteioDancaInput
    Candidato: CandidatoCreateNestedOneWithoutSorteioDancaInput
  }

  export type SorteioDancaUncheckedCreateWithoutUsuarioInput = {
    idSorteio?: number
    resultadoSorteio: number
    dataSorteio?: Date | string
    tipoDanca: $Enums.DancaSalaoTradicional
    candidatoId: number
    preferenciaSorteioDancaIds?: PreferenciaSorteioDancaUncheckedCreateNestedManyWithoutSorteioDancaInput
  }

  export type SorteioDancaCreateOrConnectWithoutUsuarioInput = {
    where: SorteioDancaWhereUniqueInput
    create: XOR<SorteioDancaCreateWithoutUsuarioInput, SorteioDancaUncheckedCreateWithoutUsuarioInput>
  }

  export type SorteioDancaCreateManyUsuarioInputEnvelope = {
    data: SorteioDancaCreateManyUsuarioInput | SorteioDancaCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type CTGUpsertWithoutUsuarioInput = {
    update: XOR<CTGUpdateWithoutUsuarioInput, CTGUncheckedUpdateWithoutUsuarioInput>
    create: XOR<CTGCreateWithoutUsuarioInput, CTGUncheckedCreateWithoutUsuarioInput>
    where?: CTGWhereInput
  }

  export type CTGUpdateToOneWithWhereWithoutUsuarioInput = {
    where?: CTGWhereInput
    data: XOR<CTGUpdateWithoutUsuarioInput, CTGUncheckedUpdateWithoutUsuarioInput>
  }

  export type CTGUpdateWithoutUsuarioInput = {
    nomeCTG?: StringFieldUpdateOperationsInput | string
    RT?: RTUpdateOneRequiredWithoutCTGsNestedInput
    Candidato?: CandidatoUpdateManyWithoutCTGNestedInput
  }

  export type CTGUncheckedUpdateWithoutUsuarioInput = {
    idCTG?: IntFieldUpdateOperationsInput | number
    nomeCTG?: StringFieldUpdateOperationsInput | string
    RTid?: IntFieldUpdateOperationsInput | number
    Candidato?: CandidatoUncheckedUpdateManyWithoutCTGNestedInput
  }

  export type ComissaoUsuarioUpsertWithoutUsuariosInput = {
    update: XOR<ComissaoUsuarioUpdateWithoutUsuariosInput, ComissaoUsuarioUncheckedUpdateWithoutUsuariosInput>
    create: XOR<ComissaoUsuarioCreateWithoutUsuariosInput, ComissaoUsuarioUncheckedCreateWithoutUsuariosInput>
    where?: ComissaoUsuarioWhereInput
  }

  export type ComissaoUsuarioUpdateToOneWithWhereWithoutUsuariosInput = {
    where?: ComissaoUsuarioWhereInput
    data: XOR<ComissaoUsuarioUpdateWithoutUsuariosInput, ComissaoUsuarioUncheckedUpdateWithoutUsuariosInput>
  }

  export type ComissaoUsuarioUpdateWithoutUsuariosInput = {
    Comissao?: ComissaoUpdateOneRequiredWithoutUsuariosNestedInput
  }

  export type ComissaoUsuarioUncheckedUpdateWithoutUsuariosInput = {
    idComissaoUsuario?: IntFieldUpdateOperationsInput | number
    comissaoId?: IntFieldUpdateOperationsInput | number
  }

  export type AvaliacaoUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: AvaliacaoWhereUniqueInput
    update: XOR<AvaliacaoUpdateWithoutUsuarioInput, AvaliacaoUncheckedUpdateWithoutUsuarioInput>
    create: XOR<AvaliacaoCreateWithoutUsuarioInput, AvaliacaoUncheckedCreateWithoutUsuarioInput>
  }

  export type AvaliacaoUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: AvaliacaoWhereUniqueInput
    data: XOR<AvaliacaoUpdateWithoutUsuarioInput, AvaliacaoUncheckedUpdateWithoutUsuarioInput>
  }

  export type AvaliacaoUpdateManyWithWhereWithoutUsuarioInput = {
    where: AvaliacaoScalarWhereInput
    data: XOR<AvaliacaoUpdateManyMutationInput, AvaliacaoUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type RecursoUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: RecursoWhereUniqueInput
    update: XOR<RecursoUpdateWithoutUsuarioInput, RecursoUncheckedUpdateWithoutUsuarioInput>
    create: XOR<RecursoCreateWithoutUsuarioInput, RecursoUncheckedCreateWithoutUsuarioInput>
  }

  export type RecursoUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: RecursoWhereUniqueInput
    data: XOR<RecursoUpdateWithoutUsuarioInput, RecursoUncheckedUpdateWithoutUsuarioInput>
  }

  export type RecursoUpdateManyWithWhereWithoutUsuarioInput = {
    where: RecursoScalarWhereInput
    data: XOR<RecursoUpdateManyMutationInput, RecursoUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type SorteioDancaUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: SorteioDancaWhereUniqueInput
    update: XOR<SorteioDancaUpdateWithoutUsuarioInput, SorteioDancaUncheckedUpdateWithoutUsuarioInput>
    create: XOR<SorteioDancaCreateWithoutUsuarioInput, SorteioDancaUncheckedCreateWithoutUsuarioInput>
  }

  export type SorteioDancaUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: SorteioDancaWhereUniqueInput
    data: XOR<SorteioDancaUpdateWithoutUsuarioInput, SorteioDancaUncheckedUpdateWithoutUsuarioInput>
  }

  export type SorteioDancaUpdateManyWithWhereWithoutUsuarioInput = {
    where: SorteioDancaScalarWhereInput
    data: XOR<SorteioDancaUpdateManyMutationInput, SorteioDancaUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type RTCreateWithoutCTGsInput = {
    nomeRT: string
    numeroRT?: number | null
  }

  export type RTUncheckedCreateWithoutCTGsInput = {
    idRT?: number
    nomeRT: string
    numeroRT?: number | null
  }

  export type RTCreateOrConnectWithoutCTGsInput = {
    where: RTWhereUniqueInput
    create: XOR<RTCreateWithoutCTGsInput, RTUncheckedCreateWithoutCTGsInput>
  }

  export type UsuarioCreateWithoutCTGInput = {
    nomeCompleto: string
    cidade: string
    estado: string
    numCarteirinha: string
    login: string
    senha: string
    funcao: $Enums.Funcao
    credenciamento?: $Enums.Credenciamento
    numCredenciamento?: number | null
    comissaoUsuarioId?: number | null
    ComissaoUsuario?: ComissaoUsuarioCreateNestedOneWithoutUsuariosInput
    avalicoes?: AvaliacaoCreateNestedManyWithoutUsuarioInput
    recursos?: RecursoCreateNestedManyWithoutUsuarioInput
    sorteioDanca?: SorteioDancaCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutCTGInput = {
    idUsuario?: number
    nomeCompleto: string
    cidade: string
    estado: string
    numCarteirinha: string
    login: string
    senha: string
    funcao: $Enums.Funcao
    credenciamento?: $Enums.Credenciamento
    numCredenciamento?: number | null
    comissaoUsuarioId?: number | null
    ComissaoUsuario?: ComissaoUsuarioUncheckedCreateNestedOneWithoutUsuariosInput
    avalicoes?: AvaliacaoUncheckedCreateNestedManyWithoutUsuarioInput
    recursos?: RecursoUncheckedCreateNestedManyWithoutUsuarioInput
    sorteioDanca?: SorteioDancaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutCTGInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutCTGInput, UsuarioUncheckedCreateWithoutCTGInput>
  }

  export type UsuarioCreateManyCTGInputEnvelope = {
    data: UsuarioCreateManyCTGInput | UsuarioCreateManyCTGInput[]
    skipDuplicates?: boolean
  }

  export type CandidatoCreateWithoutCTGInput = {
    nomeCompleto: string
    cidade: string
    estado: string
    numCarteirinha: string
    CPF: string
    RG: string
    endereco: string
    numEndereco: number
    bairro: string
    escolaridade: string
    filiacao: string
    ProvaCampeiraEsportiva?: $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: Bytes | null
    anexoCarteirinha?: Bytes | null
    anexoEscolaridade?: Bytes | null
    anexoResidencia?: Bytes | null
    anexoAtaConcurso?: Bytes | null
    fichaInscricao?: Bytes | null
    anexoTermoCandidato?: Bytes | null
    anexoRelatorioVivencia?: Bytes | null
    anexoResponsavel?: Bytes | null
    anexoProvaEsportivaCampeira?: Bytes | null
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaCreateNestedManyWithoutCandidatoInput
    Categoria: CategoriaCreateNestedOneWithoutCandidatosInput
    avalicoes?: AvaliacaoCreateNestedManyWithoutCandidatoInput
    sorteioDanca?: SorteioDancaCreateNestedManyWithoutCandidatoInput
    Recurso?: RecursoCreateNestedManyWithoutCandidatoInput
    Concurso?: ConcursoCreateNestedOneWithoutCandidatosInput
  }

  export type CandidatoUncheckedCreateWithoutCTGInput = {
    idCandidato?: number
    nomeCompleto: string
    cidade: string
    estado: string
    numCarteirinha: string
    CPF: string
    RG: string
    endereco: string
    numEndereco: number
    bairro: string
    escolaridade: string
    filiacao: string
    ProvaCampeiraEsportiva?: $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: Bytes | null
    anexoCarteirinha?: Bytes | null
    anexoEscolaridade?: Bytes | null
    anexoResidencia?: Bytes | null
    anexoAtaConcurso?: Bytes | null
    fichaInscricao?: Bytes | null
    anexoTermoCandidato?: Bytes | null
    anexoRelatorioVivencia?: Bytes | null
    anexoResponsavel?: Bytes | null
    anexoProvaEsportivaCampeira?: Bytes | null
    categoriaId: number
    concursoIdConcurso?: number | null
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaUncheckedCreateNestedManyWithoutCandidatoInput
    avalicoes?: AvaliacaoUncheckedCreateNestedManyWithoutCandidatoInput
    sorteioDanca?: SorteioDancaUncheckedCreateNestedManyWithoutCandidatoInput
    Recurso?: RecursoUncheckedCreateNestedManyWithoutCandidatoInput
  }

  export type CandidatoCreateOrConnectWithoutCTGInput = {
    where: CandidatoWhereUniqueInput
    create: XOR<CandidatoCreateWithoutCTGInput, CandidatoUncheckedCreateWithoutCTGInput>
  }

  export type CandidatoCreateManyCTGInputEnvelope = {
    data: CandidatoCreateManyCTGInput | CandidatoCreateManyCTGInput[]
    skipDuplicates?: boolean
  }

  export type RTUpsertWithoutCTGsInput = {
    update: XOR<RTUpdateWithoutCTGsInput, RTUncheckedUpdateWithoutCTGsInput>
    create: XOR<RTCreateWithoutCTGsInput, RTUncheckedCreateWithoutCTGsInput>
    where?: RTWhereInput
  }

  export type RTUpdateToOneWithWhereWithoutCTGsInput = {
    where?: RTWhereInput
    data: XOR<RTUpdateWithoutCTGsInput, RTUncheckedUpdateWithoutCTGsInput>
  }

  export type RTUpdateWithoutCTGsInput = {
    nomeRT?: StringFieldUpdateOperationsInput | string
    numeroRT?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RTUncheckedUpdateWithoutCTGsInput = {
    idRT?: IntFieldUpdateOperationsInput | number
    nomeRT?: StringFieldUpdateOperationsInput | string
    numeroRT?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UsuarioUpsertWithWhereUniqueWithoutCTGInput = {
    where: UsuarioWhereUniqueInput
    update: XOR<UsuarioUpdateWithoutCTGInput, UsuarioUncheckedUpdateWithoutCTGInput>
    create: XOR<UsuarioCreateWithoutCTGInput, UsuarioUncheckedCreateWithoutCTGInput>
  }

  export type UsuarioUpdateWithWhereUniqueWithoutCTGInput = {
    where: UsuarioWhereUniqueInput
    data: XOR<UsuarioUpdateWithoutCTGInput, UsuarioUncheckedUpdateWithoutCTGInput>
  }

  export type UsuarioUpdateManyWithWhereWithoutCTGInput = {
    where: UsuarioScalarWhereInput
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyWithoutCTGInput>
  }

  export type UsuarioScalarWhereInput = {
    AND?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
    OR?: UsuarioScalarWhereInput[]
    NOT?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
    idUsuario?: IntFilter<"Usuario"> | number
    nomeCompleto?: StringFilter<"Usuario"> | string
    cidade?: StringFilter<"Usuario"> | string
    estado?: StringFilter<"Usuario"> | string
    CTGId?: IntFilter<"Usuario"> | number
    numCarteirinha?: StringFilter<"Usuario"> | string
    login?: StringFilter<"Usuario"> | string
    senha?: StringFilter<"Usuario"> | string
    funcao?: EnumFuncaoFilter<"Usuario"> | $Enums.Funcao
    credenciamento?: EnumCredenciamentoFilter<"Usuario"> | $Enums.Credenciamento
    numCredenciamento?: IntNullableFilter<"Usuario"> | number | null
    comissaoUsuarioId?: IntNullableFilter<"Usuario"> | number | null
  }

  export type CandidatoUpsertWithWhereUniqueWithoutCTGInput = {
    where: CandidatoWhereUniqueInput
    update: XOR<CandidatoUpdateWithoutCTGInput, CandidatoUncheckedUpdateWithoutCTGInput>
    create: XOR<CandidatoCreateWithoutCTGInput, CandidatoUncheckedCreateWithoutCTGInput>
  }

  export type CandidatoUpdateWithWhereUniqueWithoutCTGInput = {
    where: CandidatoWhereUniqueInput
    data: XOR<CandidatoUpdateWithoutCTGInput, CandidatoUncheckedUpdateWithoutCTGInput>
  }

  export type CandidatoUpdateManyWithWhereWithoutCTGInput = {
    where: CandidatoScalarWhereInput
    data: XOR<CandidatoUpdateManyMutationInput, CandidatoUncheckedUpdateManyWithoutCTGInput>
  }

  export type CandidatoScalarWhereInput = {
    AND?: CandidatoScalarWhereInput | CandidatoScalarWhereInput[]
    OR?: CandidatoScalarWhereInput[]
    NOT?: CandidatoScalarWhereInput | CandidatoScalarWhereInput[]
    idCandidato?: IntFilter<"Candidato"> | number
    nomeCompleto?: StringFilter<"Candidato"> | string
    cidade?: StringFilter<"Candidato"> | string
    estado?: StringFilter<"Candidato"> | string
    CTGId?: IntFilter<"Candidato"> | number
    numCarteirinha?: StringFilter<"Candidato"> | string
    CPF?: StringFilter<"Candidato"> | string
    RG?: StringFilter<"Candidato"> | string
    endereco?: StringFilter<"Candidato"> | string
    numEndereco?: IntFilter<"Candidato"> | number
    bairro?: StringFilter<"Candidato"> | string
    escolaridade?: StringFilter<"Candidato"> | string
    filiacao?: StringFilter<"Candidato"> | string
    ProvaCampeiraEsportiva?: EnumProvaCampeiraEsportivaNullableFilter<"Candidato"> | $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: BytesNullableFilter<"Candidato"> | Bytes | null
    anexoCarteirinha?: BytesNullableFilter<"Candidato"> | Bytes | null
    anexoEscolaridade?: BytesNullableFilter<"Candidato"> | Bytes | null
    anexoResidencia?: BytesNullableFilter<"Candidato"> | Bytes | null
    anexoAtaConcurso?: BytesNullableFilter<"Candidato"> | Bytes | null
    fichaInscricao?: BytesNullableFilter<"Candidato"> | Bytes | null
    anexoTermoCandidato?: BytesNullableFilter<"Candidato"> | Bytes | null
    anexoRelatorioVivencia?: BytesNullableFilter<"Candidato"> | Bytes | null
    anexoResponsavel?: BytesNullableFilter<"Candidato"> | Bytes | null
    anexoProvaEsportivaCampeira?: BytesNullableFilter<"Candidato"> | Bytes | null
    categoriaId?: IntFilter<"Candidato"> | number
    concursoIdConcurso?: IntNullableFilter<"Candidato"> | number | null
  }

  export type CTGCreateWithoutRTInput = {
    nomeCTG: string
    Usuario?: UsuarioCreateNestedManyWithoutCTGInput
    Candidato?: CandidatoCreateNestedManyWithoutCTGInput
  }

  export type CTGUncheckedCreateWithoutRTInput = {
    idCTG?: number
    nomeCTG: string
    Usuario?: UsuarioUncheckedCreateNestedManyWithoutCTGInput
    Candidato?: CandidatoUncheckedCreateNestedManyWithoutCTGInput
  }

  export type CTGCreateOrConnectWithoutRTInput = {
    where: CTGWhereUniqueInput
    create: XOR<CTGCreateWithoutRTInput, CTGUncheckedCreateWithoutRTInput>
  }

  export type CTGCreateManyRTInputEnvelope = {
    data: CTGCreateManyRTInput | CTGCreateManyRTInput[]
    skipDuplicates?: boolean
  }

  export type CTGUpsertWithWhereUniqueWithoutRTInput = {
    where: CTGWhereUniqueInput
    update: XOR<CTGUpdateWithoutRTInput, CTGUncheckedUpdateWithoutRTInput>
    create: XOR<CTGCreateWithoutRTInput, CTGUncheckedCreateWithoutRTInput>
  }

  export type CTGUpdateWithWhereUniqueWithoutRTInput = {
    where: CTGWhereUniqueInput
    data: XOR<CTGUpdateWithoutRTInput, CTGUncheckedUpdateWithoutRTInput>
  }

  export type CTGUpdateManyWithWhereWithoutRTInput = {
    where: CTGScalarWhereInput
    data: XOR<CTGUpdateManyMutationInput, CTGUncheckedUpdateManyWithoutRTInput>
  }

  export type CTGScalarWhereInput = {
    AND?: CTGScalarWhereInput | CTGScalarWhereInput[]
    OR?: CTGScalarWhereInput[]
    NOT?: CTGScalarWhereInput | CTGScalarWhereInput[]
    idCTG?: IntFilter<"CTG"> | number
    nomeCTG?: StringFilter<"CTG"> | string
    RTid?: IntFilter<"CTG"> | number
  }

  export type CandidatoCreateWithoutPreferenciaSorteioDancaInput = {
    nomeCompleto: string
    cidade: string
    estado: string
    numCarteirinha: string
    CPF: string
    RG: string
    endereco: string
    numEndereco: number
    bairro: string
    escolaridade: string
    filiacao: string
    ProvaCampeiraEsportiva?: $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: Bytes | null
    anexoCarteirinha?: Bytes | null
    anexoEscolaridade?: Bytes | null
    anexoResidencia?: Bytes | null
    anexoAtaConcurso?: Bytes | null
    fichaInscricao?: Bytes | null
    anexoTermoCandidato?: Bytes | null
    anexoRelatorioVivencia?: Bytes | null
    anexoResponsavel?: Bytes | null
    anexoProvaEsportivaCampeira?: Bytes | null
    CTG: CTGCreateNestedOneWithoutCandidatoInput
    Categoria: CategoriaCreateNestedOneWithoutCandidatosInput
    avalicoes?: AvaliacaoCreateNestedManyWithoutCandidatoInput
    sorteioDanca?: SorteioDancaCreateNestedManyWithoutCandidatoInput
    Recurso?: RecursoCreateNestedManyWithoutCandidatoInput
    Concurso?: ConcursoCreateNestedOneWithoutCandidatosInput
  }

  export type CandidatoUncheckedCreateWithoutPreferenciaSorteioDancaInput = {
    idCandidato?: number
    nomeCompleto: string
    cidade: string
    estado: string
    CTGId: number
    numCarteirinha: string
    CPF: string
    RG: string
    endereco: string
    numEndereco: number
    bairro: string
    escolaridade: string
    filiacao: string
    ProvaCampeiraEsportiva?: $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: Bytes | null
    anexoCarteirinha?: Bytes | null
    anexoEscolaridade?: Bytes | null
    anexoResidencia?: Bytes | null
    anexoAtaConcurso?: Bytes | null
    fichaInscricao?: Bytes | null
    anexoTermoCandidato?: Bytes | null
    anexoRelatorioVivencia?: Bytes | null
    anexoResponsavel?: Bytes | null
    anexoProvaEsportivaCampeira?: Bytes | null
    categoriaId: number
    concursoIdConcurso?: number | null
    avalicoes?: AvaliacaoUncheckedCreateNestedManyWithoutCandidatoInput
    sorteioDanca?: SorteioDancaUncheckedCreateNestedManyWithoutCandidatoInput
    Recurso?: RecursoUncheckedCreateNestedManyWithoutCandidatoInput
  }

  export type CandidatoCreateOrConnectWithoutPreferenciaSorteioDancaInput = {
    where: CandidatoWhereUniqueInput
    create: XOR<CandidatoCreateWithoutPreferenciaSorteioDancaInput, CandidatoUncheckedCreateWithoutPreferenciaSorteioDancaInput>
  }

  export type SorteioDancaCreateWithoutPreferenciaSorteioDancaIdsInput = {
    resultadoSorteio: number
    dataSorteio?: Date | string
    tipoDanca: $Enums.DancaSalaoTradicional
    Candidato: CandidatoCreateNestedOneWithoutSorteioDancaInput
    Usuario: UsuarioCreateNestedOneWithoutSorteioDancaInput
  }

  export type SorteioDancaUncheckedCreateWithoutPreferenciaSorteioDancaIdsInput = {
    idSorteio?: number
    resultadoSorteio: number
    dataSorteio?: Date | string
    tipoDanca: $Enums.DancaSalaoTradicional
    candidatoId: number
    usuarioId: number
  }

  export type SorteioDancaCreateOrConnectWithoutPreferenciaSorteioDancaIdsInput = {
    where: SorteioDancaWhereUniqueInput
    create: XOR<SorteioDancaCreateWithoutPreferenciaSorteioDancaIdsInput, SorteioDancaUncheckedCreateWithoutPreferenciaSorteioDancaIdsInput>
  }

  export type QuesitosCreateWithoutPreferenciaSorteioDancaInput = {
    nomeQuesito: string
    notaMaximaQuesito: number
    danca: boolean
    dancaSalaoTradicional: $Enums.DancaSalaoTradicional
    BlocoProva?: BlocoProvaCreateNestedOneWithoutQuesitosInput
    ProvaTeorica?: ProvaTeoricaCreateNestedOneWithoutQuesitosInput
    subeQuesitos?: SubQuesitosCreateNestedManyWithoutQuesitoInput
    recursos?: RecursoCreateNestedManyWithoutQuesitoInput
    Avaliacao?: AvaliacaoCreateNestedOneWithoutQuesitosInput
  }

  export type QuesitosUncheckedCreateWithoutPreferenciaSorteioDancaInput = {
    idQuesito?: number
    nomeQuesito: string
    notaMaximaQuesito: number
    danca: boolean
    dancaSalaoTradicional: $Enums.DancaSalaoTradicional
    blocoProvaIdBloco?: number | null
    provaTeoricaIdprovaTeorica?: number | null
    avaliacaoIdAvalicao?: number | null
    subeQuesitos?: SubQuesitosUncheckedCreateNestedManyWithoutQuesitoInput
    recursos?: RecursoUncheckedCreateNestedManyWithoutQuesitoInput
  }

  export type QuesitosCreateOrConnectWithoutPreferenciaSorteioDancaInput = {
    where: QuesitosWhereUniqueInput
    create: XOR<QuesitosCreateWithoutPreferenciaSorteioDancaInput, QuesitosUncheckedCreateWithoutPreferenciaSorteioDancaInput>
  }

  export type QuesitosCreateManyPreferenciaSorteioDancaInputEnvelope = {
    data: QuesitosCreateManyPreferenciaSorteioDancaInput | QuesitosCreateManyPreferenciaSorteioDancaInput[]
    skipDuplicates?: boolean
  }

  export type CandidatoUpsertWithoutPreferenciaSorteioDancaInput = {
    update: XOR<CandidatoUpdateWithoutPreferenciaSorteioDancaInput, CandidatoUncheckedUpdateWithoutPreferenciaSorteioDancaInput>
    create: XOR<CandidatoCreateWithoutPreferenciaSorteioDancaInput, CandidatoUncheckedCreateWithoutPreferenciaSorteioDancaInput>
    where?: CandidatoWhereInput
  }

  export type CandidatoUpdateToOneWithWhereWithoutPreferenciaSorteioDancaInput = {
    where?: CandidatoWhereInput
    data: XOR<CandidatoUpdateWithoutPreferenciaSorteioDancaInput, CandidatoUncheckedUpdateWithoutPreferenciaSorteioDancaInput>
  }

  export type CandidatoUpdateWithoutPreferenciaSorteioDancaInput = {
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    numCarteirinha?: StringFieldUpdateOperationsInput | string
    CPF?: StringFieldUpdateOperationsInput | string
    RG?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    numEndereco?: IntFieldUpdateOperationsInput | number
    bairro?: StringFieldUpdateOperationsInput | string
    escolaridade?: StringFieldUpdateOperationsInput | string
    filiacao?: StringFieldUpdateOperationsInput | string
    ProvaCampeiraEsportiva?: NullableEnumProvaCampeiraEsportivaFieldUpdateOperationsInput | $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoCarteirinha?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoEscolaridade?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoResidencia?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoAtaConcurso?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    fichaInscricao?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoTermoCandidato?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoRelatorioVivencia?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoResponsavel?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoProvaEsportivaCampeira?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    CTG?: CTGUpdateOneRequiredWithoutCandidatoNestedInput
    Categoria?: CategoriaUpdateOneRequiredWithoutCandidatosNestedInput
    avalicoes?: AvaliacaoUpdateManyWithoutCandidatoNestedInput
    sorteioDanca?: SorteioDancaUpdateManyWithoutCandidatoNestedInput
    Recurso?: RecursoUpdateManyWithoutCandidatoNestedInput
    Concurso?: ConcursoUpdateOneWithoutCandidatosNestedInput
  }

  export type CandidatoUncheckedUpdateWithoutPreferenciaSorteioDancaInput = {
    idCandidato?: IntFieldUpdateOperationsInput | number
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    CTGId?: IntFieldUpdateOperationsInput | number
    numCarteirinha?: StringFieldUpdateOperationsInput | string
    CPF?: StringFieldUpdateOperationsInput | string
    RG?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    numEndereco?: IntFieldUpdateOperationsInput | number
    bairro?: StringFieldUpdateOperationsInput | string
    escolaridade?: StringFieldUpdateOperationsInput | string
    filiacao?: StringFieldUpdateOperationsInput | string
    ProvaCampeiraEsportiva?: NullableEnumProvaCampeiraEsportivaFieldUpdateOperationsInput | $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoCarteirinha?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoEscolaridade?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoResidencia?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoAtaConcurso?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    fichaInscricao?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoTermoCandidato?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoRelatorioVivencia?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoResponsavel?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoProvaEsportivaCampeira?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    categoriaId?: IntFieldUpdateOperationsInput | number
    concursoIdConcurso?: NullableIntFieldUpdateOperationsInput | number | null
    avalicoes?: AvaliacaoUncheckedUpdateManyWithoutCandidatoNestedInput
    sorteioDanca?: SorteioDancaUncheckedUpdateManyWithoutCandidatoNestedInput
    Recurso?: RecursoUncheckedUpdateManyWithoutCandidatoNestedInput
  }

  export type SorteioDancaUpsertWithoutPreferenciaSorteioDancaIdsInput = {
    update: XOR<SorteioDancaUpdateWithoutPreferenciaSorteioDancaIdsInput, SorteioDancaUncheckedUpdateWithoutPreferenciaSorteioDancaIdsInput>
    create: XOR<SorteioDancaCreateWithoutPreferenciaSorteioDancaIdsInput, SorteioDancaUncheckedCreateWithoutPreferenciaSorteioDancaIdsInput>
    where?: SorteioDancaWhereInput
  }

  export type SorteioDancaUpdateToOneWithWhereWithoutPreferenciaSorteioDancaIdsInput = {
    where?: SorteioDancaWhereInput
    data: XOR<SorteioDancaUpdateWithoutPreferenciaSorteioDancaIdsInput, SorteioDancaUncheckedUpdateWithoutPreferenciaSorteioDancaIdsInput>
  }

  export type SorteioDancaUpdateWithoutPreferenciaSorteioDancaIdsInput = {
    resultadoSorteio?: IntFieldUpdateOperationsInput | number
    dataSorteio?: DateTimeFieldUpdateOperationsInput | Date | string
    tipoDanca?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
    Candidato?: CandidatoUpdateOneRequiredWithoutSorteioDancaNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutSorteioDancaNestedInput
  }

  export type SorteioDancaUncheckedUpdateWithoutPreferenciaSorteioDancaIdsInput = {
    idSorteio?: IntFieldUpdateOperationsInput | number
    resultadoSorteio?: IntFieldUpdateOperationsInput | number
    dataSorteio?: DateTimeFieldUpdateOperationsInput | Date | string
    tipoDanca?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
    candidatoId?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
  }

  export type QuesitosUpsertWithWhereUniqueWithoutPreferenciaSorteioDancaInput = {
    where: QuesitosWhereUniqueInput
    update: XOR<QuesitosUpdateWithoutPreferenciaSorteioDancaInput, QuesitosUncheckedUpdateWithoutPreferenciaSorteioDancaInput>
    create: XOR<QuesitosCreateWithoutPreferenciaSorteioDancaInput, QuesitosUncheckedCreateWithoutPreferenciaSorteioDancaInput>
  }

  export type QuesitosUpdateWithWhereUniqueWithoutPreferenciaSorteioDancaInput = {
    where: QuesitosWhereUniqueInput
    data: XOR<QuesitosUpdateWithoutPreferenciaSorteioDancaInput, QuesitosUncheckedUpdateWithoutPreferenciaSorteioDancaInput>
  }

  export type QuesitosUpdateManyWithWhereWithoutPreferenciaSorteioDancaInput = {
    where: QuesitosScalarWhereInput
    data: XOR<QuesitosUpdateManyMutationInput, QuesitosUncheckedUpdateManyWithoutPreferenciaSorteioDancaInput>
  }

  export type QuesitosScalarWhereInput = {
    AND?: QuesitosScalarWhereInput | QuesitosScalarWhereInput[]
    OR?: QuesitosScalarWhereInput[]
    NOT?: QuesitosScalarWhereInput | QuesitosScalarWhereInput[]
    idQuesito?: IntFilter<"Quesitos"> | number
    nomeQuesito?: StringFilter<"Quesitos"> | string
    notaMaximaQuesito?: FloatFilter<"Quesitos"> | number
    danca?: BoolFilter<"Quesitos"> | boolean
    dancaSalaoTradicional?: EnumDancaSalaoTradicionalFilter<"Quesitos"> | $Enums.DancaSalaoTradicional
    blocoProvaIdBloco?: IntNullableFilter<"Quesitos"> | number | null
    provaTeoricaIdprovaTeorica?: IntNullableFilter<"Quesitos"> | number | null
    preferenciaSorteioDancaId?: IntNullableFilter<"Quesitos"> | number | null
    avaliacaoIdAvalicao?: IntNullableFilter<"Quesitos"> | number | null
  }

  export type CandidatoCreateWithoutConcursoInput = {
    nomeCompleto: string
    cidade: string
    estado: string
    numCarteirinha: string
    CPF: string
    RG: string
    endereco: string
    numEndereco: number
    bairro: string
    escolaridade: string
    filiacao: string
    ProvaCampeiraEsportiva?: $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: Bytes | null
    anexoCarteirinha?: Bytes | null
    anexoEscolaridade?: Bytes | null
    anexoResidencia?: Bytes | null
    anexoAtaConcurso?: Bytes | null
    fichaInscricao?: Bytes | null
    anexoTermoCandidato?: Bytes | null
    anexoRelatorioVivencia?: Bytes | null
    anexoResponsavel?: Bytes | null
    anexoProvaEsportivaCampeira?: Bytes | null
    CTG: CTGCreateNestedOneWithoutCandidatoInput
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaCreateNestedManyWithoutCandidatoInput
    Categoria: CategoriaCreateNestedOneWithoutCandidatosInput
    avalicoes?: AvaliacaoCreateNestedManyWithoutCandidatoInput
    sorteioDanca?: SorteioDancaCreateNestedManyWithoutCandidatoInput
    Recurso?: RecursoCreateNestedManyWithoutCandidatoInput
  }

  export type CandidatoUncheckedCreateWithoutConcursoInput = {
    idCandidato?: number
    nomeCompleto: string
    cidade: string
    estado: string
    CTGId: number
    numCarteirinha: string
    CPF: string
    RG: string
    endereco: string
    numEndereco: number
    bairro: string
    escolaridade: string
    filiacao: string
    ProvaCampeiraEsportiva?: $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: Bytes | null
    anexoCarteirinha?: Bytes | null
    anexoEscolaridade?: Bytes | null
    anexoResidencia?: Bytes | null
    anexoAtaConcurso?: Bytes | null
    fichaInscricao?: Bytes | null
    anexoTermoCandidato?: Bytes | null
    anexoRelatorioVivencia?: Bytes | null
    anexoResponsavel?: Bytes | null
    anexoProvaEsportivaCampeira?: Bytes | null
    categoriaId: number
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaUncheckedCreateNestedManyWithoutCandidatoInput
    avalicoes?: AvaliacaoUncheckedCreateNestedManyWithoutCandidatoInput
    sorteioDanca?: SorteioDancaUncheckedCreateNestedManyWithoutCandidatoInput
    Recurso?: RecursoUncheckedCreateNestedManyWithoutCandidatoInput
  }

  export type CandidatoCreateOrConnectWithoutConcursoInput = {
    where: CandidatoWhereUniqueInput
    create: XOR<CandidatoCreateWithoutConcursoInput, CandidatoUncheckedCreateWithoutConcursoInput>
  }

  export type CandidatoCreateManyConcursoInputEnvelope = {
    data: CandidatoCreateManyConcursoInput | CandidatoCreateManyConcursoInput[]
    skipDuplicates?: boolean
  }

  export type ComissaoCreateWithoutConcursoInput = {
    nomeComissao: string
    avalicao?: AvaliacaoCreateNestedManyWithoutComissaoInput
    usuarios?: ComissaoUsuarioCreateNestedManyWithoutComissaoInput
  }

  export type ComissaoUncheckedCreateWithoutConcursoInput = {
    idComissao?: number
    nomeComissao: string
    avalicao?: AvaliacaoUncheckedCreateNestedManyWithoutComissaoInput
    usuarios?: ComissaoUsuarioUncheckedCreateNestedManyWithoutComissaoInput
  }

  export type ComissaoCreateOrConnectWithoutConcursoInput = {
    where: ComissaoWhereUniqueInput
    create: XOR<ComissaoCreateWithoutConcursoInput, ComissaoUncheckedCreateWithoutConcursoInput>
  }

  export type ComissaoCreateManyConcursoInputEnvelope = {
    data: ComissaoCreateManyConcursoInput | ComissaoCreateManyConcursoInput[]
    skipDuplicates?: boolean
  }

  export type CandidatoUpsertWithWhereUniqueWithoutConcursoInput = {
    where: CandidatoWhereUniqueInput
    update: XOR<CandidatoUpdateWithoutConcursoInput, CandidatoUncheckedUpdateWithoutConcursoInput>
    create: XOR<CandidatoCreateWithoutConcursoInput, CandidatoUncheckedCreateWithoutConcursoInput>
  }

  export type CandidatoUpdateWithWhereUniqueWithoutConcursoInput = {
    where: CandidatoWhereUniqueInput
    data: XOR<CandidatoUpdateWithoutConcursoInput, CandidatoUncheckedUpdateWithoutConcursoInput>
  }

  export type CandidatoUpdateManyWithWhereWithoutConcursoInput = {
    where: CandidatoScalarWhereInput
    data: XOR<CandidatoUpdateManyMutationInput, CandidatoUncheckedUpdateManyWithoutConcursoInput>
  }

  export type ComissaoUpsertWithWhereUniqueWithoutConcursoInput = {
    where: ComissaoWhereUniqueInput
    update: XOR<ComissaoUpdateWithoutConcursoInput, ComissaoUncheckedUpdateWithoutConcursoInput>
    create: XOR<ComissaoCreateWithoutConcursoInput, ComissaoUncheckedCreateWithoutConcursoInput>
  }

  export type ComissaoUpdateWithWhereUniqueWithoutConcursoInput = {
    where: ComissaoWhereUniqueInput
    data: XOR<ComissaoUpdateWithoutConcursoInput, ComissaoUncheckedUpdateWithoutConcursoInput>
  }

  export type ComissaoUpdateManyWithWhereWithoutConcursoInput = {
    where: ComissaoScalarWhereInput
    data: XOR<ComissaoUpdateManyMutationInput, ComissaoUncheckedUpdateManyWithoutConcursoInput>
  }

  export type ComissaoScalarWhereInput = {
    AND?: ComissaoScalarWhereInput | ComissaoScalarWhereInput[]
    OR?: ComissaoScalarWhereInput[]
    NOT?: ComissaoScalarWhereInput | ComissaoScalarWhereInput[]
    idComissao?: IntFilter<"Comissao"> | number
    nomeComissao?: StringFilter<"Comissao"> | string
    concursoId?: IntFilter<"Comissao"> | number
  }

  export type ConcursoCreateWithoutComissoesInput = {
    nomeConcurso: string
    lancamentoEdital: Date | string
    inscricoesInicio: Date | string
    inscricoesFinal: Date | string
    dataProvaEscrita: Date | string
    dataProvasPraticas: Date | string
    dataResultado: Date | string
    local: string
    anexoEdital?: Bytes | null
    candidatos?: CandidatoCreateNestedManyWithoutConcursoInput
  }

  export type ConcursoUncheckedCreateWithoutComissoesInput = {
    idConcurso?: number
    nomeConcurso: string
    lancamentoEdital: Date | string
    inscricoesInicio: Date | string
    inscricoesFinal: Date | string
    dataProvaEscrita: Date | string
    dataProvasPraticas: Date | string
    dataResultado: Date | string
    local: string
    anexoEdital?: Bytes | null
    candidatos?: CandidatoUncheckedCreateNestedManyWithoutConcursoInput
  }

  export type ConcursoCreateOrConnectWithoutComissoesInput = {
    where: ConcursoWhereUniqueInput
    create: XOR<ConcursoCreateWithoutComissoesInput, ConcursoUncheckedCreateWithoutComissoesInput>
  }

  export type AvaliacaoCreateWithoutComissaoInput = {
    dataAvaliacao?: Date | string
    nota: number
    Usuario: UsuarioCreateNestedOneWithoutAvalicoesInput
    Prova?: ProvaCreateNestedOneWithoutAvaliacaoInput
    BlocoProva?: BlocoProvaCreateNestedOneWithoutAvaliacaoInput
    quesitos?: QuesitosCreateNestedManyWithoutAvaliacaoInput
    Candidato: CandidatoCreateNestedOneWithoutAvalicoesInput
    FichaCandidato?: FichaCandidatoCreateNestedOneWithoutAvaliacoesInput
  }

  export type AvaliacaoUncheckedCreateWithoutComissaoInput = {
    idAvalicao?: number
    dataAvaliacao?: Date | string
    avaliadorId: number
    provaId: number
    blocoProvaId?: number | null
    nota: number
    candidatoId: number
    fichaCandidatoIdFicha?: number | null
    quesitos?: QuesitosUncheckedCreateNestedManyWithoutAvaliacaoInput
  }

  export type AvaliacaoCreateOrConnectWithoutComissaoInput = {
    where: AvaliacaoWhereUniqueInput
    create: XOR<AvaliacaoCreateWithoutComissaoInput, AvaliacaoUncheckedCreateWithoutComissaoInput>
  }

  export type AvaliacaoCreateManyComissaoInputEnvelope = {
    data: AvaliacaoCreateManyComissaoInput | AvaliacaoCreateManyComissaoInput[]
    skipDuplicates?: boolean
  }

  export type ComissaoUsuarioCreateWithoutComissaoInput = {
    Usuarios: UsuarioCreateNestedOneWithoutComissaoUsuarioInput
  }

  export type ComissaoUsuarioUncheckedCreateWithoutComissaoInput = {
    idComissaoUsuario?: number
    usuarioId: number
  }

  export type ComissaoUsuarioCreateOrConnectWithoutComissaoInput = {
    where: ComissaoUsuarioWhereUniqueInput
    create: XOR<ComissaoUsuarioCreateWithoutComissaoInput, ComissaoUsuarioUncheckedCreateWithoutComissaoInput>
  }

  export type ComissaoUsuarioCreateManyComissaoInputEnvelope = {
    data: ComissaoUsuarioCreateManyComissaoInput | ComissaoUsuarioCreateManyComissaoInput[]
    skipDuplicates?: boolean
  }

  export type ConcursoUpsertWithoutComissoesInput = {
    update: XOR<ConcursoUpdateWithoutComissoesInput, ConcursoUncheckedUpdateWithoutComissoesInput>
    create: XOR<ConcursoCreateWithoutComissoesInput, ConcursoUncheckedCreateWithoutComissoesInput>
    where?: ConcursoWhereInput
  }

  export type ConcursoUpdateToOneWithWhereWithoutComissoesInput = {
    where?: ConcursoWhereInput
    data: XOR<ConcursoUpdateWithoutComissoesInput, ConcursoUncheckedUpdateWithoutComissoesInput>
  }

  export type ConcursoUpdateWithoutComissoesInput = {
    nomeConcurso?: StringFieldUpdateOperationsInput | string
    lancamentoEdital?: DateTimeFieldUpdateOperationsInput | Date | string
    inscricoesInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    inscricoesFinal?: DateTimeFieldUpdateOperationsInput | Date | string
    dataProvaEscrita?: DateTimeFieldUpdateOperationsInput | Date | string
    dataProvasPraticas?: DateTimeFieldUpdateOperationsInput | Date | string
    dataResultado?: DateTimeFieldUpdateOperationsInput | Date | string
    local?: StringFieldUpdateOperationsInput | string
    anexoEdital?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    candidatos?: CandidatoUpdateManyWithoutConcursoNestedInput
  }

  export type ConcursoUncheckedUpdateWithoutComissoesInput = {
    idConcurso?: IntFieldUpdateOperationsInput | number
    nomeConcurso?: StringFieldUpdateOperationsInput | string
    lancamentoEdital?: DateTimeFieldUpdateOperationsInput | Date | string
    inscricoesInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    inscricoesFinal?: DateTimeFieldUpdateOperationsInput | Date | string
    dataProvaEscrita?: DateTimeFieldUpdateOperationsInput | Date | string
    dataProvasPraticas?: DateTimeFieldUpdateOperationsInput | Date | string
    dataResultado?: DateTimeFieldUpdateOperationsInput | Date | string
    local?: StringFieldUpdateOperationsInput | string
    anexoEdital?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    candidatos?: CandidatoUncheckedUpdateManyWithoutConcursoNestedInput
  }

  export type AvaliacaoUpsertWithWhereUniqueWithoutComissaoInput = {
    where: AvaliacaoWhereUniqueInput
    update: XOR<AvaliacaoUpdateWithoutComissaoInput, AvaliacaoUncheckedUpdateWithoutComissaoInput>
    create: XOR<AvaliacaoCreateWithoutComissaoInput, AvaliacaoUncheckedCreateWithoutComissaoInput>
  }

  export type AvaliacaoUpdateWithWhereUniqueWithoutComissaoInput = {
    where: AvaliacaoWhereUniqueInput
    data: XOR<AvaliacaoUpdateWithoutComissaoInput, AvaliacaoUncheckedUpdateWithoutComissaoInput>
  }

  export type AvaliacaoUpdateManyWithWhereWithoutComissaoInput = {
    where: AvaliacaoScalarWhereInput
    data: XOR<AvaliacaoUpdateManyMutationInput, AvaliacaoUncheckedUpdateManyWithoutComissaoInput>
  }

  export type ComissaoUsuarioUpsertWithWhereUniqueWithoutComissaoInput = {
    where: ComissaoUsuarioWhereUniqueInput
    update: XOR<ComissaoUsuarioUpdateWithoutComissaoInput, ComissaoUsuarioUncheckedUpdateWithoutComissaoInput>
    create: XOR<ComissaoUsuarioCreateWithoutComissaoInput, ComissaoUsuarioUncheckedCreateWithoutComissaoInput>
  }

  export type ComissaoUsuarioUpdateWithWhereUniqueWithoutComissaoInput = {
    where: ComissaoUsuarioWhereUniqueInput
    data: XOR<ComissaoUsuarioUpdateWithoutComissaoInput, ComissaoUsuarioUncheckedUpdateWithoutComissaoInput>
  }

  export type ComissaoUsuarioUpdateManyWithWhereWithoutComissaoInput = {
    where: ComissaoUsuarioScalarWhereInput
    data: XOR<ComissaoUsuarioUpdateManyMutationInput, ComissaoUsuarioUncheckedUpdateManyWithoutComissaoInput>
  }

  export type ComissaoUsuarioScalarWhereInput = {
    AND?: ComissaoUsuarioScalarWhereInput | ComissaoUsuarioScalarWhereInput[]
    OR?: ComissaoUsuarioScalarWhereInput[]
    NOT?: ComissaoUsuarioScalarWhereInput | ComissaoUsuarioScalarWhereInput[]
    idComissaoUsuario?: IntFilter<"ComissaoUsuario"> | number
    comissaoId?: IntFilter<"ComissaoUsuario"> | number
    usuarioId?: IntFilter<"ComissaoUsuario"> | number
  }

  export type ComissaoCreateWithoutUsuariosInput = {
    nomeComissao: string
    concurso: ConcursoCreateNestedOneWithoutComissoesInput
    avalicao?: AvaliacaoCreateNestedManyWithoutComissaoInput
  }

  export type ComissaoUncheckedCreateWithoutUsuariosInput = {
    idComissao?: number
    nomeComissao: string
    concursoId: number
    avalicao?: AvaliacaoUncheckedCreateNestedManyWithoutComissaoInput
  }

  export type ComissaoCreateOrConnectWithoutUsuariosInput = {
    where: ComissaoWhereUniqueInput
    create: XOR<ComissaoCreateWithoutUsuariosInput, ComissaoUncheckedCreateWithoutUsuariosInput>
  }

  export type UsuarioCreateWithoutComissaoUsuarioInput = {
    nomeCompleto: string
    cidade: string
    estado: string
    numCarteirinha: string
    login: string
    senha: string
    funcao: $Enums.Funcao
    credenciamento?: $Enums.Credenciamento
    numCredenciamento?: number | null
    comissaoUsuarioId?: number | null
    CTG: CTGCreateNestedOneWithoutUsuarioInput
    avalicoes?: AvaliacaoCreateNestedManyWithoutUsuarioInput
    recursos?: RecursoCreateNestedManyWithoutUsuarioInput
    sorteioDanca?: SorteioDancaCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutComissaoUsuarioInput = {
    idUsuario?: number
    nomeCompleto: string
    cidade: string
    estado: string
    CTGId: number
    numCarteirinha: string
    login: string
    senha: string
    funcao: $Enums.Funcao
    credenciamento?: $Enums.Credenciamento
    numCredenciamento?: number | null
    comissaoUsuarioId?: number | null
    avalicoes?: AvaliacaoUncheckedCreateNestedManyWithoutUsuarioInput
    recursos?: RecursoUncheckedCreateNestedManyWithoutUsuarioInput
    sorteioDanca?: SorteioDancaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutComissaoUsuarioInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutComissaoUsuarioInput, UsuarioUncheckedCreateWithoutComissaoUsuarioInput>
  }

  export type ComissaoUpsertWithoutUsuariosInput = {
    update: XOR<ComissaoUpdateWithoutUsuariosInput, ComissaoUncheckedUpdateWithoutUsuariosInput>
    create: XOR<ComissaoCreateWithoutUsuariosInput, ComissaoUncheckedCreateWithoutUsuariosInput>
    where?: ComissaoWhereInput
  }

  export type ComissaoUpdateToOneWithWhereWithoutUsuariosInput = {
    where?: ComissaoWhereInput
    data: XOR<ComissaoUpdateWithoutUsuariosInput, ComissaoUncheckedUpdateWithoutUsuariosInput>
  }

  export type ComissaoUpdateWithoutUsuariosInput = {
    nomeComissao?: StringFieldUpdateOperationsInput | string
    concurso?: ConcursoUpdateOneRequiredWithoutComissoesNestedInput
    avalicao?: AvaliacaoUpdateManyWithoutComissaoNestedInput
  }

  export type ComissaoUncheckedUpdateWithoutUsuariosInput = {
    idComissao?: IntFieldUpdateOperationsInput | number
    nomeComissao?: StringFieldUpdateOperationsInput | string
    concursoId?: IntFieldUpdateOperationsInput | number
    avalicao?: AvaliacaoUncheckedUpdateManyWithoutComissaoNestedInput
  }

  export type UsuarioUpsertWithoutComissaoUsuarioInput = {
    update: XOR<UsuarioUpdateWithoutComissaoUsuarioInput, UsuarioUncheckedUpdateWithoutComissaoUsuarioInput>
    create: XOR<UsuarioCreateWithoutComissaoUsuarioInput, UsuarioUncheckedCreateWithoutComissaoUsuarioInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutComissaoUsuarioInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutComissaoUsuarioInput, UsuarioUncheckedUpdateWithoutComissaoUsuarioInput>
  }

  export type UsuarioUpdateWithoutComissaoUsuarioInput = {
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    numCarteirinha?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    funcao?: EnumFuncaoFieldUpdateOperationsInput | $Enums.Funcao
    credenciamento?: EnumCredenciamentoFieldUpdateOperationsInput | $Enums.Credenciamento
    numCredenciamento?: NullableIntFieldUpdateOperationsInput | number | null
    comissaoUsuarioId?: NullableIntFieldUpdateOperationsInput | number | null
    CTG?: CTGUpdateOneRequiredWithoutUsuarioNestedInput
    avalicoes?: AvaliacaoUpdateManyWithoutUsuarioNestedInput
    recursos?: RecursoUpdateManyWithoutUsuarioNestedInput
    sorteioDanca?: SorteioDancaUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutComissaoUsuarioInput = {
    idUsuario?: IntFieldUpdateOperationsInput | number
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    CTGId?: IntFieldUpdateOperationsInput | number
    numCarteirinha?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    funcao?: EnumFuncaoFieldUpdateOperationsInput | $Enums.Funcao
    credenciamento?: EnumCredenciamentoFieldUpdateOperationsInput | $Enums.Credenciamento
    numCredenciamento?: NullableIntFieldUpdateOperationsInput | number | null
    comissaoUsuarioId?: NullableIntFieldUpdateOperationsInput | number | null
    avalicoes?: AvaliacaoUncheckedUpdateManyWithoutUsuarioNestedInput
    recursos?: RecursoUncheckedUpdateManyWithoutUsuarioNestedInput
    sorteioDanca?: SorteioDancaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type CandidatoCreateWithoutCategoriaInput = {
    nomeCompleto: string
    cidade: string
    estado: string
    numCarteirinha: string
    CPF: string
    RG: string
    endereco: string
    numEndereco: number
    bairro: string
    escolaridade: string
    filiacao: string
    ProvaCampeiraEsportiva?: $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: Bytes | null
    anexoCarteirinha?: Bytes | null
    anexoEscolaridade?: Bytes | null
    anexoResidencia?: Bytes | null
    anexoAtaConcurso?: Bytes | null
    fichaInscricao?: Bytes | null
    anexoTermoCandidato?: Bytes | null
    anexoRelatorioVivencia?: Bytes | null
    anexoResponsavel?: Bytes | null
    anexoProvaEsportivaCampeira?: Bytes | null
    CTG: CTGCreateNestedOneWithoutCandidatoInput
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaCreateNestedManyWithoutCandidatoInput
    avalicoes?: AvaliacaoCreateNestedManyWithoutCandidatoInput
    sorteioDanca?: SorteioDancaCreateNestedManyWithoutCandidatoInput
    Recurso?: RecursoCreateNestedManyWithoutCandidatoInput
    Concurso?: ConcursoCreateNestedOneWithoutCandidatosInput
  }

  export type CandidatoUncheckedCreateWithoutCategoriaInput = {
    idCandidato?: number
    nomeCompleto: string
    cidade: string
    estado: string
    CTGId: number
    numCarteirinha: string
    CPF: string
    RG: string
    endereco: string
    numEndereco: number
    bairro: string
    escolaridade: string
    filiacao: string
    ProvaCampeiraEsportiva?: $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: Bytes | null
    anexoCarteirinha?: Bytes | null
    anexoEscolaridade?: Bytes | null
    anexoResidencia?: Bytes | null
    anexoAtaConcurso?: Bytes | null
    fichaInscricao?: Bytes | null
    anexoTermoCandidato?: Bytes | null
    anexoRelatorioVivencia?: Bytes | null
    anexoResponsavel?: Bytes | null
    anexoProvaEsportivaCampeira?: Bytes | null
    concursoIdConcurso?: number | null
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaUncheckedCreateNestedManyWithoutCandidatoInput
    avalicoes?: AvaliacaoUncheckedCreateNestedManyWithoutCandidatoInput
    sorteioDanca?: SorteioDancaUncheckedCreateNestedManyWithoutCandidatoInput
    Recurso?: RecursoUncheckedCreateNestedManyWithoutCandidatoInput
  }

  export type CandidatoCreateOrConnectWithoutCategoriaInput = {
    where: CandidatoWhereUniqueInput
    create: XOR<CandidatoCreateWithoutCategoriaInput, CandidatoUncheckedCreateWithoutCategoriaInput>
  }

  export type CandidatoCreateManyCategoriaInputEnvelope = {
    data: CandidatoCreateManyCategoriaInput | CandidatoCreateManyCategoriaInput[]
    skipDuplicates?: boolean
  }

  export type ProvaCreateWithoutCategoriasInput = {
    nomeProva: string
    notaMaxima: number
    ProvaTeorica?: ProvaTeoricaCreateNestedManyWithoutProvaInput
    ProvaPratica?: ProvaPraticaCreateNestedManyWithoutProvaInput
    recursos?: RecursoCreateNestedManyWithoutProvaInput
    Avaliacao?: AvaliacaoCreateNestedManyWithoutProvaInput
  }

  export type ProvaUncheckedCreateWithoutCategoriasInput = {
    idProva?: number
    nomeProva: string
    notaMaxima: number
    ProvaTeorica?: ProvaTeoricaUncheckedCreateNestedManyWithoutProvaInput
    ProvaPratica?: ProvaPraticaUncheckedCreateNestedManyWithoutProvaInput
    recursos?: RecursoUncheckedCreateNestedManyWithoutProvaInput
    Avaliacao?: AvaliacaoUncheckedCreateNestedManyWithoutProvaInput
  }

  export type ProvaCreateOrConnectWithoutCategoriasInput = {
    where: ProvaWhereUniqueInput
    create: XOR<ProvaCreateWithoutCategoriasInput, ProvaUncheckedCreateWithoutCategoriasInput>
  }

  export type ProvaTeoricaCreateWithoutCategoriaInput = {
    gabaritoOficinal: Bytes
    numQuestao: number
    Prova?: ProvaCreateNestedOneWithoutProvaTeoricaInput
    quesitos?: QuesitosCreateNestedManyWithoutProvaTeoricaInput
    Recurso?: RecursoCreateNestedManyWithoutProvaTeoricaInput
  }

  export type ProvaTeoricaUncheckedCreateWithoutCategoriaInput = {
    idprovaTeorica?: number
    provaId?: number | null
    gabaritoOficinal: Bytes
    numQuestao: number
    quesitos?: QuesitosUncheckedCreateNestedManyWithoutProvaTeoricaInput
    Recurso?: RecursoUncheckedCreateNestedManyWithoutProvaTeoricaInput
  }

  export type ProvaTeoricaCreateOrConnectWithoutCategoriaInput = {
    where: ProvaTeoricaWhereUniqueInput
    create: XOR<ProvaTeoricaCreateWithoutCategoriaInput, ProvaTeoricaUncheckedCreateWithoutCategoriaInput>
  }

  export type ProvaPraticaCreateWithoutCategoriaInput = {
    prova?: ProvaCreateNestedOneWithoutProvaPraticaInput
    blocosProvas?: BlocoProvaCreateNestedManyWithoutProvaPraticaInput
    Recurso?: RecursoCreateNestedManyWithoutProvaPraticaInput
  }

  export type ProvaPraticaUncheckedCreateWithoutCategoriaInput = {
    idProvaPratica?: number
    provaId?: number | null
    blocosProvas?: BlocoProvaUncheckedCreateNestedManyWithoutProvaPraticaInput
    Recurso?: RecursoUncheckedCreateNestedManyWithoutProvaPraticaInput
  }

  export type ProvaPraticaCreateOrConnectWithoutCategoriaInput = {
    where: ProvaPraticaWhereUniqueInput
    create: XOR<ProvaPraticaCreateWithoutCategoriaInput, ProvaPraticaUncheckedCreateWithoutCategoriaInput>
  }

  export type CandidatoUpsertWithWhereUniqueWithoutCategoriaInput = {
    where: CandidatoWhereUniqueInput
    update: XOR<CandidatoUpdateWithoutCategoriaInput, CandidatoUncheckedUpdateWithoutCategoriaInput>
    create: XOR<CandidatoCreateWithoutCategoriaInput, CandidatoUncheckedCreateWithoutCategoriaInput>
  }

  export type CandidatoUpdateWithWhereUniqueWithoutCategoriaInput = {
    where: CandidatoWhereUniqueInput
    data: XOR<CandidatoUpdateWithoutCategoriaInput, CandidatoUncheckedUpdateWithoutCategoriaInput>
  }

  export type CandidatoUpdateManyWithWhereWithoutCategoriaInput = {
    where: CandidatoScalarWhereInput
    data: XOR<CandidatoUpdateManyMutationInput, CandidatoUncheckedUpdateManyWithoutCategoriaInput>
  }

  export type ProvaUpsertWithoutCategoriasInput = {
    update: XOR<ProvaUpdateWithoutCategoriasInput, ProvaUncheckedUpdateWithoutCategoriasInput>
    create: XOR<ProvaCreateWithoutCategoriasInput, ProvaUncheckedCreateWithoutCategoriasInput>
    where?: ProvaWhereInput
  }

  export type ProvaUpdateToOneWithWhereWithoutCategoriasInput = {
    where?: ProvaWhereInput
    data: XOR<ProvaUpdateWithoutCategoriasInput, ProvaUncheckedUpdateWithoutCategoriasInput>
  }

  export type ProvaUpdateWithoutCategoriasInput = {
    nomeProva?: StringFieldUpdateOperationsInput | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    ProvaTeorica?: ProvaTeoricaUpdateManyWithoutProvaNestedInput
    ProvaPratica?: ProvaPraticaUpdateManyWithoutProvaNestedInput
    recursos?: RecursoUpdateManyWithoutProvaNestedInput
    Avaliacao?: AvaliacaoUpdateManyWithoutProvaNestedInput
  }

  export type ProvaUncheckedUpdateWithoutCategoriasInput = {
    idProva?: IntFieldUpdateOperationsInput | number
    nomeProva?: StringFieldUpdateOperationsInput | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    ProvaTeorica?: ProvaTeoricaUncheckedUpdateManyWithoutProvaNestedInput
    ProvaPratica?: ProvaPraticaUncheckedUpdateManyWithoutProvaNestedInput
    recursos?: RecursoUncheckedUpdateManyWithoutProvaNestedInput
    Avaliacao?: AvaliacaoUncheckedUpdateManyWithoutProvaNestedInput
  }

  export type ProvaTeoricaUpsertWithoutCategoriaInput = {
    update: XOR<ProvaTeoricaUpdateWithoutCategoriaInput, ProvaTeoricaUncheckedUpdateWithoutCategoriaInput>
    create: XOR<ProvaTeoricaCreateWithoutCategoriaInput, ProvaTeoricaUncheckedCreateWithoutCategoriaInput>
    where?: ProvaTeoricaWhereInput
  }

  export type ProvaTeoricaUpdateToOneWithWhereWithoutCategoriaInput = {
    where?: ProvaTeoricaWhereInput
    data: XOR<ProvaTeoricaUpdateWithoutCategoriaInput, ProvaTeoricaUncheckedUpdateWithoutCategoriaInput>
  }

  export type ProvaTeoricaUpdateWithoutCategoriaInput = {
    gabaritoOficinal?: BytesFieldUpdateOperationsInput | Bytes
    numQuestao?: IntFieldUpdateOperationsInput | number
    Prova?: ProvaUpdateOneWithoutProvaTeoricaNestedInput
    quesitos?: QuesitosUpdateManyWithoutProvaTeoricaNestedInput
    Recurso?: RecursoUpdateManyWithoutProvaTeoricaNestedInput
  }

  export type ProvaTeoricaUncheckedUpdateWithoutCategoriaInput = {
    idprovaTeorica?: IntFieldUpdateOperationsInput | number
    provaId?: NullableIntFieldUpdateOperationsInput | number | null
    gabaritoOficinal?: BytesFieldUpdateOperationsInput | Bytes
    numQuestao?: IntFieldUpdateOperationsInput | number
    quesitos?: QuesitosUncheckedUpdateManyWithoutProvaTeoricaNestedInput
    Recurso?: RecursoUncheckedUpdateManyWithoutProvaTeoricaNestedInput
  }

  export type ProvaPraticaUpsertWithoutCategoriaInput = {
    update: XOR<ProvaPraticaUpdateWithoutCategoriaInput, ProvaPraticaUncheckedUpdateWithoutCategoriaInput>
    create: XOR<ProvaPraticaCreateWithoutCategoriaInput, ProvaPraticaUncheckedCreateWithoutCategoriaInput>
    where?: ProvaPraticaWhereInput
  }

  export type ProvaPraticaUpdateToOneWithWhereWithoutCategoriaInput = {
    where?: ProvaPraticaWhereInput
    data: XOR<ProvaPraticaUpdateWithoutCategoriaInput, ProvaPraticaUncheckedUpdateWithoutCategoriaInput>
  }

  export type ProvaPraticaUpdateWithoutCategoriaInput = {
    prova?: ProvaUpdateOneWithoutProvaPraticaNestedInput
    blocosProvas?: BlocoProvaUpdateManyWithoutProvaPraticaNestedInput
    Recurso?: RecursoUpdateManyWithoutProvaPraticaNestedInput
  }

  export type ProvaPraticaUncheckedUpdateWithoutCategoriaInput = {
    idProvaPratica?: IntFieldUpdateOperationsInput | number
    provaId?: NullableIntFieldUpdateOperationsInput | number | null
    blocosProvas?: BlocoProvaUncheckedUpdateManyWithoutProvaPraticaNestedInput
    Recurso?: RecursoUncheckedUpdateManyWithoutProvaPraticaNestedInput
  }

  export type ComissaoCreateWithoutAvalicaoInput = {
    nomeComissao: string
    concurso: ConcursoCreateNestedOneWithoutComissoesInput
    usuarios?: ComissaoUsuarioCreateNestedManyWithoutComissaoInput
  }

  export type ComissaoUncheckedCreateWithoutAvalicaoInput = {
    idComissao?: number
    nomeComissao: string
    concursoId: number
    usuarios?: ComissaoUsuarioUncheckedCreateNestedManyWithoutComissaoInput
  }

  export type ComissaoCreateOrConnectWithoutAvalicaoInput = {
    where: ComissaoWhereUniqueInput
    create: XOR<ComissaoCreateWithoutAvalicaoInput, ComissaoUncheckedCreateWithoutAvalicaoInput>
  }

  export type UsuarioCreateWithoutAvalicoesInput = {
    nomeCompleto: string
    cidade: string
    estado: string
    numCarteirinha: string
    login: string
    senha: string
    funcao: $Enums.Funcao
    credenciamento?: $Enums.Credenciamento
    numCredenciamento?: number | null
    comissaoUsuarioId?: number | null
    CTG: CTGCreateNestedOneWithoutUsuarioInput
    ComissaoUsuario?: ComissaoUsuarioCreateNestedOneWithoutUsuariosInput
    recursos?: RecursoCreateNestedManyWithoutUsuarioInput
    sorteioDanca?: SorteioDancaCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutAvalicoesInput = {
    idUsuario?: number
    nomeCompleto: string
    cidade: string
    estado: string
    CTGId: number
    numCarteirinha: string
    login: string
    senha: string
    funcao: $Enums.Funcao
    credenciamento?: $Enums.Credenciamento
    numCredenciamento?: number | null
    comissaoUsuarioId?: number | null
    ComissaoUsuario?: ComissaoUsuarioUncheckedCreateNestedOneWithoutUsuariosInput
    recursos?: RecursoUncheckedCreateNestedManyWithoutUsuarioInput
    sorteioDanca?: SorteioDancaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutAvalicoesInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutAvalicoesInput, UsuarioUncheckedCreateWithoutAvalicoesInput>
  }

  export type ProvaCreateWithoutAvaliacaoInput = {
    nomeProva: string
    notaMaxima: number
    categorias?: CategoriaCreateNestedManyWithoutProvaInput
    ProvaTeorica?: ProvaTeoricaCreateNestedManyWithoutProvaInput
    ProvaPratica?: ProvaPraticaCreateNestedManyWithoutProvaInput
    recursos?: RecursoCreateNestedManyWithoutProvaInput
  }

  export type ProvaUncheckedCreateWithoutAvaliacaoInput = {
    idProva?: number
    nomeProva: string
    notaMaxima: number
    categorias?: CategoriaUncheckedCreateNestedManyWithoutProvaInput
    ProvaTeorica?: ProvaTeoricaUncheckedCreateNestedManyWithoutProvaInput
    ProvaPratica?: ProvaPraticaUncheckedCreateNestedManyWithoutProvaInput
    recursos?: RecursoUncheckedCreateNestedManyWithoutProvaInput
  }

  export type ProvaCreateOrConnectWithoutAvaliacaoInput = {
    where: ProvaWhereUniqueInput
    create: XOR<ProvaCreateWithoutAvaliacaoInput, ProvaUncheckedCreateWithoutAvaliacaoInput>
  }

  export type BlocoProvaCreateWithoutAvaliacaoInput = {
    nomeBloco: string
    notaMaximaBloco: number
    ProvaPratica?: ProvaPraticaCreateNestedOneWithoutBlocosProvasInput
    quesitos?: QuesitosCreateNestedManyWithoutBlocoProvaInput
  }

  export type BlocoProvaUncheckedCreateWithoutAvaliacaoInput = {
    idBloco?: number
    nomeBloco: string
    notaMaximaBloco: number
    provaPraticaId?: number | null
    quesitos?: QuesitosUncheckedCreateNestedManyWithoutBlocoProvaInput
  }

  export type BlocoProvaCreateOrConnectWithoutAvaliacaoInput = {
    where: BlocoProvaWhereUniqueInput
    create: XOR<BlocoProvaCreateWithoutAvaliacaoInput, BlocoProvaUncheckedCreateWithoutAvaliacaoInput>
  }

  export type QuesitosCreateWithoutAvaliacaoInput = {
    nomeQuesito: string
    notaMaximaQuesito: number
    danca: boolean
    dancaSalaoTradicional: $Enums.DancaSalaoTradicional
    BlocoProva?: BlocoProvaCreateNestedOneWithoutQuesitosInput
    ProvaTeorica?: ProvaTeoricaCreateNestedOneWithoutQuesitosInput
    subeQuesitos?: SubQuesitosCreateNestedManyWithoutQuesitoInput
    recursos?: RecursoCreateNestedManyWithoutQuesitoInput
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaCreateNestedOneWithoutQuesitosInput
  }

  export type QuesitosUncheckedCreateWithoutAvaliacaoInput = {
    idQuesito?: number
    nomeQuesito: string
    notaMaximaQuesito: number
    danca: boolean
    dancaSalaoTradicional: $Enums.DancaSalaoTradicional
    blocoProvaIdBloco?: number | null
    provaTeoricaIdprovaTeorica?: number | null
    preferenciaSorteioDancaId?: number | null
    subeQuesitos?: SubQuesitosUncheckedCreateNestedManyWithoutQuesitoInput
    recursos?: RecursoUncheckedCreateNestedManyWithoutQuesitoInput
  }

  export type QuesitosCreateOrConnectWithoutAvaliacaoInput = {
    where: QuesitosWhereUniqueInput
    create: XOR<QuesitosCreateWithoutAvaliacaoInput, QuesitosUncheckedCreateWithoutAvaliacaoInput>
  }

  export type QuesitosCreateManyAvaliacaoInputEnvelope = {
    data: QuesitosCreateManyAvaliacaoInput | QuesitosCreateManyAvaliacaoInput[]
    skipDuplicates?: boolean
  }

  export type CandidatoCreateWithoutAvalicoesInput = {
    nomeCompleto: string
    cidade: string
    estado: string
    numCarteirinha: string
    CPF: string
    RG: string
    endereco: string
    numEndereco: number
    bairro: string
    escolaridade: string
    filiacao: string
    ProvaCampeiraEsportiva?: $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: Bytes | null
    anexoCarteirinha?: Bytes | null
    anexoEscolaridade?: Bytes | null
    anexoResidencia?: Bytes | null
    anexoAtaConcurso?: Bytes | null
    fichaInscricao?: Bytes | null
    anexoTermoCandidato?: Bytes | null
    anexoRelatorioVivencia?: Bytes | null
    anexoResponsavel?: Bytes | null
    anexoProvaEsportivaCampeira?: Bytes | null
    CTG: CTGCreateNestedOneWithoutCandidatoInput
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaCreateNestedManyWithoutCandidatoInput
    Categoria: CategoriaCreateNestedOneWithoutCandidatosInput
    sorteioDanca?: SorteioDancaCreateNestedManyWithoutCandidatoInput
    Recurso?: RecursoCreateNestedManyWithoutCandidatoInput
    Concurso?: ConcursoCreateNestedOneWithoutCandidatosInput
  }

  export type CandidatoUncheckedCreateWithoutAvalicoesInput = {
    idCandidato?: number
    nomeCompleto: string
    cidade: string
    estado: string
    CTGId: number
    numCarteirinha: string
    CPF: string
    RG: string
    endereco: string
    numEndereco: number
    bairro: string
    escolaridade: string
    filiacao: string
    ProvaCampeiraEsportiva?: $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: Bytes | null
    anexoCarteirinha?: Bytes | null
    anexoEscolaridade?: Bytes | null
    anexoResidencia?: Bytes | null
    anexoAtaConcurso?: Bytes | null
    fichaInscricao?: Bytes | null
    anexoTermoCandidato?: Bytes | null
    anexoRelatorioVivencia?: Bytes | null
    anexoResponsavel?: Bytes | null
    anexoProvaEsportivaCampeira?: Bytes | null
    categoriaId: number
    concursoIdConcurso?: number | null
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaUncheckedCreateNestedManyWithoutCandidatoInput
    sorteioDanca?: SorteioDancaUncheckedCreateNestedManyWithoutCandidatoInput
    Recurso?: RecursoUncheckedCreateNestedManyWithoutCandidatoInput
  }

  export type CandidatoCreateOrConnectWithoutAvalicoesInput = {
    where: CandidatoWhereUniqueInput
    create: XOR<CandidatoCreateWithoutAvalicoesInput, CandidatoUncheckedCreateWithoutAvalicoesInput>
  }

  export type FichaCandidatoCreateWithoutAvaliacoesInput = {
    candidatoId: number
    notaCandidato: number
    provaId: number
    concursoId: number
    categoriaId: number
    anexoTermodeCiencia: Bytes
    dataTermo?: Date | string
    numAcertosProvaTeorica: number
    anexoGabarito: Bytes
    notaRedacao: number
    anexoRedacao: Bytes
    anexoProvaPratica: Bytes
  }

  export type FichaCandidatoUncheckedCreateWithoutAvaliacoesInput = {
    idFicha?: number
    candidatoId: number
    notaCandidato: number
    provaId: number
    concursoId: number
    categoriaId: number
    anexoTermodeCiencia: Bytes
    dataTermo?: Date | string
    numAcertosProvaTeorica: number
    anexoGabarito: Bytes
    notaRedacao: number
    anexoRedacao: Bytes
    anexoProvaPratica: Bytes
  }

  export type FichaCandidatoCreateOrConnectWithoutAvaliacoesInput = {
    where: FichaCandidatoWhereUniqueInput
    create: XOR<FichaCandidatoCreateWithoutAvaliacoesInput, FichaCandidatoUncheckedCreateWithoutAvaliacoesInput>
  }

  export type ComissaoUpsertWithoutAvalicaoInput = {
    update: XOR<ComissaoUpdateWithoutAvalicaoInput, ComissaoUncheckedUpdateWithoutAvalicaoInput>
    create: XOR<ComissaoCreateWithoutAvalicaoInput, ComissaoUncheckedCreateWithoutAvalicaoInput>
    where?: ComissaoWhereInput
  }

  export type ComissaoUpdateToOneWithWhereWithoutAvalicaoInput = {
    where?: ComissaoWhereInput
    data: XOR<ComissaoUpdateWithoutAvalicaoInput, ComissaoUncheckedUpdateWithoutAvalicaoInput>
  }

  export type ComissaoUpdateWithoutAvalicaoInput = {
    nomeComissao?: StringFieldUpdateOperationsInput | string
    concurso?: ConcursoUpdateOneRequiredWithoutComissoesNestedInput
    usuarios?: ComissaoUsuarioUpdateManyWithoutComissaoNestedInput
  }

  export type ComissaoUncheckedUpdateWithoutAvalicaoInput = {
    idComissao?: IntFieldUpdateOperationsInput | number
    nomeComissao?: StringFieldUpdateOperationsInput | string
    concursoId?: IntFieldUpdateOperationsInput | number
    usuarios?: ComissaoUsuarioUncheckedUpdateManyWithoutComissaoNestedInput
  }

  export type UsuarioUpsertWithoutAvalicoesInput = {
    update: XOR<UsuarioUpdateWithoutAvalicoesInput, UsuarioUncheckedUpdateWithoutAvalicoesInput>
    create: XOR<UsuarioCreateWithoutAvalicoesInput, UsuarioUncheckedCreateWithoutAvalicoesInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutAvalicoesInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutAvalicoesInput, UsuarioUncheckedUpdateWithoutAvalicoesInput>
  }

  export type UsuarioUpdateWithoutAvalicoesInput = {
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    numCarteirinha?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    funcao?: EnumFuncaoFieldUpdateOperationsInput | $Enums.Funcao
    credenciamento?: EnumCredenciamentoFieldUpdateOperationsInput | $Enums.Credenciamento
    numCredenciamento?: NullableIntFieldUpdateOperationsInput | number | null
    comissaoUsuarioId?: NullableIntFieldUpdateOperationsInput | number | null
    CTG?: CTGUpdateOneRequiredWithoutUsuarioNestedInput
    ComissaoUsuario?: ComissaoUsuarioUpdateOneWithoutUsuariosNestedInput
    recursos?: RecursoUpdateManyWithoutUsuarioNestedInput
    sorteioDanca?: SorteioDancaUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutAvalicoesInput = {
    idUsuario?: IntFieldUpdateOperationsInput | number
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    CTGId?: IntFieldUpdateOperationsInput | number
    numCarteirinha?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    funcao?: EnumFuncaoFieldUpdateOperationsInput | $Enums.Funcao
    credenciamento?: EnumCredenciamentoFieldUpdateOperationsInput | $Enums.Credenciamento
    numCredenciamento?: NullableIntFieldUpdateOperationsInput | number | null
    comissaoUsuarioId?: NullableIntFieldUpdateOperationsInput | number | null
    ComissaoUsuario?: ComissaoUsuarioUncheckedUpdateOneWithoutUsuariosNestedInput
    recursos?: RecursoUncheckedUpdateManyWithoutUsuarioNestedInput
    sorteioDanca?: SorteioDancaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type ProvaUpsertWithoutAvaliacaoInput = {
    update: XOR<ProvaUpdateWithoutAvaliacaoInput, ProvaUncheckedUpdateWithoutAvaliacaoInput>
    create: XOR<ProvaCreateWithoutAvaliacaoInput, ProvaUncheckedCreateWithoutAvaliacaoInput>
    where?: ProvaWhereInput
  }

  export type ProvaUpdateToOneWithWhereWithoutAvaliacaoInput = {
    where?: ProvaWhereInput
    data: XOR<ProvaUpdateWithoutAvaliacaoInput, ProvaUncheckedUpdateWithoutAvaliacaoInput>
  }

  export type ProvaUpdateWithoutAvaliacaoInput = {
    nomeProva?: StringFieldUpdateOperationsInput | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    categorias?: CategoriaUpdateManyWithoutProvaNestedInput
    ProvaTeorica?: ProvaTeoricaUpdateManyWithoutProvaNestedInput
    ProvaPratica?: ProvaPraticaUpdateManyWithoutProvaNestedInput
    recursos?: RecursoUpdateManyWithoutProvaNestedInput
  }

  export type ProvaUncheckedUpdateWithoutAvaliacaoInput = {
    idProva?: IntFieldUpdateOperationsInput | number
    nomeProva?: StringFieldUpdateOperationsInput | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    categorias?: CategoriaUncheckedUpdateManyWithoutProvaNestedInput
    ProvaTeorica?: ProvaTeoricaUncheckedUpdateManyWithoutProvaNestedInput
    ProvaPratica?: ProvaPraticaUncheckedUpdateManyWithoutProvaNestedInput
    recursos?: RecursoUncheckedUpdateManyWithoutProvaNestedInput
  }

  export type BlocoProvaUpsertWithoutAvaliacaoInput = {
    update: XOR<BlocoProvaUpdateWithoutAvaliacaoInput, BlocoProvaUncheckedUpdateWithoutAvaliacaoInput>
    create: XOR<BlocoProvaCreateWithoutAvaliacaoInput, BlocoProvaUncheckedCreateWithoutAvaliacaoInput>
    where?: BlocoProvaWhereInput
  }

  export type BlocoProvaUpdateToOneWithWhereWithoutAvaliacaoInput = {
    where?: BlocoProvaWhereInput
    data: XOR<BlocoProvaUpdateWithoutAvaliacaoInput, BlocoProvaUncheckedUpdateWithoutAvaliacaoInput>
  }

  export type BlocoProvaUpdateWithoutAvaliacaoInput = {
    nomeBloco?: StringFieldUpdateOperationsInput | string
    notaMaximaBloco?: FloatFieldUpdateOperationsInput | number
    ProvaPratica?: ProvaPraticaUpdateOneWithoutBlocosProvasNestedInput
    quesitos?: QuesitosUpdateManyWithoutBlocoProvaNestedInput
  }

  export type BlocoProvaUncheckedUpdateWithoutAvaliacaoInput = {
    idBloco?: IntFieldUpdateOperationsInput | number
    nomeBloco?: StringFieldUpdateOperationsInput | string
    notaMaximaBloco?: FloatFieldUpdateOperationsInput | number
    provaPraticaId?: NullableIntFieldUpdateOperationsInput | number | null
    quesitos?: QuesitosUncheckedUpdateManyWithoutBlocoProvaNestedInput
  }

  export type QuesitosUpsertWithWhereUniqueWithoutAvaliacaoInput = {
    where: QuesitosWhereUniqueInput
    update: XOR<QuesitosUpdateWithoutAvaliacaoInput, QuesitosUncheckedUpdateWithoutAvaliacaoInput>
    create: XOR<QuesitosCreateWithoutAvaliacaoInput, QuesitosUncheckedCreateWithoutAvaliacaoInput>
  }

  export type QuesitosUpdateWithWhereUniqueWithoutAvaliacaoInput = {
    where: QuesitosWhereUniqueInput
    data: XOR<QuesitosUpdateWithoutAvaliacaoInput, QuesitosUncheckedUpdateWithoutAvaliacaoInput>
  }

  export type QuesitosUpdateManyWithWhereWithoutAvaliacaoInput = {
    where: QuesitosScalarWhereInput
    data: XOR<QuesitosUpdateManyMutationInput, QuesitosUncheckedUpdateManyWithoutAvaliacaoInput>
  }

  export type CandidatoUpsertWithoutAvalicoesInput = {
    update: XOR<CandidatoUpdateWithoutAvalicoesInput, CandidatoUncheckedUpdateWithoutAvalicoesInput>
    create: XOR<CandidatoCreateWithoutAvalicoesInput, CandidatoUncheckedCreateWithoutAvalicoesInput>
    where?: CandidatoWhereInput
  }

  export type CandidatoUpdateToOneWithWhereWithoutAvalicoesInput = {
    where?: CandidatoWhereInput
    data: XOR<CandidatoUpdateWithoutAvalicoesInput, CandidatoUncheckedUpdateWithoutAvalicoesInput>
  }

  export type CandidatoUpdateWithoutAvalicoesInput = {
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    numCarteirinha?: StringFieldUpdateOperationsInput | string
    CPF?: StringFieldUpdateOperationsInput | string
    RG?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    numEndereco?: IntFieldUpdateOperationsInput | number
    bairro?: StringFieldUpdateOperationsInput | string
    escolaridade?: StringFieldUpdateOperationsInput | string
    filiacao?: StringFieldUpdateOperationsInput | string
    ProvaCampeiraEsportiva?: NullableEnumProvaCampeiraEsportivaFieldUpdateOperationsInput | $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoCarteirinha?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoEscolaridade?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoResidencia?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoAtaConcurso?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    fichaInscricao?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoTermoCandidato?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoRelatorioVivencia?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoResponsavel?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoProvaEsportivaCampeira?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    CTG?: CTGUpdateOneRequiredWithoutCandidatoNestedInput
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaUpdateManyWithoutCandidatoNestedInput
    Categoria?: CategoriaUpdateOneRequiredWithoutCandidatosNestedInput
    sorteioDanca?: SorteioDancaUpdateManyWithoutCandidatoNestedInput
    Recurso?: RecursoUpdateManyWithoutCandidatoNestedInput
    Concurso?: ConcursoUpdateOneWithoutCandidatosNestedInput
  }

  export type CandidatoUncheckedUpdateWithoutAvalicoesInput = {
    idCandidato?: IntFieldUpdateOperationsInput | number
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    CTGId?: IntFieldUpdateOperationsInput | number
    numCarteirinha?: StringFieldUpdateOperationsInput | string
    CPF?: StringFieldUpdateOperationsInput | string
    RG?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    numEndereco?: IntFieldUpdateOperationsInput | number
    bairro?: StringFieldUpdateOperationsInput | string
    escolaridade?: StringFieldUpdateOperationsInput | string
    filiacao?: StringFieldUpdateOperationsInput | string
    ProvaCampeiraEsportiva?: NullableEnumProvaCampeiraEsportivaFieldUpdateOperationsInput | $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoCarteirinha?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoEscolaridade?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoResidencia?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoAtaConcurso?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    fichaInscricao?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoTermoCandidato?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoRelatorioVivencia?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoResponsavel?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoProvaEsportivaCampeira?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    categoriaId?: IntFieldUpdateOperationsInput | number
    concursoIdConcurso?: NullableIntFieldUpdateOperationsInput | number | null
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaUncheckedUpdateManyWithoutCandidatoNestedInput
    sorteioDanca?: SorteioDancaUncheckedUpdateManyWithoutCandidatoNestedInput
    Recurso?: RecursoUncheckedUpdateManyWithoutCandidatoNestedInput
  }

  export type FichaCandidatoUpsertWithoutAvaliacoesInput = {
    update: XOR<FichaCandidatoUpdateWithoutAvaliacoesInput, FichaCandidatoUncheckedUpdateWithoutAvaliacoesInput>
    create: XOR<FichaCandidatoCreateWithoutAvaliacoesInput, FichaCandidatoUncheckedCreateWithoutAvaliacoesInput>
    where?: FichaCandidatoWhereInput
  }

  export type FichaCandidatoUpdateToOneWithWhereWithoutAvaliacoesInput = {
    where?: FichaCandidatoWhereInput
    data: XOR<FichaCandidatoUpdateWithoutAvaliacoesInput, FichaCandidatoUncheckedUpdateWithoutAvaliacoesInput>
  }

  export type FichaCandidatoUpdateWithoutAvaliacoesInput = {
    candidatoId?: IntFieldUpdateOperationsInput | number
    notaCandidato?: FloatFieldUpdateOperationsInput | number
    provaId?: IntFieldUpdateOperationsInput | number
    concursoId?: IntFieldUpdateOperationsInput | number
    categoriaId?: IntFieldUpdateOperationsInput | number
    anexoTermodeCiencia?: BytesFieldUpdateOperationsInput | Bytes
    dataTermo?: DateTimeFieldUpdateOperationsInput | Date | string
    numAcertosProvaTeorica?: IntFieldUpdateOperationsInput | number
    anexoGabarito?: BytesFieldUpdateOperationsInput | Bytes
    notaRedacao?: FloatFieldUpdateOperationsInput | number
    anexoRedacao?: BytesFieldUpdateOperationsInput | Bytes
    anexoProvaPratica?: BytesFieldUpdateOperationsInput | Bytes
  }

  export type FichaCandidatoUncheckedUpdateWithoutAvaliacoesInput = {
    idFicha?: IntFieldUpdateOperationsInput | number
    candidatoId?: IntFieldUpdateOperationsInput | number
    notaCandidato?: FloatFieldUpdateOperationsInput | number
    provaId?: IntFieldUpdateOperationsInput | number
    concursoId?: IntFieldUpdateOperationsInput | number
    categoriaId?: IntFieldUpdateOperationsInput | number
    anexoTermodeCiencia?: BytesFieldUpdateOperationsInput | Bytes
    dataTermo?: DateTimeFieldUpdateOperationsInput | Date | string
    numAcertosProvaTeorica?: IntFieldUpdateOperationsInput | number
    anexoGabarito?: BytesFieldUpdateOperationsInput | Bytes
    notaRedacao?: FloatFieldUpdateOperationsInput | number
    anexoRedacao?: BytesFieldUpdateOperationsInput | Bytes
    anexoProvaPratica?: BytesFieldUpdateOperationsInput | Bytes
  }

  export type CategoriaCreateWithoutProvaInput = {
    nomeCategoria: string
    escolaridade: string
    sorteioDanca: number
    idadeInicial: number
    idadeLimite?: number | null
    candidatos?: CandidatoCreateNestedManyWithoutCategoriaInput
    ProvaTeorica?: ProvaTeoricaCreateNestedOneWithoutCategoriaInput
    ProvaPratica?: ProvaPraticaCreateNestedOneWithoutCategoriaInput
  }

  export type CategoriaUncheckedCreateWithoutProvaInput = {
    idCategoria?: number
    nomeCategoria: string
    escolaridade: string
    sorteioDanca: number
    idadeInicial: number
    idadeLimite?: number | null
    provaTeoricaId?: number | null
    provaPraticaId?: number | null
    candidatos?: CandidatoUncheckedCreateNestedManyWithoutCategoriaInput
  }

  export type CategoriaCreateOrConnectWithoutProvaInput = {
    where: CategoriaWhereUniqueInput
    create: XOR<CategoriaCreateWithoutProvaInput, CategoriaUncheckedCreateWithoutProvaInput>
  }

  export type CategoriaCreateManyProvaInputEnvelope = {
    data: CategoriaCreateManyProvaInput | CategoriaCreateManyProvaInput[]
    skipDuplicates?: boolean
  }

  export type ProvaTeoricaCreateWithoutProvaInput = {
    gabaritoOficinal: Bytes
    numQuestao: number
    quesitos?: QuesitosCreateNestedManyWithoutProvaTeoricaInput
    Categoria?: CategoriaCreateNestedManyWithoutProvaTeoricaInput
    Recurso?: RecursoCreateNestedManyWithoutProvaTeoricaInput
  }

  export type ProvaTeoricaUncheckedCreateWithoutProvaInput = {
    idprovaTeorica?: number
    gabaritoOficinal: Bytes
    numQuestao: number
    quesitos?: QuesitosUncheckedCreateNestedManyWithoutProvaTeoricaInput
    Categoria?: CategoriaUncheckedCreateNestedManyWithoutProvaTeoricaInput
    Recurso?: RecursoUncheckedCreateNestedManyWithoutProvaTeoricaInput
  }

  export type ProvaTeoricaCreateOrConnectWithoutProvaInput = {
    where: ProvaTeoricaWhereUniqueInput
    create: XOR<ProvaTeoricaCreateWithoutProvaInput, ProvaTeoricaUncheckedCreateWithoutProvaInput>
  }

  export type ProvaTeoricaCreateManyProvaInputEnvelope = {
    data: ProvaTeoricaCreateManyProvaInput | ProvaTeoricaCreateManyProvaInput[]
    skipDuplicates?: boolean
  }

  export type ProvaPraticaCreateWithoutProvaInput = {
    blocosProvas?: BlocoProvaCreateNestedManyWithoutProvaPraticaInput
    Categoria?: CategoriaCreateNestedManyWithoutProvaPraticaInput
    Recurso?: RecursoCreateNestedManyWithoutProvaPraticaInput
  }

  export type ProvaPraticaUncheckedCreateWithoutProvaInput = {
    idProvaPratica?: number
    blocosProvas?: BlocoProvaUncheckedCreateNestedManyWithoutProvaPraticaInput
    Categoria?: CategoriaUncheckedCreateNestedManyWithoutProvaPraticaInput
    Recurso?: RecursoUncheckedCreateNestedManyWithoutProvaPraticaInput
  }

  export type ProvaPraticaCreateOrConnectWithoutProvaInput = {
    where: ProvaPraticaWhereUniqueInput
    create: XOR<ProvaPraticaCreateWithoutProvaInput, ProvaPraticaUncheckedCreateWithoutProvaInput>
  }

  export type ProvaPraticaCreateManyProvaInputEnvelope = {
    data: ProvaPraticaCreateManyProvaInput | ProvaPraticaCreateManyProvaInput[]
    skipDuplicates?: boolean
  }

  export type RecursoCreateWithoutProvaInput = {
    nomeRecurso: string
    justificativa: string
    status: boolean
    dataRecurso?: Date | string
    arquivos: Bytes
    Candidato: CandidatoCreateNestedOneWithoutRecursoInput
    Usuario: UsuarioCreateNestedOneWithoutRecursosInput
    Quesito: QuesitosCreateNestedOneWithoutRecursosInput
    ProvaTeorica?: ProvaTeoricaCreateNestedOneWithoutRecursoInput
    ProvaPratica?: ProvaPraticaCreateNestedOneWithoutRecursoInput
  }

  export type RecursoUncheckedCreateWithoutProvaInput = {
    idRecurso?: number
    nomeRecurso: string
    justificativa: string
    status: boolean
    dataRecurso?: Date | string
    arquivos: Bytes
    candidato: number
    avaliador: number
    quesitoRecurso: number
    provaTeoricaIdprovaTeorica?: number | null
    provaPraticaIdProvaPratica?: number | null
  }

  export type RecursoCreateOrConnectWithoutProvaInput = {
    where: RecursoWhereUniqueInput
    create: XOR<RecursoCreateWithoutProvaInput, RecursoUncheckedCreateWithoutProvaInput>
  }

  export type RecursoCreateManyProvaInputEnvelope = {
    data: RecursoCreateManyProvaInput | RecursoCreateManyProvaInput[]
    skipDuplicates?: boolean
  }

  export type AvaliacaoCreateWithoutProvaInput = {
    dataAvaliacao?: Date | string
    nota: number
    Comissao: ComissaoCreateNestedOneWithoutAvalicaoInput
    Usuario: UsuarioCreateNestedOneWithoutAvalicoesInput
    BlocoProva?: BlocoProvaCreateNestedOneWithoutAvaliacaoInput
    quesitos?: QuesitosCreateNestedManyWithoutAvaliacaoInput
    Candidato: CandidatoCreateNestedOneWithoutAvalicoesInput
    FichaCandidato?: FichaCandidatoCreateNestedOneWithoutAvaliacoesInput
  }

  export type AvaliacaoUncheckedCreateWithoutProvaInput = {
    idAvalicao?: number
    dataAvaliacao?: Date | string
    comissaoId: number
    avaliadorId: number
    blocoProvaId?: number | null
    nota: number
    candidatoId: number
    fichaCandidatoIdFicha?: number | null
    quesitos?: QuesitosUncheckedCreateNestedManyWithoutAvaliacaoInput
  }

  export type AvaliacaoCreateOrConnectWithoutProvaInput = {
    where: AvaliacaoWhereUniqueInput
    create: XOR<AvaliacaoCreateWithoutProvaInput, AvaliacaoUncheckedCreateWithoutProvaInput>
  }

  export type AvaliacaoCreateManyProvaInputEnvelope = {
    data: AvaliacaoCreateManyProvaInput | AvaliacaoCreateManyProvaInput[]
    skipDuplicates?: boolean
  }

  export type CategoriaUpsertWithWhereUniqueWithoutProvaInput = {
    where: CategoriaWhereUniqueInput
    update: XOR<CategoriaUpdateWithoutProvaInput, CategoriaUncheckedUpdateWithoutProvaInput>
    create: XOR<CategoriaCreateWithoutProvaInput, CategoriaUncheckedCreateWithoutProvaInput>
  }

  export type CategoriaUpdateWithWhereUniqueWithoutProvaInput = {
    where: CategoriaWhereUniqueInput
    data: XOR<CategoriaUpdateWithoutProvaInput, CategoriaUncheckedUpdateWithoutProvaInput>
  }

  export type CategoriaUpdateManyWithWhereWithoutProvaInput = {
    where: CategoriaScalarWhereInput
    data: XOR<CategoriaUpdateManyMutationInput, CategoriaUncheckedUpdateManyWithoutProvaInput>
  }

  export type CategoriaScalarWhereInput = {
    AND?: CategoriaScalarWhereInput | CategoriaScalarWhereInput[]
    OR?: CategoriaScalarWhereInput[]
    NOT?: CategoriaScalarWhereInput | CategoriaScalarWhereInput[]
    idCategoria?: IntFilter<"Categoria"> | number
    nomeCategoria?: StringFilter<"Categoria"> | string
    escolaridade?: StringFilter<"Categoria"> | string
    sorteioDanca?: IntFilter<"Categoria"> | number
    idadeInicial?: IntFilter<"Categoria"> | number
    idadeLimite?: IntNullableFilter<"Categoria"> | number | null
    provaId?: IntNullableFilter<"Categoria"> | number | null
    provaTeoricaId?: IntNullableFilter<"Categoria"> | number | null
    provaPraticaId?: IntNullableFilter<"Categoria"> | number | null
  }

  export type ProvaTeoricaUpsertWithWhereUniqueWithoutProvaInput = {
    where: ProvaTeoricaWhereUniqueInput
    update: XOR<ProvaTeoricaUpdateWithoutProvaInput, ProvaTeoricaUncheckedUpdateWithoutProvaInput>
    create: XOR<ProvaTeoricaCreateWithoutProvaInput, ProvaTeoricaUncheckedCreateWithoutProvaInput>
  }

  export type ProvaTeoricaUpdateWithWhereUniqueWithoutProvaInput = {
    where: ProvaTeoricaWhereUniqueInput
    data: XOR<ProvaTeoricaUpdateWithoutProvaInput, ProvaTeoricaUncheckedUpdateWithoutProvaInput>
  }

  export type ProvaTeoricaUpdateManyWithWhereWithoutProvaInput = {
    where: ProvaTeoricaScalarWhereInput
    data: XOR<ProvaTeoricaUpdateManyMutationInput, ProvaTeoricaUncheckedUpdateManyWithoutProvaInput>
  }

  export type ProvaTeoricaScalarWhereInput = {
    AND?: ProvaTeoricaScalarWhereInput | ProvaTeoricaScalarWhereInput[]
    OR?: ProvaTeoricaScalarWhereInput[]
    NOT?: ProvaTeoricaScalarWhereInput | ProvaTeoricaScalarWhereInput[]
    idprovaTeorica?: IntFilter<"ProvaTeorica"> | number
    provaId?: IntNullableFilter<"ProvaTeorica"> | number | null
    gabaritoOficinal?: BytesFilter<"ProvaTeorica"> | Bytes
    numQuestao?: IntFilter<"ProvaTeorica"> | number
  }

  export type ProvaPraticaUpsertWithWhereUniqueWithoutProvaInput = {
    where: ProvaPraticaWhereUniqueInput
    update: XOR<ProvaPraticaUpdateWithoutProvaInput, ProvaPraticaUncheckedUpdateWithoutProvaInput>
    create: XOR<ProvaPraticaCreateWithoutProvaInput, ProvaPraticaUncheckedCreateWithoutProvaInput>
  }

  export type ProvaPraticaUpdateWithWhereUniqueWithoutProvaInput = {
    where: ProvaPraticaWhereUniqueInput
    data: XOR<ProvaPraticaUpdateWithoutProvaInput, ProvaPraticaUncheckedUpdateWithoutProvaInput>
  }

  export type ProvaPraticaUpdateManyWithWhereWithoutProvaInput = {
    where: ProvaPraticaScalarWhereInput
    data: XOR<ProvaPraticaUpdateManyMutationInput, ProvaPraticaUncheckedUpdateManyWithoutProvaInput>
  }

  export type ProvaPraticaScalarWhereInput = {
    AND?: ProvaPraticaScalarWhereInput | ProvaPraticaScalarWhereInput[]
    OR?: ProvaPraticaScalarWhereInput[]
    NOT?: ProvaPraticaScalarWhereInput | ProvaPraticaScalarWhereInput[]
    idProvaPratica?: IntFilter<"ProvaPratica"> | number
    provaId?: IntNullableFilter<"ProvaPratica"> | number | null
  }

  export type RecursoUpsertWithWhereUniqueWithoutProvaInput = {
    where: RecursoWhereUniqueInput
    update: XOR<RecursoUpdateWithoutProvaInput, RecursoUncheckedUpdateWithoutProvaInput>
    create: XOR<RecursoCreateWithoutProvaInput, RecursoUncheckedCreateWithoutProvaInput>
  }

  export type RecursoUpdateWithWhereUniqueWithoutProvaInput = {
    where: RecursoWhereUniqueInput
    data: XOR<RecursoUpdateWithoutProvaInput, RecursoUncheckedUpdateWithoutProvaInput>
  }

  export type RecursoUpdateManyWithWhereWithoutProvaInput = {
    where: RecursoScalarWhereInput
    data: XOR<RecursoUpdateManyMutationInput, RecursoUncheckedUpdateManyWithoutProvaInput>
  }

  export type AvaliacaoUpsertWithWhereUniqueWithoutProvaInput = {
    where: AvaliacaoWhereUniqueInput
    update: XOR<AvaliacaoUpdateWithoutProvaInput, AvaliacaoUncheckedUpdateWithoutProvaInput>
    create: XOR<AvaliacaoCreateWithoutProvaInput, AvaliacaoUncheckedCreateWithoutProvaInput>
  }

  export type AvaliacaoUpdateWithWhereUniqueWithoutProvaInput = {
    where: AvaliacaoWhereUniqueInput
    data: XOR<AvaliacaoUpdateWithoutProvaInput, AvaliacaoUncheckedUpdateWithoutProvaInput>
  }

  export type AvaliacaoUpdateManyWithWhereWithoutProvaInput = {
    where: AvaliacaoScalarWhereInput
    data: XOR<AvaliacaoUpdateManyMutationInput, AvaliacaoUncheckedUpdateManyWithoutProvaInput>
  }

  export type ProvaCreateWithoutProvaTeoricaInput = {
    nomeProva: string
    notaMaxima: number
    categorias?: CategoriaCreateNestedManyWithoutProvaInput
    ProvaPratica?: ProvaPraticaCreateNestedManyWithoutProvaInput
    recursos?: RecursoCreateNestedManyWithoutProvaInput
    Avaliacao?: AvaliacaoCreateNestedManyWithoutProvaInput
  }

  export type ProvaUncheckedCreateWithoutProvaTeoricaInput = {
    idProva?: number
    nomeProva: string
    notaMaxima: number
    categorias?: CategoriaUncheckedCreateNestedManyWithoutProvaInput
    ProvaPratica?: ProvaPraticaUncheckedCreateNestedManyWithoutProvaInput
    recursos?: RecursoUncheckedCreateNestedManyWithoutProvaInput
    Avaliacao?: AvaliacaoUncheckedCreateNestedManyWithoutProvaInput
  }

  export type ProvaCreateOrConnectWithoutProvaTeoricaInput = {
    where: ProvaWhereUniqueInput
    create: XOR<ProvaCreateWithoutProvaTeoricaInput, ProvaUncheckedCreateWithoutProvaTeoricaInput>
  }

  export type QuesitosCreateWithoutProvaTeoricaInput = {
    nomeQuesito: string
    notaMaximaQuesito: number
    danca: boolean
    dancaSalaoTradicional: $Enums.DancaSalaoTradicional
    BlocoProva?: BlocoProvaCreateNestedOneWithoutQuesitosInput
    subeQuesitos?: SubQuesitosCreateNestedManyWithoutQuesitoInput
    recursos?: RecursoCreateNestedManyWithoutQuesitoInput
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaCreateNestedOneWithoutQuesitosInput
    Avaliacao?: AvaliacaoCreateNestedOneWithoutQuesitosInput
  }

  export type QuesitosUncheckedCreateWithoutProvaTeoricaInput = {
    idQuesito?: number
    nomeQuesito: string
    notaMaximaQuesito: number
    danca: boolean
    dancaSalaoTradicional: $Enums.DancaSalaoTradicional
    blocoProvaIdBloco?: number | null
    preferenciaSorteioDancaId?: number | null
    avaliacaoIdAvalicao?: number | null
    subeQuesitos?: SubQuesitosUncheckedCreateNestedManyWithoutQuesitoInput
    recursos?: RecursoUncheckedCreateNestedManyWithoutQuesitoInput
  }

  export type QuesitosCreateOrConnectWithoutProvaTeoricaInput = {
    where: QuesitosWhereUniqueInput
    create: XOR<QuesitosCreateWithoutProvaTeoricaInput, QuesitosUncheckedCreateWithoutProvaTeoricaInput>
  }

  export type QuesitosCreateManyProvaTeoricaInputEnvelope = {
    data: QuesitosCreateManyProvaTeoricaInput | QuesitosCreateManyProvaTeoricaInput[]
    skipDuplicates?: boolean
  }

  export type CategoriaCreateWithoutProvaTeoricaInput = {
    nomeCategoria: string
    escolaridade: string
    sorteioDanca: number
    idadeInicial: number
    idadeLimite?: number | null
    candidatos?: CandidatoCreateNestedManyWithoutCategoriaInput
    Prova?: ProvaCreateNestedOneWithoutCategoriasInput
    ProvaPratica?: ProvaPraticaCreateNestedOneWithoutCategoriaInput
  }

  export type CategoriaUncheckedCreateWithoutProvaTeoricaInput = {
    idCategoria?: number
    nomeCategoria: string
    escolaridade: string
    sorteioDanca: number
    idadeInicial: number
    idadeLimite?: number | null
    provaId?: number | null
    provaPraticaId?: number | null
    candidatos?: CandidatoUncheckedCreateNestedManyWithoutCategoriaInput
  }

  export type CategoriaCreateOrConnectWithoutProvaTeoricaInput = {
    where: CategoriaWhereUniqueInput
    create: XOR<CategoriaCreateWithoutProvaTeoricaInput, CategoriaUncheckedCreateWithoutProvaTeoricaInput>
  }

  export type CategoriaCreateManyProvaTeoricaInputEnvelope = {
    data: CategoriaCreateManyProvaTeoricaInput | CategoriaCreateManyProvaTeoricaInput[]
    skipDuplicates?: boolean
  }

  export type RecursoCreateWithoutProvaTeoricaInput = {
    nomeRecurso: string
    justificativa: string
    status: boolean
    dataRecurso?: Date | string
    arquivos: Bytes
    Candidato: CandidatoCreateNestedOneWithoutRecursoInput
    Usuario: UsuarioCreateNestedOneWithoutRecursosInput
    Quesito: QuesitosCreateNestedOneWithoutRecursosInput
    ProvaPratica?: ProvaPraticaCreateNestedOneWithoutRecursoInput
    Prova?: ProvaCreateNestedOneWithoutRecursosInput
  }

  export type RecursoUncheckedCreateWithoutProvaTeoricaInput = {
    idRecurso?: number
    nomeRecurso: string
    justificativa: string
    status: boolean
    dataRecurso?: Date | string
    arquivos: Bytes
    candidato: number
    avaliador: number
    quesitoRecurso: number
    provaPraticaIdProvaPratica?: number | null
    provaIdProva?: number | null
  }

  export type RecursoCreateOrConnectWithoutProvaTeoricaInput = {
    where: RecursoWhereUniqueInput
    create: XOR<RecursoCreateWithoutProvaTeoricaInput, RecursoUncheckedCreateWithoutProvaTeoricaInput>
  }

  export type RecursoCreateManyProvaTeoricaInputEnvelope = {
    data: RecursoCreateManyProvaTeoricaInput | RecursoCreateManyProvaTeoricaInput[]
    skipDuplicates?: boolean
  }

  export type ProvaUpsertWithoutProvaTeoricaInput = {
    update: XOR<ProvaUpdateWithoutProvaTeoricaInput, ProvaUncheckedUpdateWithoutProvaTeoricaInput>
    create: XOR<ProvaCreateWithoutProvaTeoricaInput, ProvaUncheckedCreateWithoutProvaTeoricaInput>
    where?: ProvaWhereInput
  }

  export type ProvaUpdateToOneWithWhereWithoutProvaTeoricaInput = {
    where?: ProvaWhereInput
    data: XOR<ProvaUpdateWithoutProvaTeoricaInput, ProvaUncheckedUpdateWithoutProvaTeoricaInput>
  }

  export type ProvaUpdateWithoutProvaTeoricaInput = {
    nomeProva?: StringFieldUpdateOperationsInput | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    categorias?: CategoriaUpdateManyWithoutProvaNestedInput
    ProvaPratica?: ProvaPraticaUpdateManyWithoutProvaNestedInput
    recursos?: RecursoUpdateManyWithoutProvaNestedInput
    Avaliacao?: AvaliacaoUpdateManyWithoutProvaNestedInput
  }

  export type ProvaUncheckedUpdateWithoutProvaTeoricaInput = {
    idProva?: IntFieldUpdateOperationsInput | number
    nomeProva?: StringFieldUpdateOperationsInput | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    categorias?: CategoriaUncheckedUpdateManyWithoutProvaNestedInput
    ProvaPratica?: ProvaPraticaUncheckedUpdateManyWithoutProvaNestedInput
    recursos?: RecursoUncheckedUpdateManyWithoutProvaNestedInput
    Avaliacao?: AvaliacaoUncheckedUpdateManyWithoutProvaNestedInput
  }

  export type QuesitosUpsertWithWhereUniqueWithoutProvaTeoricaInput = {
    where: QuesitosWhereUniqueInput
    update: XOR<QuesitosUpdateWithoutProvaTeoricaInput, QuesitosUncheckedUpdateWithoutProvaTeoricaInput>
    create: XOR<QuesitosCreateWithoutProvaTeoricaInput, QuesitosUncheckedCreateWithoutProvaTeoricaInput>
  }

  export type QuesitosUpdateWithWhereUniqueWithoutProvaTeoricaInput = {
    where: QuesitosWhereUniqueInput
    data: XOR<QuesitosUpdateWithoutProvaTeoricaInput, QuesitosUncheckedUpdateWithoutProvaTeoricaInput>
  }

  export type QuesitosUpdateManyWithWhereWithoutProvaTeoricaInput = {
    where: QuesitosScalarWhereInput
    data: XOR<QuesitosUpdateManyMutationInput, QuesitosUncheckedUpdateManyWithoutProvaTeoricaInput>
  }

  export type CategoriaUpsertWithWhereUniqueWithoutProvaTeoricaInput = {
    where: CategoriaWhereUniqueInput
    update: XOR<CategoriaUpdateWithoutProvaTeoricaInput, CategoriaUncheckedUpdateWithoutProvaTeoricaInput>
    create: XOR<CategoriaCreateWithoutProvaTeoricaInput, CategoriaUncheckedCreateWithoutProvaTeoricaInput>
  }

  export type CategoriaUpdateWithWhereUniqueWithoutProvaTeoricaInput = {
    where: CategoriaWhereUniqueInput
    data: XOR<CategoriaUpdateWithoutProvaTeoricaInput, CategoriaUncheckedUpdateWithoutProvaTeoricaInput>
  }

  export type CategoriaUpdateManyWithWhereWithoutProvaTeoricaInput = {
    where: CategoriaScalarWhereInput
    data: XOR<CategoriaUpdateManyMutationInput, CategoriaUncheckedUpdateManyWithoutProvaTeoricaInput>
  }

  export type RecursoUpsertWithWhereUniqueWithoutProvaTeoricaInput = {
    where: RecursoWhereUniqueInput
    update: XOR<RecursoUpdateWithoutProvaTeoricaInput, RecursoUncheckedUpdateWithoutProvaTeoricaInput>
    create: XOR<RecursoCreateWithoutProvaTeoricaInput, RecursoUncheckedCreateWithoutProvaTeoricaInput>
  }

  export type RecursoUpdateWithWhereUniqueWithoutProvaTeoricaInput = {
    where: RecursoWhereUniqueInput
    data: XOR<RecursoUpdateWithoutProvaTeoricaInput, RecursoUncheckedUpdateWithoutProvaTeoricaInput>
  }

  export type RecursoUpdateManyWithWhereWithoutProvaTeoricaInput = {
    where: RecursoScalarWhereInput
    data: XOR<RecursoUpdateManyMutationInput, RecursoUncheckedUpdateManyWithoutProvaTeoricaInput>
  }

  export type ProvaCreateWithoutProvaPraticaInput = {
    nomeProva: string
    notaMaxima: number
    categorias?: CategoriaCreateNestedManyWithoutProvaInput
    ProvaTeorica?: ProvaTeoricaCreateNestedManyWithoutProvaInput
    recursos?: RecursoCreateNestedManyWithoutProvaInput
    Avaliacao?: AvaliacaoCreateNestedManyWithoutProvaInput
  }

  export type ProvaUncheckedCreateWithoutProvaPraticaInput = {
    idProva?: number
    nomeProva: string
    notaMaxima: number
    categorias?: CategoriaUncheckedCreateNestedManyWithoutProvaInput
    ProvaTeorica?: ProvaTeoricaUncheckedCreateNestedManyWithoutProvaInput
    recursos?: RecursoUncheckedCreateNestedManyWithoutProvaInput
    Avaliacao?: AvaliacaoUncheckedCreateNestedManyWithoutProvaInput
  }

  export type ProvaCreateOrConnectWithoutProvaPraticaInput = {
    where: ProvaWhereUniqueInput
    create: XOR<ProvaCreateWithoutProvaPraticaInput, ProvaUncheckedCreateWithoutProvaPraticaInput>
  }

  export type BlocoProvaCreateWithoutProvaPraticaInput = {
    nomeBloco: string
    notaMaximaBloco: number
    quesitos?: QuesitosCreateNestedManyWithoutBlocoProvaInput
    Avaliacao?: AvaliacaoCreateNestedManyWithoutBlocoProvaInput
  }

  export type BlocoProvaUncheckedCreateWithoutProvaPraticaInput = {
    idBloco?: number
    nomeBloco: string
    notaMaximaBloco: number
    quesitos?: QuesitosUncheckedCreateNestedManyWithoutBlocoProvaInput
    Avaliacao?: AvaliacaoUncheckedCreateNestedManyWithoutBlocoProvaInput
  }

  export type BlocoProvaCreateOrConnectWithoutProvaPraticaInput = {
    where: BlocoProvaWhereUniqueInput
    create: XOR<BlocoProvaCreateWithoutProvaPraticaInput, BlocoProvaUncheckedCreateWithoutProvaPraticaInput>
  }

  export type BlocoProvaCreateManyProvaPraticaInputEnvelope = {
    data: BlocoProvaCreateManyProvaPraticaInput | BlocoProvaCreateManyProvaPraticaInput[]
    skipDuplicates?: boolean
  }

  export type CategoriaCreateWithoutProvaPraticaInput = {
    nomeCategoria: string
    escolaridade: string
    sorteioDanca: number
    idadeInicial: number
    idadeLimite?: number | null
    candidatos?: CandidatoCreateNestedManyWithoutCategoriaInput
    Prova?: ProvaCreateNestedOneWithoutCategoriasInput
    ProvaTeorica?: ProvaTeoricaCreateNestedOneWithoutCategoriaInput
  }

  export type CategoriaUncheckedCreateWithoutProvaPraticaInput = {
    idCategoria?: number
    nomeCategoria: string
    escolaridade: string
    sorteioDanca: number
    idadeInicial: number
    idadeLimite?: number | null
    provaId?: number | null
    provaTeoricaId?: number | null
    candidatos?: CandidatoUncheckedCreateNestedManyWithoutCategoriaInput
  }

  export type CategoriaCreateOrConnectWithoutProvaPraticaInput = {
    where: CategoriaWhereUniqueInput
    create: XOR<CategoriaCreateWithoutProvaPraticaInput, CategoriaUncheckedCreateWithoutProvaPraticaInput>
  }

  export type CategoriaCreateManyProvaPraticaInputEnvelope = {
    data: CategoriaCreateManyProvaPraticaInput | CategoriaCreateManyProvaPraticaInput[]
    skipDuplicates?: boolean
  }

  export type RecursoCreateWithoutProvaPraticaInput = {
    nomeRecurso: string
    justificativa: string
    status: boolean
    dataRecurso?: Date | string
    arquivos: Bytes
    Candidato: CandidatoCreateNestedOneWithoutRecursoInput
    Usuario: UsuarioCreateNestedOneWithoutRecursosInput
    Quesito: QuesitosCreateNestedOneWithoutRecursosInput
    ProvaTeorica?: ProvaTeoricaCreateNestedOneWithoutRecursoInput
    Prova?: ProvaCreateNestedOneWithoutRecursosInput
  }

  export type RecursoUncheckedCreateWithoutProvaPraticaInput = {
    idRecurso?: number
    nomeRecurso: string
    justificativa: string
    status: boolean
    dataRecurso?: Date | string
    arquivos: Bytes
    candidato: number
    avaliador: number
    quesitoRecurso: number
    provaTeoricaIdprovaTeorica?: number | null
    provaIdProva?: number | null
  }

  export type RecursoCreateOrConnectWithoutProvaPraticaInput = {
    where: RecursoWhereUniqueInput
    create: XOR<RecursoCreateWithoutProvaPraticaInput, RecursoUncheckedCreateWithoutProvaPraticaInput>
  }

  export type RecursoCreateManyProvaPraticaInputEnvelope = {
    data: RecursoCreateManyProvaPraticaInput | RecursoCreateManyProvaPraticaInput[]
    skipDuplicates?: boolean
  }

  export type ProvaUpsertWithoutProvaPraticaInput = {
    update: XOR<ProvaUpdateWithoutProvaPraticaInput, ProvaUncheckedUpdateWithoutProvaPraticaInput>
    create: XOR<ProvaCreateWithoutProvaPraticaInput, ProvaUncheckedCreateWithoutProvaPraticaInput>
    where?: ProvaWhereInput
  }

  export type ProvaUpdateToOneWithWhereWithoutProvaPraticaInput = {
    where?: ProvaWhereInput
    data: XOR<ProvaUpdateWithoutProvaPraticaInput, ProvaUncheckedUpdateWithoutProvaPraticaInput>
  }

  export type ProvaUpdateWithoutProvaPraticaInput = {
    nomeProva?: StringFieldUpdateOperationsInput | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    categorias?: CategoriaUpdateManyWithoutProvaNestedInput
    ProvaTeorica?: ProvaTeoricaUpdateManyWithoutProvaNestedInput
    recursos?: RecursoUpdateManyWithoutProvaNestedInput
    Avaliacao?: AvaliacaoUpdateManyWithoutProvaNestedInput
  }

  export type ProvaUncheckedUpdateWithoutProvaPraticaInput = {
    idProva?: IntFieldUpdateOperationsInput | number
    nomeProva?: StringFieldUpdateOperationsInput | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    categorias?: CategoriaUncheckedUpdateManyWithoutProvaNestedInput
    ProvaTeorica?: ProvaTeoricaUncheckedUpdateManyWithoutProvaNestedInput
    recursos?: RecursoUncheckedUpdateManyWithoutProvaNestedInput
    Avaliacao?: AvaliacaoUncheckedUpdateManyWithoutProvaNestedInput
  }

  export type BlocoProvaUpsertWithWhereUniqueWithoutProvaPraticaInput = {
    where: BlocoProvaWhereUniqueInput
    update: XOR<BlocoProvaUpdateWithoutProvaPraticaInput, BlocoProvaUncheckedUpdateWithoutProvaPraticaInput>
    create: XOR<BlocoProvaCreateWithoutProvaPraticaInput, BlocoProvaUncheckedCreateWithoutProvaPraticaInput>
  }

  export type BlocoProvaUpdateWithWhereUniqueWithoutProvaPraticaInput = {
    where: BlocoProvaWhereUniqueInput
    data: XOR<BlocoProvaUpdateWithoutProvaPraticaInput, BlocoProvaUncheckedUpdateWithoutProvaPraticaInput>
  }

  export type BlocoProvaUpdateManyWithWhereWithoutProvaPraticaInput = {
    where: BlocoProvaScalarWhereInput
    data: XOR<BlocoProvaUpdateManyMutationInput, BlocoProvaUncheckedUpdateManyWithoutProvaPraticaInput>
  }

  export type BlocoProvaScalarWhereInput = {
    AND?: BlocoProvaScalarWhereInput | BlocoProvaScalarWhereInput[]
    OR?: BlocoProvaScalarWhereInput[]
    NOT?: BlocoProvaScalarWhereInput | BlocoProvaScalarWhereInput[]
    idBloco?: IntFilter<"BlocoProva"> | number
    nomeBloco?: StringFilter<"BlocoProva"> | string
    notaMaximaBloco?: FloatFilter<"BlocoProva"> | number
    provaPraticaId?: IntNullableFilter<"BlocoProva"> | number | null
  }

  export type CategoriaUpsertWithWhereUniqueWithoutProvaPraticaInput = {
    where: CategoriaWhereUniqueInput
    update: XOR<CategoriaUpdateWithoutProvaPraticaInput, CategoriaUncheckedUpdateWithoutProvaPraticaInput>
    create: XOR<CategoriaCreateWithoutProvaPraticaInput, CategoriaUncheckedCreateWithoutProvaPraticaInput>
  }

  export type CategoriaUpdateWithWhereUniqueWithoutProvaPraticaInput = {
    where: CategoriaWhereUniqueInput
    data: XOR<CategoriaUpdateWithoutProvaPraticaInput, CategoriaUncheckedUpdateWithoutProvaPraticaInput>
  }

  export type CategoriaUpdateManyWithWhereWithoutProvaPraticaInput = {
    where: CategoriaScalarWhereInput
    data: XOR<CategoriaUpdateManyMutationInput, CategoriaUncheckedUpdateManyWithoutProvaPraticaInput>
  }

  export type RecursoUpsertWithWhereUniqueWithoutProvaPraticaInput = {
    where: RecursoWhereUniqueInput
    update: XOR<RecursoUpdateWithoutProvaPraticaInput, RecursoUncheckedUpdateWithoutProvaPraticaInput>
    create: XOR<RecursoCreateWithoutProvaPraticaInput, RecursoUncheckedCreateWithoutProvaPraticaInput>
  }

  export type RecursoUpdateWithWhereUniqueWithoutProvaPraticaInput = {
    where: RecursoWhereUniqueInput
    data: XOR<RecursoUpdateWithoutProvaPraticaInput, RecursoUncheckedUpdateWithoutProvaPraticaInput>
  }

  export type RecursoUpdateManyWithWhereWithoutProvaPraticaInput = {
    where: RecursoScalarWhereInput
    data: XOR<RecursoUpdateManyMutationInput, RecursoUncheckedUpdateManyWithoutProvaPraticaInput>
  }

  export type ProvaPraticaCreateWithoutBlocosProvasInput = {
    prova?: ProvaCreateNestedOneWithoutProvaPraticaInput
    Categoria?: CategoriaCreateNestedManyWithoutProvaPraticaInput
    Recurso?: RecursoCreateNestedManyWithoutProvaPraticaInput
  }

  export type ProvaPraticaUncheckedCreateWithoutBlocosProvasInput = {
    idProvaPratica?: number
    provaId?: number | null
    Categoria?: CategoriaUncheckedCreateNestedManyWithoutProvaPraticaInput
    Recurso?: RecursoUncheckedCreateNestedManyWithoutProvaPraticaInput
  }

  export type ProvaPraticaCreateOrConnectWithoutBlocosProvasInput = {
    where: ProvaPraticaWhereUniqueInput
    create: XOR<ProvaPraticaCreateWithoutBlocosProvasInput, ProvaPraticaUncheckedCreateWithoutBlocosProvasInput>
  }

  export type QuesitosCreateWithoutBlocoProvaInput = {
    nomeQuesito: string
    notaMaximaQuesito: number
    danca: boolean
    dancaSalaoTradicional: $Enums.DancaSalaoTradicional
    ProvaTeorica?: ProvaTeoricaCreateNestedOneWithoutQuesitosInput
    subeQuesitos?: SubQuesitosCreateNestedManyWithoutQuesitoInput
    recursos?: RecursoCreateNestedManyWithoutQuesitoInput
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaCreateNestedOneWithoutQuesitosInput
    Avaliacao?: AvaliacaoCreateNestedOneWithoutQuesitosInput
  }

  export type QuesitosUncheckedCreateWithoutBlocoProvaInput = {
    idQuesito?: number
    nomeQuesito: string
    notaMaximaQuesito: number
    danca: boolean
    dancaSalaoTradicional: $Enums.DancaSalaoTradicional
    provaTeoricaIdprovaTeorica?: number | null
    preferenciaSorteioDancaId?: number | null
    avaliacaoIdAvalicao?: number | null
    subeQuesitos?: SubQuesitosUncheckedCreateNestedManyWithoutQuesitoInput
    recursos?: RecursoUncheckedCreateNestedManyWithoutQuesitoInput
  }

  export type QuesitosCreateOrConnectWithoutBlocoProvaInput = {
    where: QuesitosWhereUniqueInput
    create: XOR<QuesitosCreateWithoutBlocoProvaInput, QuesitosUncheckedCreateWithoutBlocoProvaInput>
  }

  export type QuesitosCreateManyBlocoProvaInputEnvelope = {
    data: QuesitosCreateManyBlocoProvaInput | QuesitosCreateManyBlocoProvaInput[]
    skipDuplicates?: boolean
  }

  export type AvaliacaoCreateWithoutBlocoProvaInput = {
    dataAvaliacao?: Date | string
    nota: number
    Comissao: ComissaoCreateNestedOneWithoutAvalicaoInput
    Usuario: UsuarioCreateNestedOneWithoutAvalicoesInput
    Prova?: ProvaCreateNestedOneWithoutAvaliacaoInput
    quesitos?: QuesitosCreateNestedManyWithoutAvaliacaoInput
    Candidato: CandidatoCreateNestedOneWithoutAvalicoesInput
    FichaCandidato?: FichaCandidatoCreateNestedOneWithoutAvaliacoesInput
  }

  export type AvaliacaoUncheckedCreateWithoutBlocoProvaInput = {
    idAvalicao?: number
    dataAvaliacao?: Date | string
    comissaoId: number
    avaliadorId: number
    provaId: number
    nota: number
    candidatoId: number
    fichaCandidatoIdFicha?: number | null
    quesitos?: QuesitosUncheckedCreateNestedManyWithoutAvaliacaoInput
  }

  export type AvaliacaoCreateOrConnectWithoutBlocoProvaInput = {
    where: AvaliacaoWhereUniqueInput
    create: XOR<AvaliacaoCreateWithoutBlocoProvaInput, AvaliacaoUncheckedCreateWithoutBlocoProvaInput>
  }

  export type AvaliacaoCreateManyBlocoProvaInputEnvelope = {
    data: AvaliacaoCreateManyBlocoProvaInput | AvaliacaoCreateManyBlocoProvaInput[]
    skipDuplicates?: boolean
  }

  export type ProvaPraticaUpsertWithoutBlocosProvasInput = {
    update: XOR<ProvaPraticaUpdateWithoutBlocosProvasInput, ProvaPraticaUncheckedUpdateWithoutBlocosProvasInput>
    create: XOR<ProvaPraticaCreateWithoutBlocosProvasInput, ProvaPraticaUncheckedCreateWithoutBlocosProvasInput>
    where?: ProvaPraticaWhereInput
  }

  export type ProvaPraticaUpdateToOneWithWhereWithoutBlocosProvasInput = {
    where?: ProvaPraticaWhereInput
    data: XOR<ProvaPraticaUpdateWithoutBlocosProvasInput, ProvaPraticaUncheckedUpdateWithoutBlocosProvasInput>
  }

  export type ProvaPraticaUpdateWithoutBlocosProvasInput = {
    prova?: ProvaUpdateOneWithoutProvaPraticaNestedInput
    Categoria?: CategoriaUpdateManyWithoutProvaPraticaNestedInput
    Recurso?: RecursoUpdateManyWithoutProvaPraticaNestedInput
  }

  export type ProvaPraticaUncheckedUpdateWithoutBlocosProvasInput = {
    idProvaPratica?: IntFieldUpdateOperationsInput | number
    provaId?: NullableIntFieldUpdateOperationsInput | number | null
    Categoria?: CategoriaUncheckedUpdateManyWithoutProvaPraticaNestedInput
    Recurso?: RecursoUncheckedUpdateManyWithoutProvaPraticaNestedInput
  }

  export type QuesitosUpsertWithWhereUniqueWithoutBlocoProvaInput = {
    where: QuesitosWhereUniqueInput
    update: XOR<QuesitosUpdateWithoutBlocoProvaInput, QuesitosUncheckedUpdateWithoutBlocoProvaInput>
    create: XOR<QuesitosCreateWithoutBlocoProvaInput, QuesitosUncheckedCreateWithoutBlocoProvaInput>
  }

  export type QuesitosUpdateWithWhereUniqueWithoutBlocoProvaInput = {
    where: QuesitosWhereUniqueInput
    data: XOR<QuesitosUpdateWithoutBlocoProvaInput, QuesitosUncheckedUpdateWithoutBlocoProvaInput>
  }

  export type QuesitosUpdateManyWithWhereWithoutBlocoProvaInput = {
    where: QuesitosScalarWhereInput
    data: XOR<QuesitosUpdateManyMutationInput, QuesitosUncheckedUpdateManyWithoutBlocoProvaInput>
  }

  export type AvaliacaoUpsertWithWhereUniqueWithoutBlocoProvaInput = {
    where: AvaliacaoWhereUniqueInput
    update: XOR<AvaliacaoUpdateWithoutBlocoProvaInput, AvaliacaoUncheckedUpdateWithoutBlocoProvaInput>
    create: XOR<AvaliacaoCreateWithoutBlocoProvaInput, AvaliacaoUncheckedCreateWithoutBlocoProvaInput>
  }

  export type AvaliacaoUpdateWithWhereUniqueWithoutBlocoProvaInput = {
    where: AvaliacaoWhereUniqueInput
    data: XOR<AvaliacaoUpdateWithoutBlocoProvaInput, AvaliacaoUncheckedUpdateWithoutBlocoProvaInput>
  }

  export type AvaliacaoUpdateManyWithWhereWithoutBlocoProvaInput = {
    where: AvaliacaoScalarWhereInput
    data: XOR<AvaliacaoUpdateManyMutationInput, AvaliacaoUncheckedUpdateManyWithoutBlocoProvaInput>
  }

  export type BlocoProvaCreateWithoutQuesitosInput = {
    nomeBloco: string
    notaMaximaBloco: number
    ProvaPratica?: ProvaPraticaCreateNestedOneWithoutBlocosProvasInput
    Avaliacao?: AvaliacaoCreateNestedManyWithoutBlocoProvaInput
  }

  export type BlocoProvaUncheckedCreateWithoutQuesitosInput = {
    idBloco?: number
    nomeBloco: string
    notaMaximaBloco: number
    provaPraticaId?: number | null
    Avaliacao?: AvaliacaoUncheckedCreateNestedManyWithoutBlocoProvaInput
  }

  export type BlocoProvaCreateOrConnectWithoutQuesitosInput = {
    where: BlocoProvaWhereUniqueInput
    create: XOR<BlocoProvaCreateWithoutQuesitosInput, BlocoProvaUncheckedCreateWithoutQuesitosInput>
  }

  export type ProvaTeoricaCreateWithoutQuesitosInput = {
    gabaritoOficinal: Bytes
    numQuestao: number
    Prova?: ProvaCreateNestedOneWithoutProvaTeoricaInput
    Categoria?: CategoriaCreateNestedManyWithoutProvaTeoricaInput
    Recurso?: RecursoCreateNestedManyWithoutProvaTeoricaInput
  }

  export type ProvaTeoricaUncheckedCreateWithoutQuesitosInput = {
    idprovaTeorica?: number
    provaId?: number | null
    gabaritoOficinal: Bytes
    numQuestao: number
    Categoria?: CategoriaUncheckedCreateNestedManyWithoutProvaTeoricaInput
    Recurso?: RecursoUncheckedCreateNestedManyWithoutProvaTeoricaInput
  }

  export type ProvaTeoricaCreateOrConnectWithoutQuesitosInput = {
    where: ProvaTeoricaWhereUniqueInput
    create: XOR<ProvaTeoricaCreateWithoutQuesitosInput, ProvaTeoricaUncheckedCreateWithoutQuesitosInput>
  }

  export type SubQuesitosCreateWithoutQuesitoInput = {
    nomeSubquesito: string
    notaSubequesito: number
    subequesitosFilhos?: SubQuesitosCreateNestedManyWithoutSubequesitosPaiInput
    subequesitosPai?: SubQuesitosCreateNestedManyWithoutSubequesitosFilhosInput
  }

  export type SubQuesitosUncheckedCreateWithoutQuesitoInput = {
    idSubequestios?: number
    nomeSubquesito: string
    notaSubequesito: number
    subequesitosFilhos?: SubQuesitosUncheckedCreateNestedManyWithoutSubequesitosPaiInput
    subequesitosPai?: SubQuesitosUncheckedCreateNestedManyWithoutSubequesitosFilhosInput
  }

  export type SubQuesitosCreateOrConnectWithoutQuesitoInput = {
    where: SubQuesitosWhereUniqueInput
    create: XOR<SubQuesitosCreateWithoutQuesitoInput, SubQuesitosUncheckedCreateWithoutQuesitoInput>
  }

  export type SubQuesitosCreateManyQuesitoInputEnvelope = {
    data: SubQuesitosCreateManyQuesitoInput | SubQuesitosCreateManyQuesitoInput[]
    skipDuplicates?: boolean
  }

  export type RecursoCreateWithoutQuesitoInput = {
    nomeRecurso: string
    justificativa: string
    status: boolean
    dataRecurso?: Date | string
    arquivos: Bytes
    Candidato: CandidatoCreateNestedOneWithoutRecursoInput
    Usuario: UsuarioCreateNestedOneWithoutRecursosInput
    ProvaTeorica?: ProvaTeoricaCreateNestedOneWithoutRecursoInput
    ProvaPratica?: ProvaPraticaCreateNestedOneWithoutRecursoInput
    Prova?: ProvaCreateNestedOneWithoutRecursosInput
  }

  export type RecursoUncheckedCreateWithoutQuesitoInput = {
    idRecurso?: number
    nomeRecurso: string
    justificativa: string
    status: boolean
    dataRecurso?: Date | string
    arquivos: Bytes
    candidato: number
    avaliador: number
    provaTeoricaIdprovaTeorica?: number | null
    provaPraticaIdProvaPratica?: number | null
    provaIdProva?: number | null
  }

  export type RecursoCreateOrConnectWithoutQuesitoInput = {
    where: RecursoWhereUniqueInput
    create: XOR<RecursoCreateWithoutQuesitoInput, RecursoUncheckedCreateWithoutQuesitoInput>
  }

  export type RecursoCreateManyQuesitoInputEnvelope = {
    data: RecursoCreateManyQuesitoInput | RecursoCreateManyQuesitoInput[]
    skipDuplicates?: boolean
  }

  export type PreferenciaSorteioDancaCreateWithoutQuesitosInput = {
    nomeSorteioDanca: $Enums.DancaSalaoTradicional
    Candidato: CandidatoCreateNestedOneWithoutPreferenciaSorteioDancaInput
    SorteioDanca?: SorteioDancaCreateNestedOneWithoutPreferenciaSorteioDancaIdsInput
  }

  export type PreferenciaSorteioDancaUncheckedCreateWithoutQuesitosInput = {
    idPreferencia?: number
    nomeSorteioDanca: $Enums.DancaSalaoTradicional
    candidatoId: number
    sorteioDancaId?: number | null
  }

  export type PreferenciaSorteioDancaCreateOrConnectWithoutQuesitosInput = {
    where: PreferenciaSorteioDancaWhereUniqueInput
    create: XOR<PreferenciaSorteioDancaCreateWithoutQuesitosInput, PreferenciaSorteioDancaUncheckedCreateWithoutQuesitosInput>
  }

  export type AvaliacaoCreateWithoutQuesitosInput = {
    dataAvaliacao?: Date | string
    nota: number
    Comissao: ComissaoCreateNestedOneWithoutAvalicaoInput
    Usuario: UsuarioCreateNestedOneWithoutAvalicoesInput
    Prova?: ProvaCreateNestedOneWithoutAvaliacaoInput
    BlocoProva?: BlocoProvaCreateNestedOneWithoutAvaliacaoInput
    Candidato: CandidatoCreateNestedOneWithoutAvalicoesInput
    FichaCandidato?: FichaCandidatoCreateNestedOneWithoutAvaliacoesInput
  }

  export type AvaliacaoUncheckedCreateWithoutQuesitosInput = {
    idAvalicao?: number
    dataAvaliacao?: Date | string
    comissaoId: number
    avaliadorId: number
    provaId: number
    blocoProvaId?: number | null
    nota: number
    candidatoId: number
    fichaCandidatoIdFicha?: number | null
  }

  export type AvaliacaoCreateOrConnectWithoutQuesitosInput = {
    where: AvaliacaoWhereUniqueInput
    create: XOR<AvaliacaoCreateWithoutQuesitosInput, AvaliacaoUncheckedCreateWithoutQuesitosInput>
  }

  export type BlocoProvaUpsertWithoutQuesitosInput = {
    update: XOR<BlocoProvaUpdateWithoutQuesitosInput, BlocoProvaUncheckedUpdateWithoutQuesitosInput>
    create: XOR<BlocoProvaCreateWithoutQuesitosInput, BlocoProvaUncheckedCreateWithoutQuesitosInput>
    where?: BlocoProvaWhereInput
  }

  export type BlocoProvaUpdateToOneWithWhereWithoutQuesitosInput = {
    where?: BlocoProvaWhereInput
    data: XOR<BlocoProvaUpdateWithoutQuesitosInput, BlocoProvaUncheckedUpdateWithoutQuesitosInput>
  }

  export type BlocoProvaUpdateWithoutQuesitosInput = {
    nomeBloco?: StringFieldUpdateOperationsInput | string
    notaMaximaBloco?: FloatFieldUpdateOperationsInput | number
    ProvaPratica?: ProvaPraticaUpdateOneWithoutBlocosProvasNestedInput
    Avaliacao?: AvaliacaoUpdateManyWithoutBlocoProvaNestedInput
  }

  export type BlocoProvaUncheckedUpdateWithoutQuesitosInput = {
    idBloco?: IntFieldUpdateOperationsInput | number
    nomeBloco?: StringFieldUpdateOperationsInput | string
    notaMaximaBloco?: FloatFieldUpdateOperationsInput | number
    provaPraticaId?: NullableIntFieldUpdateOperationsInput | number | null
    Avaliacao?: AvaliacaoUncheckedUpdateManyWithoutBlocoProvaNestedInput
  }

  export type ProvaTeoricaUpsertWithoutQuesitosInput = {
    update: XOR<ProvaTeoricaUpdateWithoutQuesitosInput, ProvaTeoricaUncheckedUpdateWithoutQuesitosInput>
    create: XOR<ProvaTeoricaCreateWithoutQuesitosInput, ProvaTeoricaUncheckedCreateWithoutQuesitosInput>
    where?: ProvaTeoricaWhereInput
  }

  export type ProvaTeoricaUpdateToOneWithWhereWithoutQuesitosInput = {
    where?: ProvaTeoricaWhereInput
    data: XOR<ProvaTeoricaUpdateWithoutQuesitosInput, ProvaTeoricaUncheckedUpdateWithoutQuesitosInput>
  }

  export type ProvaTeoricaUpdateWithoutQuesitosInput = {
    gabaritoOficinal?: BytesFieldUpdateOperationsInput | Bytes
    numQuestao?: IntFieldUpdateOperationsInput | number
    Prova?: ProvaUpdateOneWithoutProvaTeoricaNestedInput
    Categoria?: CategoriaUpdateManyWithoutProvaTeoricaNestedInput
    Recurso?: RecursoUpdateManyWithoutProvaTeoricaNestedInput
  }

  export type ProvaTeoricaUncheckedUpdateWithoutQuesitosInput = {
    idprovaTeorica?: IntFieldUpdateOperationsInput | number
    provaId?: NullableIntFieldUpdateOperationsInput | number | null
    gabaritoOficinal?: BytesFieldUpdateOperationsInput | Bytes
    numQuestao?: IntFieldUpdateOperationsInput | number
    Categoria?: CategoriaUncheckedUpdateManyWithoutProvaTeoricaNestedInput
    Recurso?: RecursoUncheckedUpdateManyWithoutProvaTeoricaNestedInput
  }

  export type SubQuesitosUpsertWithWhereUniqueWithoutQuesitoInput = {
    where: SubQuesitosWhereUniqueInput
    update: XOR<SubQuesitosUpdateWithoutQuesitoInput, SubQuesitosUncheckedUpdateWithoutQuesitoInput>
    create: XOR<SubQuesitosCreateWithoutQuesitoInput, SubQuesitosUncheckedCreateWithoutQuesitoInput>
  }

  export type SubQuesitosUpdateWithWhereUniqueWithoutQuesitoInput = {
    where: SubQuesitosWhereUniqueInput
    data: XOR<SubQuesitosUpdateWithoutQuesitoInput, SubQuesitosUncheckedUpdateWithoutQuesitoInput>
  }

  export type SubQuesitosUpdateManyWithWhereWithoutQuesitoInput = {
    where: SubQuesitosScalarWhereInput
    data: XOR<SubQuesitosUpdateManyMutationInput, SubQuesitosUncheckedUpdateManyWithoutQuesitoInput>
  }

  export type SubQuesitosScalarWhereInput = {
    AND?: SubQuesitosScalarWhereInput | SubQuesitosScalarWhereInput[]
    OR?: SubQuesitosScalarWhereInput[]
    NOT?: SubQuesitosScalarWhereInput | SubQuesitosScalarWhereInput[]
    idSubequestios?: IntFilter<"SubQuesitos"> | number
    nomeSubquesito?: StringFilter<"SubQuesitos"> | string
    notaSubequesito?: FloatFilter<"SubQuesitos"> | number
    quesitoId?: IntFilter<"SubQuesitos"> | number
  }

  export type RecursoUpsertWithWhereUniqueWithoutQuesitoInput = {
    where: RecursoWhereUniqueInput
    update: XOR<RecursoUpdateWithoutQuesitoInput, RecursoUncheckedUpdateWithoutQuesitoInput>
    create: XOR<RecursoCreateWithoutQuesitoInput, RecursoUncheckedCreateWithoutQuesitoInput>
  }

  export type RecursoUpdateWithWhereUniqueWithoutQuesitoInput = {
    where: RecursoWhereUniqueInput
    data: XOR<RecursoUpdateWithoutQuesitoInput, RecursoUncheckedUpdateWithoutQuesitoInput>
  }

  export type RecursoUpdateManyWithWhereWithoutQuesitoInput = {
    where: RecursoScalarWhereInput
    data: XOR<RecursoUpdateManyMutationInput, RecursoUncheckedUpdateManyWithoutQuesitoInput>
  }

  export type PreferenciaSorteioDancaUpsertWithoutQuesitosInput = {
    update: XOR<PreferenciaSorteioDancaUpdateWithoutQuesitosInput, PreferenciaSorteioDancaUncheckedUpdateWithoutQuesitosInput>
    create: XOR<PreferenciaSorteioDancaCreateWithoutQuesitosInput, PreferenciaSorteioDancaUncheckedCreateWithoutQuesitosInput>
    where?: PreferenciaSorteioDancaWhereInput
  }

  export type PreferenciaSorteioDancaUpdateToOneWithWhereWithoutQuesitosInput = {
    where?: PreferenciaSorteioDancaWhereInput
    data: XOR<PreferenciaSorteioDancaUpdateWithoutQuesitosInput, PreferenciaSorteioDancaUncheckedUpdateWithoutQuesitosInput>
  }

  export type PreferenciaSorteioDancaUpdateWithoutQuesitosInput = {
    nomeSorteioDanca?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
    Candidato?: CandidatoUpdateOneRequiredWithoutPreferenciaSorteioDancaNestedInput
    SorteioDanca?: SorteioDancaUpdateOneWithoutPreferenciaSorteioDancaIdsNestedInput
  }

  export type PreferenciaSorteioDancaUncheckedUpdateWithoutQuesitosInput = {
    idPreferencia?: IntFieldUpdateOperationsInput | number
    nomeSorteioDanca?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
    candidatoId?: IntFieldUpdateOperationsInput | number
    sorteioDancaId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AvaliacaoUpsertWithoutQuesitosInput = {
    update: XOR<AvaliacaoUpdateWithoutQuesitosInput, AvaliacaoUncheckedUpdateWithoutQuesitosInput>
    create: XOR<AvaliacaoCreateWithoutQuesitosInput, AvaliacaoUncheckedCreateWithoutQuesitosInput>
    where?: AvaliacaoWhereInput
  }

  export type AvaliacaoUpdateToOneWithWhereWithoutQuesitosInput = {
    where?: AvaliacaoWhereInput
    data: XOR<AvaliacaoUpdateWithoutQuesitosInput, AvaliacaoUncheckedUpdateWithoutQuesitosInput>
  }

  export type AvaliacaoUpdateWithoutQuesitosInput = {
    dataAvaliacao?: DateTimeFieldUpdateOperationsInput | Date | string
    nota?: FloatFieldUpdateOperationsInput | number
    Comissao?: ComissaoUpdateOneRequiredWithoutAvalicaoNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutAvalicoesNestedInput
    Prova?: ProvaUpdateOneWithoutAvaliacaoNestedInput
    BlocoProva?: BlocoProvaUpdateOneWithoutAvaliacaoNestedInput
    Candidato?: CandidatoUpdateOneRequiredWithoutAvalicoesNestedInput
    FichaCandidato?: FichaCandidatoUpdateOneWithoutAvaliacoesNestedInput
  }

  export type AvaliacaoUncheckedUpdateWithoutQuesitosInput = {
    idAvalicao?: IntFieldUpdateOperationsInput | number
    dataAvaliacao?: DateTimeFieldUpdateOperationsInput | Date | string
    comissaoId?: IntFieldUpdateOperationsInput | number
    avaliadorId?: IntFieldUpdateOperationsInput | number
    provaId?: IntFieldUpdateOperationsInput | number
    blocoProvaId?: NullableIntFieldUpdateOperationsInput | number | null
    nota?: FloatFieldUpdateOperationsInput | number
    candidatoId?: IntFieldUpdateOperationsInput | number
    fichaCandidatoIdFicha?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuesitosCreateWithoutSubeQuesitosInput = {
    nomeQuesito: string
    notaMaximaQuesito: number
    danca: boolean
    dancaSalaoTradicional: $Enums.DancaSalaoTradicional
    BlocoProva?: BlocoProvaCreateNestedOneWithoutQuesitosInput
    ProvaTeorica?: ProvaTeoricaCreateNestedOneWithoutQuesitosInput
    recursos?: RecursoCreateNestedManyWithoutQuesitoInput
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaCreateNestedOneWithoutQuesitosInput
    Avaliacao?: AvaliacaoCreateNestedOneWithoutQuesitosInput
  }

  export type QuesitosUncheckedCreateWithoutSubeQuesitosInput = {
    idQuesito?: number
    nomeQuesito: string
    notaMaximaQuesito: number
    danca: boolean
    dancaSalaoTradicional: $Enums.DancaSalaoTradicional
    blocoProvaIdBloco?: number | null
    provaTeoricaIdprovaTeorica?: number | null
    preferenciaSorteioDancaId?: number | null
    avaliacaoIdAvalicao?: number | null
    recursos?: RecursoUncheckedCreateNestedManyWithoutQuesitoInput
  }

  export type QuesitosCreateOrConnectWithoutSubeQuesitosInput = {
    where: QuesitosWhereUniqueInput
    create: XOR<QuesitosCreateWithoutSubeQuesitosInput, QuesitosUncheckedCreateWithoutSubeQuesitosInput>
  }

  export type SubQuesitosCreateWithoutSubequesitosPaiInput = {
    nomeSubquesito: string
    notaSubequesito: number
    Quesito: QuesitosCreateNestedOneWithoutSubeQuesitosInput
    subequesitosFilhos?: SubQuesitosCreateNestedManyWithoutSubequesitosPaiInput
  }

  export type SubQuesitosUncheckedCreateWithoutSubequesitosPaiInput = {
    idSubequestios?: number
    nomeSubquesito: string
    notaSubequesito: number
    quesitoId: number
    subequesitosFilhos?: SubQuesitosUncheckedCreateNestedManyWithoutSubequesitosPaiInput
  }

  export type SubQuesitosCreateOrConnectWithoutSubequesitosPaiInput = {
    where: SubQuesitosWhereUniqueInput
    create: XOR<SubQuesitosCreateWithoutSubequesitosPaiInput, SubQuesitosUncheckedCreateWithoutSubequesitosPaiInput>
  }

  export type SubQuesitosCreateWithoutSubequesitosFilhosInput = {
    nomeSubquesito: string
    notaSubequesito: number
    Quesito: QuesitosCreateNestedOneWithoutSubeQuesitosInput
    subequesitosPai?: SubQuesitosCreateNestedManyWithoutSubequesitosFilhosInput
  }

  export type SubQuesitosUncheckedCreateWithoutSubequesitosFilhosInput = {
    idSubequestios?: number
    nomeSubquesito: string
    notaSubequesito: number
    quesitoId: number
    subequesitosPai?: SubQuesitosUncheckedCreateNestedManyWithoutSubequesitosFilhosInput
  }

  export type SubQuesitosCreateOrConnectWithoutSubequesitosFilhosInput = {
    where: SubQuesitosWhereUniqueInput
    create: XOR<SubQuesitosCreateWithoutSubequesitosFilhosInput, SubQuesitosUncheckedCreateWithoutSubequesitosFilhosInput>
  }

  export type QuesitosUpsertWithoutSubeQuesitosInput = {
    update: XOR<QuesitosUpdateWithoutSubeQuesitosInput, QuesitosUncheckedUpdateWithoutSubeQuesitosInput>
    create: XOR<QuesitosCreateWithoutSubeQuesitosInput, QuesitosUncheckedCreateWithoutSubeQuesitosInput>
    where?: QuesitosWhereInput
  }

  export type QuesitosUpdateToOneWithWhereWithoutSubeQuesitosInput = {
    where?: QuesitosWhereInput
    data: XOR<QuesitosUpdateWithoutSubeQuesitosInput, QuesitosUncheckedUpdateWithoutSubeQuesitosInput>
  }

  export type QuesitosUpdateWithoutSubeQuesitosInput = {
    nomeQuesito?: StringFieldUpdateOperationsInput | string
    notaMaximaQuesito?: FloatFieldUpdateOperationsInput | number
    danca?: BoolFieldUpdateOperationsInput | boolean
    dancaSalaoTradicional?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
    BlocoProva?: BlocoProvaUpdateOneWithoutQuesitosNestedInput
    ProvaTeorica?: ProvaTeoricaUpdateOneWithoutQuesitosNestedInput
    recursos?: RecursoUpdateManyWithoutQuesitoNestedInput
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaUpdateOneWithoutQuesitosNestedInput
    Avaliacao?: AvaliacaoUpdateOneWithoutQuesitosNestedInput
  }

  export type QuesitosUncheckedUpdateWithoutSubeQuesitosInput = {
    idQuesito?: IntFieldUpdateOperationsInput | number
    nomeQuesito?: StringFieldUpdateOperationsInput | string
    notaMaximaQuesito?: FloatFieldUpdateOperationsInput | number
    danca?: BoolFieldUpdateOperationsInput | boolean
    dancaSalaoTradicional?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
    blocoProvaIdBloco?: NullableIntFieldUpdateOperationsInput | number | null
    provaTeoricaIdprovaTeorica?: NullableIntFieldUpdateOperationsInput | number | null
    preferenciaSorteioDancaId?: NullableIntFieldUpdateOperationsInput | number | null
    avaliacaoIdAvalicao?: NullableIntFieldUpdateOperationsInput | number | null
    recursos?: RecursoUncheckedUpdateManyWithoutQuesitoNestedInput
  }

  export type SubQuesitosUpsertWithWhereUniqueWithoutSubequesitosPaiInput = {
    where: SubQuesitosWhereUniqueInput
    update: XOR<SubQuesitosUpdateWithoutSubequesitosPaiInput, SubQuesitosUncheckedUpdateWithoutSubequesitosPaiInput>
    create: XOR<SubQuesitosCreateWithoutSubequesitosPaiInput, SubQuesitosUncheckedCreateWithoutSubequesitosPaiInput>
  }

  export type SubQuesitosUpdateWithWhereUniqueWithoutSubequesitosPaiInput = {
    where: SubQuesitosWhereUniqueInput
    data: XOR<SubQuesitosUpdateWithoutSubequesitosPaiInput, SubQuesitosUncheckedUpdateWithoutSubequesitosPaiInput>
  }

  export type SubQuesitosUpdateManyWithWhereWithoutSubequesitosPaiInput = {
    where: SubQuesitosScalarWhereInput
    data: XOR<SubQuesitosUpdateManyMutationInput, SubQuesitosUncheckedUpdateManyWithoutSubequesitosPaiInput>
  }

  export type SubQuesitosUpsertWithWhereUniqueWithoutSubequesitosFilhosInput = {
    where: SubQuesitosWhereUniqueInput
    update: XOR<SubQuesitosUpdateWithoutSubequesitosFilhosInput, SubQuesitosUncheckedUpdateWithoutSubequesitosFilhosInput>
    create: XOR<SubQuesitosCreateWithoutSubequesitosFilhosInput, SubQuesitosUncheckedCreateWithoutSubequesitosFilhosInput>
  }

  export type SubQuesitosUpdateWithWhereUniqueWithoutSubequesitosFilhosInput = {
    where: SubQuesitosWhereUniqueInput
    data: XOR<SubQuesitosUpdateWithoutSubequesitosFilhosInput, SubQuesitosUncheckedUpdateWithoutSubequesitosFilhosInput>
  }

  export type SubQuesitosUpdateManyWithWhereWithoutSubequesitosFilhosInput = {
    where: SubQuesitosScalarWhereInput
    data: XOR<SubQuesitosUpdateManyMutationInput, SubQuesitosUncheckedUpdateManyWithoutSubequesitosFilhosInput>
  }

  export type CandidatoCreateWithoutRecursoInput = {
    nomeCompleto: string
    cidade: string
    estado: string
    numCarteirinha: string
    CPF: string
    RG: string
    endereco: string
    numEndereco: number
    bairro: string
    escolaridade: string
    filiacao: string
    ProvaCampeiraEsportiva?: $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: Bytes | null
    anexoCarteirinha?: Bytes | null
    anexoEscolaridade?: Bytes | null
    anexoResidencia?: Bytes | null
    anexoAtaConcurso?: Bytes | null
    fichaInscricao?: Bytes | null
    anexoTermoCandidato?: Bytes | null
    anexoRelatorioVivencia?: Bytes | null
    anexoResponsavel?: Bytes | null
    anexoProvaEsportivaCampeira?: Bytes | null
    CTG: CTGCreateNestedOneWithoutCandidatoInput
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaCreateNestedManyWithoutCandidatoInput
    Categoria: CategoriaCreateNestedOneWithoutCandidatosInput
    avalicoes?: AvaliacaoCreateNestedManyWithoutCandidatoInput
    sorteioDanca?: SorteioDancaCreateNestedManyWithoutCandidatoInput
    Concurso?: ConcursoCreateNestedOneWithoutCandidatosInput
  }

  export type CandidatoUncheckedCreateWithoutRecursoInput = {
    idCandidato?: number
    nomeCompleto: string
    cidade: string
    estado: string
    CTGId: number
    numCarteirinha: string
    CPF: string
    RG: string
    endereco: string
    numEndereco: number
    bairro: string
    escolaridade: string
    filiacao: string
    ProvaCampeiraEsportiva?: $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: Bytes | null
    anexoCarteirinha?: Bytes | null
    anexoEscolaridade?: Bytes | null
    anexoResidencia?: Bytes | null
    anexoAtaConcurso?: Bytes | null
    fichaInscricao?: Bytes | null
    anexoTermoCandidato?: Bytes | null
    anexoRelatorioVivencia?: Bytes | null
    anexoResponsavel?: Bytes | null
    anexoProvaEsportivaCampeira?: Bytes | null
    categoriaId: number
    concursoIdConcurso?: number | null
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaUncheckedCreateNestedManyWithoutCandidatoInput
    avalicoes?: AvaliacaoUncheckedCreateNestedManyWithoutCandidatoInput
    sorteioDanca?: SorteioDancaUncheckedCreateNestedManyWithoutCandidatoInput
  }

  export type CandidatoCreateOrConnectWithoutRecursoInput = {
    where: CandidatoWhereUniqueInput
    create: XOR<CandidatoCreateWithoutRecursoInput, CandidatoUncheckedCreateWithoutRecursoInput>
  }

  export type UsuarioCreateWithoutRecursosInput = {
    nomeCompleto: string
    cidade: string
    estado: string
    numCarteirinha: string
    login: string
    senha: string
    funcao: $Enums.Funcao
    credenciamento?: $Enums.Credenciamento
    numCredenciamento?: number | null
    comissaoUsuarioId?: number | null
    CTG: CTGCreateNestedOneWithoutUsuarioInput
    ComissaoUsuario?: ComissaoUsuarioCreateNestedOneWithoutUsuariosInput
    avalicoes?: AvaliacaoCreateNestedManyWithoutUsuarioInput
    sorteioDanca?: SorteioDancaCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutRecursosInput = {
    idUsuario?: number
    nomeCompleto: string
    cidade: string
    estado: string
    CTGId: number
    numCarteirinha: string
    login: string
    senha: string
    funcao: $Enums.Funcao
    credenciamento?: $Enums.Credenciamento
    numCredenciamento?: number | null
    comissaoUsuarioId?: number | null
    ComissaoUsuario?: ComissaoUsuarioUncheckedCreateNestedOneWithoutUsuariosInput
    avalicoes?: AvaliacaoUncheckedCreateNestedManyWithoutUsuarioInput
    sorteioDanca?: SorteioDancaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutRecursosInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutRecursosInput, UsuarioUncheckedCreateWithoutRecursosInput>
  }

  export type QuesitosCreateWithoutRecursosInput = {
    nomeQuesito: string
    notaMaximaQuesito: number
    danca: boolean
    dancaSalaoTradicional: $Enums.DancaSalaoTradicional
    BlocoProva?: BlocoProvaCreateNestedOneWithoutQuesitosInput
    ProvaTeorica?: ProvaTeoricaCreateNestedOneWithoutQuesitosInput
    subeQuesitos?: SubQuesitosCreateNestedManyWithoutQuesitoInput
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaCreateNestedOneWithoutQuesitosInput
    Avaliacao?: AvaliacaoCreateNestedOneWithoutQuesitosInput
  }

  export type QuesitosUncheckedCreateWithoutRecursosInput = {
    idQuesito?: number
    nomeQuesito: string
    notaMaximaQuesito: number
    danca: boolean
    dancaSalaoTradicional: $Enums.DancaSalaoTradicional
    blocoProvaIdBloco?: number | null
    provaTeoricaIdprovaTeorica?: number | null
    preferenciaSorteioDancaId?: number | null
    avaliacaoIdAvalicao?: number | null
    subeQuesitos?: SubQuesitosUncheckedCreateNestedManyWithoutQuesitoInput
  }

  export type QuesitosCreateOrConnectWithoutRecursosInput = {
    where: QuesitosWhereUniqueInput
    create: XOR<QuesitosCreateWithoutRecursosInput, QuesitosUncheckedCreateWithoutRecursosInput>
  }

  export type ProvaTeoricaCreateWithoutRecursoInput = {
    gabaritoOficinal: Bytes
    numQuestao: number
    Prova?: ProvaCreateNestedOneWithoutProvaTeoricaInput
    quesitos?: QuesitosCreateNestedManyWithoutProvaTeoricaInput
    Categoria?: CategoriaCreateNestedManyWithoutProvaTeoricaInput
  }

  export type ProvaTeoricaUncheckedCreateWithoutRecursoInput = {
    idprovaTeorica?: number
    provaId?: number | null
    gabaritoOficinal: Bytes
    numQuestao: number
    quesitos?: QuesitosUncheckedCreateNestedManyWithoutProvaTeoricaInput
    Categoria?: CategoriaUncheckedCreateNestedManyWithoutProvaTeoricaInput
  }

  export type ProvaTeoricaCreateOrConnectWithoutRecursoInput = {
    where: ProvaTeoricaWhereUniqueInput
    create: XOR<ProvaTeoricaCreateWithoutRecursoInput, ProvaTeoricaUncheckedCreateWithoutRecursoInput>
  }

  export type ProvaPraticaCreateWithoutRecursoInput = {
    prova?: ProvaCreateNestedOneWithoutProvaPraticaInput
    blocosProvas?: BlocoProvaCreateNestedManyWithoutProvaPraticaInput
    Categoria?: CategoriaCreateNestedManyWithoutProvaPraticaInput
  }

  export type ProvaPraticaUncheckedCreateWithoutRecursoInput = {
    idProvaPratica?: number
    provaId?: number | null
    blocosProvas?: BlocoProvaUncheckedCreateNestedManyWithoutProvaPraticaInput
    Categoria?: CategoriaUncheckedCreateNestedManyWithoutProvaPraticaInput
  }

  export type ProvaPraticaCreateOrConnectWithoutRecursoInput = {
    where: ProvaPraticaWhereUniqueInput
    create: XOR<ProvaPraticaCreateWithoutRecursoInput, ProvaPraticaUncheckedCreateWithoutRecursoInput>
  }

  export type ProvaCreateWithoutRecursosInput = {
    nomeProva: string
    notaMaxima: number
    categorias?: CategoriaCreateNestedManyWithoutProvaInput
    ProvaTeorica?: ProvaTeoricaCreateNestedManyWithoutProvaInput
    ProvaPratica?: ProvaPraticaCreateNestedManyWithoutProvaInput
    Avaliacao?: AvaliacaoCreateNestedManyWithoutProvaInput
  }

  export type ProvaUncheckedCreateWithoutRecursosInput = {
    idProva?: number
    nomeProva: string
    notaMaxima: number
    categorias?: CategoriaUncheckedCreateNestedManyWithoutProvaInput
    ProvaTeorica?: ProvaTeoricaUncheckedCreateNestedManyWithoutProvaInput
    ProvaPratica?: ProvaPraticaUncheckedCreateNestedManyWithoutProvaInput
    Avaliacao?: AvaliacaoUncheckedCreateNestedManyWithoutProvaInput
  }

  export type ProvaCreateOrConnectWithoutRecursosInput = {
    where: ProvaWhereUniqueInput
    create: XOR<ProvaCreateWithoutRecursosInput, ProvaUncheckedCreateWithoutRecursosInput>
  }

  export type CandidatoUpsertWithoutRecursoInput = {
    update: XOR<CandidatoUpdateWithoutRecursoInput, CandidatoUncheckedUpdateWithoutRecursoInput>
    create: XOR<CandidatoCreateWithoutRecursoInput, CandidatoUncheckedCreateWithoutRecursoInput>
    where?: CandidatoWhereInput
  }

  export type CandidatoUpdateToOneWithWhereWithoutRecursoInput = {
    where?: CandidatoWhereInput
    data: XOR<CandidatoUpdateWithoutRecursoInput, CandidatoUncheckedUpdateWithoutRecursoInput>
  }

  export type CandidatoUpdateWithoutRecursoInput = {
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    numCarteirinha?: StringFieldUpdateOperationsInput | string
    CPF?: StringFieldUpdateOperationsInput | string
    RG?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    numEndereco?: IntFieldUpdateOperationsInput | number
    bairro?: StringFieldUpdateOperationsInput | string
    escolaridade?: StringFieldUpdateOperationsInput | string
    filiacao?: StringFieldUpdateOperationsInput | string
    ProvaCampeiraEsportiva?: NullableEnumProvaCampeiraEsportivaFieldUpdateOperationsInput | $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoCarteirinha?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoEscolaridade?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoResidencia?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoAtaConcurso?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    fichaInscricao?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoTermoCandidato?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoRelatorioVivencia?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoResponsavel?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoProvaEsportivaCampeira?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    CTG?: CTGUpdateOneRequiredWithoutCandidatoNestedInput
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaUpdateManyWithoutCandidatoNestedInput
    Categoria?: CategoriaUpdateOneRequiredWithoutCandidatosNestedInput
    avalicoes?: AvaliacaoUpdateManyWithoutCandidatoNestedInput
    sorteioDanca?: SorteioDancaUpdateManyWithoutCandidatoNestedInput
    Concurso?: ConcursoUpdateOneWithoutCandidatosNestedInput
  }

  export type CandidatoUncheckedUpdateWithoutRecursoInput = {
    idCandidato?: IntFieldUpdateOperationsInput | number
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    CTGId?: IntFieldUpdateOperationsInput | number
    numCarteirinha?: StringFieldUpdateOperationsInput | string
    CPF?: StringFieldUpdateOperationsInput | string
    RG?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    numEndereco?: IntFieldUpdateOperationsInput | number
    bairro?: StringFieldUpdateOperationsInput | string
    escolaridade?: StringFieldUpdateOperationsInput | string
    filiacao?: StringFieldUpdateOperationsInput | string
    ProvaCampeiraEsportiva?: NullableEnumProvaCampeiraEsportivaFieldUpdateOperationsInput | $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoCarteirinha?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoEscolaridade?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoResidencia?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoAtaConcurso?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    fichaInscricao?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoTermoCandidato?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoRelatorioVivencia?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoResponsavel?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoProvaEsportivaCampeira?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    categoriaId?: IntFieldUpdateOperationsInput | number
    concursoIdConcurso?: NullableIntFieldUpdateOperationsInput | number | null
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaUncheckedUpdateManyWithoutCandidatoNestedInput
    avalicoes?: AvaliacaoUncheckedUpdateManyWithoutCandidatoNestedInput
    sorteioDanca?: SorteioDancaUncheckedUpdateManyWithoutCandidatoNestedInput
  }

  export type UsuarioUpsertWithoutRecursosInput = {
    update: XOR<UsuarioUpdateWithoutRecursosInput, UsuarioUncheckedUpdateWithoutRecursosInput>
    create: XOR<UsuarioCreateWithoutRecursosInput, UsuarioUncheckedCreateWithoutRecursosInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutRecursosInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutRecursosInput, UsuarioUncheckedUpdateWithoutRecursosInput>
  }

  export type UsuarioUpdateWithoutRecursosInput = {
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    numCarteirinha?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    funcao?: EnumFuncaoFieldUpdateOperationsInput | $Enums.Funcao
    credenciamento?: EnumCredenciamentoFieldUpdateOperationsInput | $Enums.Credenciamento
    numCredenciamento?: NullableIntFieldUpdateOperationsInput | number | null
    comissaoUsuarioId?: NullableIntFieldUpdateOperationsInput | number | null
    CTG?: CTGUpdateOneRequiredWithoutUsuarioNestedInput
    ComissaoUsuario?: ComissaoUsuarioUpdateOneWithoutUsuariosNestedInput
    avalicoes?: AvaliacaoUpdateManyWithoutUsuarioNestedInput
    sorteioDanca?: SorteioDancaUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutRecursosInput = {
    idUsuario?: IntFieldUpdateOperationsInput | number
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    CTGId?: IntFieldUpdateOperationsInput | number
    numCarteirinha?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    funcao?: EnumFuncaoFieldUpdateOperationsInput | $Enums.Funcao
    credenciamento?: EnumCredenciamentoFieldUpdateOperationsInput | $Enums.Credenciamento
    numCredenciamento?: NullableIntFieldUpdateOperationsInput | number | null
    comissaoUsuarioId?: NullableIntFieldUpdateOperationsInput | number | null
    ComissaoUsuario?: ComissaoUsuarioUncheckedUpdateOneWithoutUsuariosNestedInput
    avalicoes?: AvaliacaoUncheckedUpdateManyWithoutUsuarioNestedInput
    sorteioDanca?: SorteioDancaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type QuesitosUpsertWithoutRecursosInput = {
    update: XOR<QuesitosUpdateWithoutRecursosInput, QuesitosUncheckedUpdateWithoutRecursosInput>
    create: XOR<QuesitosCreateWithoutRecursosInput, QuesitosUncheckedCreateWithoutRecursosInput>
    where?: QuesitosWhereInput
  }

  export type QuesitosUpdateToOneWithWhereWithoutRecursosInput = {
    where?: QuesitosWhereInput
    data: XOR<QuesitosUpdateWithoutRecursosInput, QuesitosUncheckedUpdateWithoutRecursosInput>
  }

  export type QuesitosUpdateWithoutRecursosInput = {
    nomeQuesito?: StringFieldUpdateOperationsInput | string
    notaMaximaQuesito?: FloatFieldUpdateOperationsInput | number
    danca?: BoolFieldUpdateOperationsInput | boolean
    dancaSalaoTradicional?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
    BlocoProva?: BlocoProvaUpdateOneWithoutQuesitosNestedInput
    ProvaTeorica?: ProvaTeoricaUpdateOneWithoutQuesitosNestedInput
    subeQuesitos?: SubQuesitosUpdateManyWithoutQuesitoNestedInput
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaUpdateOneWithoutQuesitosNestedInput
    Avaliacao?: AvaliacaoUpdateOneWithoutQuesitosNestedInput
  }

  export type QuesitosUncheckedUpdateWithoutRecursosInput = {
    idQuesito?: IntFieldUpdateOperationsInput | number
    nomeQuesito?: StringFieldUpdateOperationsInput | string
    notaMaximaQuesito?: FloatFieldUpdateOperationsInput | number
    danca?: BoolFieldUpdateOperationsInput | boolean
    dancaSalaoTradicional?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
    blocoProvaIdBloco?: NullableIntFieldUpdateOperationsInput | number | null
    provaTeoricaIdprovaTeorica?: NullableIntFieldUpdateOperationsInput | number | null
    preferenciaSorteioDancaId?: NullableIntFieldUpdateOperationsInput | number | null
    avaliacaoIdAvalicao?: NullableIntFieldUpdateOperationsInput | number | null
    subeQuesitos?: SubQuesitosUncheckedUpdateManyWithoutQuesitoNestedInput
  }

  export type ProvaTeoricaUpsertWithoutRecursoInput = {
    update: XOR<ProvaTeoricaUpdateWithoutRecursoInput, ProvaTeoricaUncheckedUpdateWithoutRecursoInput>
    create: XOR<ProvaTeoricaCreateWithoutRecursoInput, ProvaTeoricaUncheckedCreateWithoutRecursoInput>
    where?: ProvaTeoricaWhereInput
  }

  export type ProvaTeoricaUpdateToOneWithWhereWithoutRecursoInput = {
    where?: ProvaTeoricaWhereInput
    data: XOR<ProvaTeoricaUpdateWithoutRecursoInput, ProvaTeoricaUncheckedUpdateWithoutRecursoInput>
  }

  export type ProvaTeoricaUpdateWithoutRecursoInput = {
    gabaritoOficinal?: BytesFieldUpdateOperationsInput | Bytes
    numQuestao?: IntFieldUpdateOperationsInput | number
    Prova?: ProvaUpdateOneWithoutProvaTeoricaNestedInput
    quesitos?: QuesitosUpdateManyWithoutProvaTeoricaNestedInput
    Categoria?: CategoriaUpdateManyWithoutProvaTeoricaNestedInput
  }

  export type ProvaTeoricaUncheckedUpdateWithoutRecursoInput = {
    idprovaTeorica?: IntFieldUpdateOperationsInput | number
    provaId?: NullableIntFieldUpdateOperationsInput | number | null
    gabaritoOficinal?: BytesFieldUpdateOperationsInput | Bytes
    numQuestao?: IntFieldUpdateOperationsInput | number
    quesitos?: QuesitosUncheckedUpdateManyWithoutProvaTeoricaNestedInput
    Categoria?: CategoriaUncheckedUpdateManyWithoutProvaTeoricaNestedInput
  }

  export type ProvaPraticaUpsertWithoutRecursoInput = {
    update: XOR<ProvaPraticaUpdateWithoutRecursoInput, ProvaPraticaUncheckedUpdateWithoutRecursoInput>
    create: XOR<ProvaPraticaCreateWithoutRecursoInput, ProvaPraticaUncheckedCreateWithoutRecursoInput>
    where?: ProvaPraticaWhereInput
  }

  export type ProvaPraticaUpdateToOneWithWhereWithoutRecursoInput = {
    where?: ProvaPraticaWhereInput
    data: XOR<ProvaPraticaUpdateWithoutRecursoInput, ProvaPraticaUncheckedUpdateWithoutRecursoInput>
  }

  export type ProvaPraticaUpdateWithoutRecursoInput = {
    prova?: ProvaUpdateOneWithoutProvaPraticaNestedInput
    blocosProvas?: BlocoProvaUpdateManyWithoutProvaPraticaNestedInput
    Categoria?: CategoriaUpdateManyWithoutProvaPraticaNestedInput
  }

  export type ProvaPraticaUncheckedUpdateWithoutRecursoInput = {
    idProvaPratica?: IntFieldUpdateOperationsInput | number
    provaId?: NullableIntFieldUpdateOperationsInput | number | null
    blocosProvas?: BlocoProvaUncheckedUpdateManyWithoutProvaPraticaNestedInput
    Categoria?: CategoriaUncheckedUpdateManyWithoutProvaPraticaNestedInput
  }

  export type ProvaUpsertWithoutRecursosInput = {
    update: XOR<ProvaUpdateWithoutRecursosInput, ProvaUncheckedUpdateWithoutRecursosInput>
    create: XOR<ProvaCreateWithoutRecursosInput, ProvaUncheckedCreateWithoutRecursosInput>
    where?: ProvaWhereInput
  }

  export type ProvaUpdateToOneWithWhereWithoutRecursosInput = {
    where?: ProvaWhereInput
    data: XOR<ProvaUpdateWithoutRecursosInput, ProvaUncheckedUpdateWithoutRecursosInput>
  }

  export type ProvaUpdateWithoutRecursosInput = {
    nomeProva?: StringFieldUpdateOperationsInput | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    categorias?: CategoriaUpdateManyWithoutProvaNestedInput
    ProvaTeorica?: ProvaTeoricaUpdateManyWithoutProvaNestedInput
    ProvaPratica?: ProvaPraticaUpdateManyWithoutProvaNestedInput
    Avaliacao?: AvaliacaoUpdateManyWithoutProvaNestedInput
  }

  export type ProvaUncheckedUpdateWithoutRecursosInput = {
    idProva?: IntFieldUpdateOperationsInput | number
    nomeProva?: StringFieldUpdateOperationsInput | string
    notaMaxima?: FloatFieldUpdateOperationsInput | number
    categorias?: CategoriaUncheckedUpdateManyWithoutProvaNestedInput
    ProvaTeorica?: ProvaTeoricaUncheckedUpdateManyWithoutProvaNestedInput
    ProvaPratica?: ProvaPraticaUncheckedUpdateManyWithoutProvaNestedInput
    Avaliacao?: AvaliacaoUncheckedUpdateManyWithoutProvaNestedInput
  }

  export type PreferenciaSorteioDancaCreateWithoutSorteioDancaInput = {
    nomeSorteioDanca: $Enums.DancaSalaoTradicional
    Candidato: CandidatoCreateNestedOneWithoutPreferenciaSorteioDancaInput
    quesitos?: QuesitosCreateNestedManyWithoutPreferenciaSorteioDancaInput
  }

  export type PreferenciaSorteioDancaUncheckedCreateWithoutSorteioDancaInput = {
    idPreferencia?: number
    nomeSorteioDanca: $Enums.DancaSalaoTradicional
    candidatoId: number
    quesitos?: QuesitosUncheckedCreateNestedManyWithoutPreferenciaSorteioDancaInput
  }

  export type PreferenciaSorteioDancaCreateOrConnectWithoutSorteioDancaInput = {
    where: PreferenciaSorteioDancaWhereUniqueInput
    create: XOR<PreferenciaSorteioDancaCreateWithoutSorteioDancaInput, PreferenciaSorteioDancaUncheckedCreateWithoutSorteioDancaInput>
  }

  export type PreferenciaSorteioDancaCreateManySorteioDancaInputEnvelope = {
    data: PreferenciaSorteioDancaCreateManySorteioDancaInput | PreferenciaSorteioDancaCreateManySorteioDancaInput[]
    skipDuplicates?: boolean
  }

  export type CandidatoCreateWithoutSorteioDancaInput = {
    nomeCompleto: string
    cidade: string
    estado: string
    numCarteirinha: string
    CPF: string
    RG: string
    endereco: string
    numEndereco: number
    bairro: string
    escolaridade: string
    filiacao: string
    ProvaCampeiraEsportiva?: $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: Bytes | null
    anexoCarteirinha?: Bytes | null
    anexoEscolaridade?: Bytes | null
    anexoResidencia?: Bytes | null
    anexoAtaConcurso?: Bytes | null
    fichaInscricao?: Bytes | null
    anexoTermoCandidato?: Bytes | null
    anexoRelatorioVivencia?: Bytes | null
    anexoResponsavel?: Bytes | null
    anexoProvaEsportivaCampeira?: Bytes | null
    CTG: CTGCreateNestedOneWithoutCandidatoInput
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaCreateNestedManyWithoutCandidatoInput
    Categoria: CategoriaCreateNestedOneWithoutCandidatosInput
    avalicoes?: AvaliacaoCreateNestedManyWithoutCandidatoInput
    Recurso?: RecursoCreateNestedManyWithoutCandidatoInput
    Concurso?: ConcursoCreateNestedOneWithoutCandidatosInput
  }

  export type CandidatoUncheckedCreateWithoutSorteioDancaInput = {
    idCandidato?: number
    nomeCompleto: string
    cidade: string
    estado: string
    CTGId: number
    numCarteirinha: string
    CPF: string
    RG: string
    endereco: string
    numEndereco: number
    bairro: string
    escolaridade: string
    filiacao: string
    ProvaCampeiraEsportiva?: $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: Bytes | null
    anexoCarteirinha?: Bytes | null
    anexoEscolaridade?: Bytes | null
    anexoResidencia?: Bytes | null
    anexoAtaConcurso?: Bytes | null
    fichaInscricao?: Bytes | null
    anexoTermoCandidato?: Bytes | null
    anexoRelatorioVivencia?: Bytes | null
    anexoResponsavel?: Bytes | null
    anexoProvaEsportivaCampeira?: Bytes | null
    categoriaId: number
    concursoIdConcurso?: number | null
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaUncheckedCreateNestedManyWithoutCandidatoInput
    avalicoes?: AvaliacaoUncheckedCreateNestedManyWithoutCandidatoInput
    Recurso?: RecursoUncheckedCreateNestedManyWithoutCandidatoInput
  }

  export type CandidatoCreateOrConnectWithoutSorteioDancaInput = {
    where: CandidatoWhereUniqueInput
    create: XOR<CandidatoCreateWithoutSorteioDancaInput, CandidatoUncheckedCreateWithoutSorteioDancaInput>
  }

  export type UsuarioCreateWithoutSorteioDancaInput = {
    nomeCompleto: string
    cidade: string
    estado: string
    numCarteirinha: string
    login: string
    senha: string
    funcao: $Enums.Funcao
    credenciamento?: $Enums.Credenciamento
    numCredenciamento?: number | null
    comissaoUsuarioId?: number | null
    CTG: CTGCreateNestedOneWithoutUsuarioInput
    ComissaoUsuario?: ComissaoUsuarioCreateNestedOneWithoutUsuariosInput
    avalicoes?: AvaliacaoCreateNestedManyWithoutUsuarioInput
    recursos?: RecursoCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutSorteioDancaInput = {
    idUsuario?: number
    nomeCompleto: string
    cidade: string
    estado: string
    CTGId: number
    numCarteirinha: string
    login: string
    senha: string
    funcao: $Enums.Funcao
    credenciamento?: $Enums.Credenciamento
    numCredenciamento?: number | null
    comissaoUsuarioId?: number | null
    ComissaoUsuario?: ComissaoUsuarioUncheckedCreateNestedOneWithoutUsuariosInput
    avalicoes?: AvaliacaoUncheckedCreateNestedManyWithoutUsuarioInput
    recursos?: RecursoUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutSorteioDancaInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutSorteioDancaInput, UsuarioUncheckedCreateWithoutSorteioDancaInput>
  }

  export type PreferenciaSorteioDancaUpsertWithWhereUniqueWithoutSorteioDancaInput = {
    where: PreferenciaSorteioDancaWhereUniqueInput
    update: XOR<PreferenciaSorteioDancaUpdateWithoutSorteioDancaInput, PreferenciaSorteioDancaUncheckedUpdateWithoutSorteioDancaInput>
    create: XOR<PreferenciaSorteioDancaCreateWithoutSorteioDancaInput, PreferenciaSorteioDancaUncheckedCreateWithoutSorteioDancaInput>
  }

  export type PreferenciaSorteioDancaUpdateWithWhereUniqueWithoutSorteioDancaInput = {
    where: PreferenciaSorteioDancaWhereUniqueInput
    data: XOR<PreferenciaSorteioDancaUpdateWithoutSorteioDancaInput, PreferenciaSorteioDancaUncheckedUpdateWithoutSorteioDancaInput>
  }

  export type PreferenciaSorteioDancaUpdateManyWithWhereWithoutSorteioDancaInput = {
    where: PreferenciaSorteioDancaScalarWhereInput
    data: XOR<PreferenciaSorteioDancaUpdateManyMutationInput, PreferenciaSorteioDancaUncheckedUpdateManyWithoutSorteioDancaInput>
  }

  export type CandidatoUpsertWithoutSorteioDancaInput = {
    update: XOR<CandidatoUpdateWithoutSorteioDancaInput, CandidatoUncheckedUpdateWithoutSorteioDancaInput>
    create: XOR<CandidatoCreateWithoutSorteioDancaInput, CandidatoUncheckedCreateWithoutSorteioDancaInput>
    where?: CandidatoWhereInput
  }

  export type CandidatoUpdateToOneWithWhereWithoutSorteioDancaInput = {
    where?: CandidatoWhereInput
    data: XOR<CandidatoUpdateWithoutSorteioDancaInput, CandidatoUncheckedUpdateWithoutSorteioDancaInput>
  }

  export type CandidatoUpdateWithoutSorteioDancaInput = {
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    numCarteirinha?: StringFieldUpdateOperationsInput | string
    CPF?: StringFieldUpdateOperationsInput | string
    RG?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    numEndereco?: IntFieldUpdateOperationsInput | number
    bairro?: StringFieldUpdateOperationsInput | string
    escolaridade?: StringFieldUpdateOperationsInput | string
    filiacao?: StringFieldUpdateOperationsInput | string
    ProvaCampeiraEsportiva?: NullableEnumProvaCampeiraEsportivaFieldUpdateOperationsInput | $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoCarteirinha?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoEscolaridade?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoResidencia?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoAtaConcurso?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    fichaInscricao?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoTermoCandidato?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoRelatorioVivencia?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoResponsavel?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoProvaEsportivaCampeira?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    CTG?: CTGUpdateOneRequiredWithoutCandidatoNestedInput
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaUpdateManyWithoutCandidatoNestedInput
    Categoria?: CategoriaUpdateOneRequiredWithoutCandidatosNestedInput
    avalicoes?: AvaliacaoUpdateManyWithoutCandidatoNestedInput
    Recurso?: RecursoUpdateManyWithoutCandidatoNestedInput
    Concurso?: ConcursoUpdateOneWithoutCandidatosNestedInput
  }

  export type CandidatoUncheckedUpdateWithoutSorteioDancaInput = {
    idCandidato?: IntFieldUpdateOperationsInput | number
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    CTGId?: IntFieldUpdateOperationsInput | number
    numCarteirinha?: StringFieldUpdateOperationsInput | string
    CPF?: StringFieldUpdateOperationsInput | string
    RG?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    numEndereco?: IntFieldUpdateOperationsInput | number
    bairro?: StringFieldUpdateOperationsInput | string
    escolaridade?: StringFieldUpdateOperationsInput | string
    filiacao?: StringFieldUpdateOperationsInput | string
    ProvaCampeiraEsportiva?: NullableEnumProvaCampeiraEsportivaFieldUpdateOperationsInput | $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoCarteirinha?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoEscolaridade?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoResidencia?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoAtaConcurso?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    fichaInscricao?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoTermoCandidato?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoRelatorioVivencia?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoResponsavel?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoProvaEsportivaCampeira?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    categoriaId?: IntFieldUpdateOperationsInput | number
    concursoIdConcurso?: NullableIntFieldUpdateOperationsInput | number | null
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaUncheckedUpdateManyWithoutCandidatoNestedInput
    avalicoes?: AvaliacaoUncheckedUpdateManyWithoutCandidatoNestedInput
    Recurso?: RecursoUncheckedUpdateManyWithoutCandidatoNestedInput
  }

  export type UsuarioUpsertWithoutSorteioDancaInput = {
    update: XOR<UsuarioUpdateWithoutSorteioDancaInput, UsuarioUncheckedUpdateWithoutSorteioDancaInput>
    create: XOR<UsuarioCreateWithoutSorteioDancaInput, UsuarioUncheckedCreateWithoutSorteioDancaInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutSorteioDancaInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutSorteioDancaInput, UsuarioUncheckedUpdateWithoutSorteioDancaInput>
  }

  export type UsuarioUpdateWithoutSorteioDancaInput = {
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    numCarteirinha?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    funcao?: EnumFuncaoFieldUpdateOperationsInput | $Enums.Funcao
    credenciamento?: EnumCredenciamentoFieldUpdateOperationsInput | $Enums.Credenciamento
    numCredenciamento?: NullableIntFieldUpdateOperationsInput | number | null
    comissaoUsuarioId?: NullableIntFieldUpdateOperationsInput | number | null
    CTG?: CTGUpdateOneRequiredWithoutUsuarioNestedInput
    ComissaoUsuario?: ComissaoUsuarioUpdateOneWithoutUsuariosNestedInput
    avalicoes?: AvaliacaoUpdateManyWithoutUsuarioNestedInput
    recursos?: RecursoUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutSorteioDancaInput = {
    idUsuario?: IntFieldUpdateOperationsInput | number
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    CTGId?: IntFieldUpdateOperationsInput | number
    numCarteirinha?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    funcao?: EnumFuncaoFieldUpdateOperationsInput | $Enums.Funcao
    credenciamento?: EnumCredenciamentoFieldUpdateOperationsInput | $Enums.Credenciamento
    numCredenciamento?: NullableIntFieldUpdateOperationsInput | number | null
    comissaoUsuarioId?: NullableIntFieldUpdateOperationsInput | number | null
    ComissaoUsuario?: ComissaoUsuarioUncheckedUpdateOneWithoutUsuariosNestedInput
    avalicoes?: AvaliacaoUncheckedUpdateManyWithoutUsuarioNestedInput
    recursos?: RecursoUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type AvaliacaoCreateWithoutFichaCandidatoInput = {
    dataAvaliacao?: Date | string
    nota: number
    Comissao: ComissaoCreateNestedOneWithoutAvalicaoInput
    Usuario: UsuarioCreateNestedOneWithoutAvalicoesInput
    Prova?: ProvaCreateNestedOneWithoutAvaliacaoInput
    BlocoProva?: BlocoProvaCreateNestedOneWithoutAvaliacaoInput
    quesitos?: QuesitosCreateNestedManyWithoutAvaliacaoInput
    Candidato: CandidatoCreateNestedOneWithoutAvalicoesInput
  }

  export type AvaliacaoUncheckedCreateWithoutFichaCandidatoInput = {
    idAvalicao?: number
    dataAvaliacao?: Date | string
    comissaoId: number
    avaliadorId: number
    provaId: number
    blocoProvaId?: number | null
    nota: number
    candidatoId: number
    quesitos?: QuesitosUncheckedCreateNestedManyWithoutAvaliacaoInput
  }

  export type AvaliacaoCreateOrConnectWithoutFichaCandidatoInput = {
    where: AvaliacaoWhereUniqueInput
    create: XOR<AvaliacaoCreateWithoutFichaCandidatoInput, AvaliacaoUncheckedCreateWithoutFichaCandidatoInput>
  }

  export type AvaliacaoCreateManyFichaCandidatoInputEnvelope = {
    data: AvaliacaoCreateManyFichaCandidatoInput | AvaliacaoCreateManyFichaCandidatoInput[]
    skipDuplicates?: boolean
  }

  export type AvaliacaoUpsertWithWhereUniqueWithoutFichaCandidatoInput = {
    where: AvaliacaoWhereUniqueInput
    update: XOR<AvaliacaoUpdateWithoutFichaCandidatoInput, AvaliacaoUncheckedUpdateWithoutFichaCandidatoInput>
    create: XOR<AvaliacaoCreateWithoutFichaCandidatoInput, AvaliacaoUncheckedCreateWithoutFichaCandidatoInput>
  }

  export type AvaliacaoUpdateWithWhereUniqueWithoutFichaCandidatoInput = {
    where: AvaliacaoWhereUniqueInput
    data: XOR<AvaliacaoUpdateWithoutFichaCandidatoInput, AvaliacaoUncheckedUpdateWithoutFichaCandidatoInput>
  }

  export type AvaliacaoUpdateManyWithWhereWithoutFichaCandidatoInput = {
    where: AvaliacaoScalarWhereInput
    data: XOR<AvaliacaoUpdateManyMutationInput, AvaliacaoUncheckedUpdateManyWithoutFichaCandidatoInput>
  }

  export type PreferenciaSorteioDancaCreateManyCandidatoInput = {
    idPreferencia?: number
    nomeSorteioDanca: $Enums.DancaSalaoTradicional
    sorteioDancaId?: number | null
  }

  export type AvaliacaoCreateManyCandidatoInput = {
    idAvalicao?: number
    dataAvaliacao?: Date | string
    comissaoId: number
    avaliadorId: number
    provaId: number
    blocoProvaId?: number | null
    nota: number
    fichaCandidatoIdFicha?: number | null
  }

  export type SorteioDancaCreateManyCandidatoInput = {
    idSorteio?: number
    resultadoSorteio: number
    dataSorteio?: Date | string
    tipoDanca: $Enums.DancaSalaoTradicional
    usuarioId: number
  }

  export type RecursoCreateManyCandidatoInput = {
    idRecurso?: number
    nomeRecurso: string
    justificativa: string
    status: boolean
    dataRecurso?: Date | string
    arquivos: Bytes
    avaliador: number
    quesitoRecurso: number
    provaTeoricaIdprovaTeorica?: number | null
    provaPraticaIdProvaPratica?: number | null
    provaIdProva?: number | null
  }

  export type PreferenciaSorteioDancaUpdateWithoutCandidatoInput = {
    nomeSorteioDanca?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
    SorteioDanca?: SorteioDancaUpdateOneWithoutPreferenciaSorteioDancaIdsNestedInput
    quesitos?: QuesitosUpdateManyWithoutPreferenciaSorteioDancaNestedInput
  }

  export type PreferenciaSorteioDancaUncheckedUpdateWithoutCandidatoInput = {
    idPreferencia?: IntFieldUpdateOperationsInput | number
    nomeSorteioDanca?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
    sorteioDancaId?: NullableIntFieldUpdateOperationsInput | number | null
    quesitos?: QuesitosUncheckedUpdateManyWithoutPreferenciaSorteioDancaNestedInput
  }

  export type PreferenciaSorteioDancaUncheckedUpdateManyWithoutCandidatoInput = {
    idPreferencia?: IntFieldUpdateOperationsInput | number
    nomeSorteioDanca?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
    sorteioDancaId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AvaliacaoUpdateWithoutCandidatoInput = {
    dataAvaliacao?: DateTimeFieldUpdateOperationsInput | Date | string
    nota?: FloatFieldUpdateOperationsInput | number
    Comissao?: ComissaoUpdateOneRequiredWithoutAvalicaoNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutAvalicoesNestedInput
    Prova?: ProvaUpdateOneWithoutAvaliacaoNestedInput
    BlocoProva?: BlocoProvaUpdateOneWithoutAvaliacaoNestedInput
    quesitos?: QuesitosUpdateManyWithoutAvaliacaoNestedInput
    FichaCandidato?: FichaCandidatoUpdateOneWithoutAvaliacoesNestedInput
  }

  export type AvaliacaoUncheckedUpdateWithoutCandidatoInput = {
    idAvalicao?: IntFieldUpdateOperationsInput | number
    dataAvaliacao?: DateTimeFieldUpdateOperationsInput | Date | string
    comissaoId?: IntFieldUpdateOperationsInput | number
    avaliadorId?: IntFieldUpdateOperationsInput | number
    provaId?: IntFieldUpdateOperationsInput | number
    blocoProvaId?: NullableIntFieldUpdateOperationsInput | number | null
    nota?: FloatFieldUpdateOperationsInput | number
    fichaCandidatoIdFicha?: NullableIntFieldUpdateOperationsInput | number | null
    quesitos?: QuesitosUncheckedUpdateManyWithoutAvaliacaoNestedInput
  }

  export type AvaliacaoUncheckedUpdateManyWithoutCandidatoInput = {
    idAvalicao?: IntFieldUpdateOperationsInput | number
    dataAvaliacao?: DateTimeFieldUpdateOperationsInput | Date | string
    comissaoId?: IntFieldUpdateOperationsInput | number
    avaliadorId?: IntFieldUpdateOperationsInput | number
    provaId?: IntFieldUpdateOperationsInput | number
    blocoProvaId?: NullableIntFieldUpdateOperationsInput | number | null
    nota?: FloatFieldUpdateOperationsInput | number
    fichaCandidatoIdFicha?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SorteioDancaUpdateWithoutCandidatoInput = {
    resultadoSorteio?: IntFieldUpdateOperationsInput | number
    dataSorteio?: DateTimeFieldUpdateOperationsInput | Date | string
    tipoDanca?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
    preferenciaSorteioDancaIds?: PreferenciaSorteioDancaUpdateManyWithoutSorteioDancaNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutSorteioDancaNestedInput
  }

  export type SorteioDancaUncheckedUpdateWithoutCandidatoInput = {
    idSorteio?: IntFieldUpdateOperationsInput | number
    resultadoSorteio?: IntFieldUpdateOperationsInput | number
    dataSorteio?: DateTimeFieldUpdateOperationsInput | Date | string
    tipoDanca?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
    usuarioId?: IntFieldUpdateOperationsInput | number
    preferenciaSorteioDancaIds?: PreferenciaSorteioDancaUncheckedUpdateManyWithoutSorteioDancaNestedInput
  }

  export type SorteioDancaUncheckedUpdateManyWithoutCandidatoInput = {
    idSorteio?: IntFieldUpdateOperationsInput | number
    resultadoSorteio?: IntFieldUpdateOperationsInput | number
    dataSorteio?: DateTimeFieldUpdateOperationsInput | Date | string
    tipoDanca?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
    usuarioId?: IntFieldUpdateOperationsInput | number
  }

  export type RecursoUpdateWithoutCandidatoInput = {
    nomeRecurso?: StringFieldUpdateOperationsInput | string
    justificativa?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dataRecurso?: DateTimeFieldUpdateOperationsInput | Date | string
    arquivos?: BytesFieldUpdateOperationsInput | Bytes
    Usuario?: UsuarioUpdateOneRequiredWithoutRecursosNestedInput
    Quesito?: QuesitosUpdateOneRequiredWithoutRecursosNestedInput
    ProvaTeorica?: ProvaTeoricaUpdateOneWithoutRecursoNestedInput
    ProvaPratica?: ProvaPraticaUpdateOneWithoutRecursoNestedInput
    Prova?: ProvaUpdateOneWithoutRecursosNestedInput
  }

  export type RecursoUncheckedUpdateWithoutCandidatoInput = {
    idRecurso?: IntFieldUpdateOperationsInput | number
    nomeRecurso?: StringFieldUpdateOperationsInput | string
    justificativa?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dataRecurso?: DateTimeFieldUpdateOperationsInput | Date | string
    arquivos?: BytesFieldUpdateOperationsInput | Bytes
    avaliador?: IntFieldUpdateOperationsInput | number
    quesitoRecurso?: IntFieldUpdateOperationsInput | number
    provaTeoricaIdprovaTeorica?: NullableIntFieldUpdateOperationsInput | number | null
    provaPraticaIdProvaPratica?: NullableIntFieldUpdateOperationsInput | number | null
    provaIdProva?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RecursoUncheckedUpdateManyWithoutCandidatoInput = {
    idRecurso?: IntFieldUpdateOperationsInput | number
    nomeRecurso?: StringFieldUpdateOperationsInput | string
    justificativa?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dataRecurso?: DateTimeFieldUpdateOperationsInput | Date | string
    arquivos?: BytesFieldUpdateOperationsInput | Bytes
    avaliador?: IntFieldUpdateOperationsInput | number
    quesitoRecurso?: IntFieldUpdateOperationsInput | number
    provaTeoricaIdprovaTeorica?: NullableIntFieldUpdateOperationsInput | number | null
    provaPraticaIdProvaPratica?: NullableIntFieldUpdateOperationsInput | number | null
    provaIdProva?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AvaliacaoCreateManyUsuarioInput = {
    idAvalicao?: number
    dataAvaliacao?: Date | string
    comissaoId: number
    provaId: number
    blocoProvaId?: number | null
    nota: number
    candidatoId: number
    fichaCandidatoIdFicha?: number | null
  }

  export type RecursoCreateManyUsuarioInput = {
    idRecurso?: number
    nomeRecurso: string
    justificativa: string
    status: boolean
    dataRecurso?: Date | string
    arquivos: Bytes
    candidato: number
    quesitoRecurso: number
    provaTeoricaIdprovaTeorica?: number | null
    provaPraticaIdProvaPratica?: number | null
    provaIdProva?: number | null
  }

  export type SorteioDancaCreateManyUsuarioInput = {
    idSorteio?: number
    resultadoSorteio: number
    dataSorteio?: Date | string
    tipoDanca: $Enums.DancaSalaoTradicional
    candidatoId: number
  }

  export type AvaliacaoUpdateWithoutUsuarioInput = {
    dataAvaliacao?: DateTimeFieldUpdateOperationsInput | Date | string
    nota?: FloatFieldUpdateOperationsInput | number
    Comissao?: ComissaoUpdateOneRequiredWithoutAvalicaoNestedInput
    Prova?: ProvaUpdateOneWithoutAvaliacaoNestedInput
    BlocoProva?: BlocoProvaUpdateOneWithoutAvaliacaoNestedInput
    quesitos?: QuesitosUpdateManyWithoutAvaliacaoNestedInput
    Candidato?: CandidatoUpdateOneRequiredWithoutAvalicoesNestedInput
    FichaCandidato?: FichaCandidatoUpdateOneWithoutAvaliacoesNestedInput
  }

  export type AvaliacaoUncheckedUpdateWithoutUsuarioInput = {
    idAvalicao?: IntFieldUpdateOperationsInput | number
    dataAvaliacao?: DateTimeFieldUpdateOperationsInput | Date | string
    comissaoId?: IntFieldUpdateOperationsInput | number
    provaId?: IntFieldUpdateOperationsInput | number
    blocoProvaId?: NullableIntFieldUpdateOperationsInput | number | null
    nota?: FloatFieldUpdateOperationsInput | number
    candidatoId?: IntFieldUpdateOperationsInput | number
    fichaCandidatoIdFicha?: NullableIntFieldUpdateOperationsInput | number | null
    quesitos?: QuesitosUncheckedUpdateManyWithoutAvaliacaoNestedInput
  }

  export type AvaliacaoUncheckedUpdateManyWithoutUsuarioInput = {
    idAvalicao?: IntFieldUpdateOperationsInput | number
    dataAvaliacao?: DateTimeFieldUpdateOperationsInput | Date | string
    comissaoId?: IntFieldUpdateOperationsInput | number
    provaId?: IntFieldUpdateOperationsInput | number
    blocoProvaId?: NullableIntFieldUpdateOperationsInput | number | null
    nota?: FloatFieldUpdateOperationsInput | number
    candidatoId?: IntFieldUpdateOperationsInput | number
    fichaCandidatoIdFicha?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RecursoUpdateWithoutUsuarioInput = {
    nomeRecurso?: StringFieldUpdateOperationsInput | string
    justificativa?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dataRecurso?: DateTimeFieldUpdateOperationsInput | Date | string
    arquivos?: BytesFieldUpdateOperationsInput | Bytes
    Candidato?: CandidatoUpdateOneRequiredWithoutRecursoNestedInput
    Quesito?: QuesitosUpdateOneRequiredWithoutRecursosNestedInput
    ProvaTeorica?: ProvaTeoricaUpdateOneWithoutRecursoNestedInput
    ProvaPratica?: ProvaPraticaUpdateOneWithoutRecursoNestedInput
    Prova?: ProvaUpdateOneWithoutRecursosNestedInput
  }

  export type RecursoUncheckedUpdateWithoutUsuarioInput = {
    idRecurso?: IntFieldUpdateOperationsInput | number
    nomeRecurso?: StringFieldUpdateOperationsInput | string
    justificativa?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dataRecurso?: DateTimeFieldUpdateOperationsInput | Date | string
    arquivos?: BytesFieldUpdateOperationsInput | Bytes
    candidato?: IntFieldUpdateOperationsInput | number
    quesitoRecurso?: IntFieldUpdateOperationsInput | number
    provaTeoricaIdprovaTeorica?: NullableIntFieldUpdateOperationsInput | number | null
    provaPraticaIdProvaPratica?: NullableIntFieldUpdateOperationsInput | number | null
    provaIdProva?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RecursoUncheckedUpdateManyWithoutUsuarioInput = {
    idRecurso?: IntFieldUpdateOperationsInput | number
    nomeRecurso?: StringFieldUpdateOperationsInput | string
    justificativa?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dataRecurso?: DateTimeFieldUpdateOperationsInput | Date | string
    arquivos?: BytesFieldUpdateOperationsInput | Bytes
    candidato?: IntFieldUpdateOperationsInput | number
    quesitoRecurso?: IntFieldUpdateOperationsInput | number
    provaTeoricaIdprovaTeorica?: NullableIntFieldUpdateOperationsInput | number | null
    provaPraticaIdProvaPratica?: NullableIntFieldUpdateOperationsInput | number | null
    provaIdProva?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SorteioDancaUpdateWithoutUsuarioInput = {
    resultadoSorteio?: IntFieldUpdateOperationsInput | number
    dataSorteio?: DateTimeFieldUpdateOperationsInput | Date | string
    tipoDanca?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
    preferenciaSorteioDancaIds?: PreferenciaSorteioDancaUpdateManyWithoutSorteioDancaNestedInput
    Candidato?: CandidatoUpdateOneRequiredWithoutSorteioDancaNestedInput
  }

  export type SorteioDancaUncheckedUpdateWithoutUsuarioInput = {
    idSorteio?: IntFieldUpdateOperationsInput | number
    resultadoSorteio?: IntFieldUpdateOperationsInput | number
    dataSorteio?: DateTimeFieldUpdateOperationsInput | Date | string
    tipoDanca?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
    candidatoId?: IntFieldUpdateOperationsInput | number
    preferenciaSorteioDancaIds?: PreferenciaSorteioDancaUncheckedUpdateManyWithoutSorteioDancaNestedInput
  }

  export type SorteioDancaUncheckedUpdateManyWithoutUsuarioInput = {
    idSorteio?: IntFieldUpdateOperationsInput | number
    resultadoSorteio?: IntFieldUpdateOperationsInput | number
    dataSorteio?: DateTimeFieldUpdateOperationsInput | Date | string
    tipoDanca?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
    candidatoId?: IntFieldUpdateOperationsInput | number
  }

  export type UsuarioCreateManyCTGInput = {
    idUsuario?: number
    nomeCompleto: string
    cidade: string
    estado: string
    numCarteirinha: string
    login: string
    senha: string
    funcao: $Enums.Funcao
    credenciamento?: $Enums.Credenciamento
    numCredenciamento?: number | null
    comissaoUsuarioId?: number | null
  }

  export type CandidatoCreateManyCTGInput = {
    idCandidato?: number
    nomeCompleto: string
    cidade: string
    estado: string
    numCarteirinha: string
    CPF: string
    RG: string
    endereco: string
    numEndereco: number
    bairro: string
    escolaridade: string
    filiacao: string
    ProvaCampeiraEsportiva?: $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: Bytes | null
    anexoCarteirinha?: Bytes | null
    anexoEscolaridade?: Bytes | null
    anexoResidencia?: Bytes | null
    anexoAtaConcurso?: Bytes | null
    fichaInscricao?: Bytes | null
    anexoTermoCandidato?: Bytes | null
    anexoRelatorioVivencia?: Bytes | null
    anexoResponsavel?: Bytes | null
    anexoProvaEsportivaCampeira?: Bytes | null
    categoriaId: number
    concursoIdConcurso?: number | null
  }

  export type UsuarioUpdateWithoutCTGInput = {
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    numCarteirinha?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    funcao?: EnumFuncaoFieldUpdateOperationsInput | $Enums.Funcao
    credenciamento?: EnumCredenciamentoFieldUpdateOperationsInput | $Enums.Credenciamento
    numCredenciamento?: NullableIntFieldUpdateOperationsInput | number | null
    comissaoUsuarioId?: NullableIntFieldUpdateOperationsInput | number | null
    ComissaoUsuario?: ComissaoUsuarioUpdateOneWithoutUsuariosNestedInput
    avalicoes?: AvaliacaoUpdateManyWithoutUsuarioNestedInput
    recursos?: RecursoUpdateManyWithoutUsuarioNestedInput
    sorteioDanca?: SorteioDancaUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutCTGInput = {
    idUsuario?: IntFieldUpdateOperationsInput | number
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    numCarteirinha?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    funcao?: EnumFuncaoFieldUpdateOperationsInput | $Enums.Funcao
    credenciamento?: EnumCredenciamentoFieldUpdateOperationsInput | $Enums.Credenciamento
    numCredenciamento?: NullableIntFieldUpdateOperationsInput | number | null
    comissaoUsuarioId?: NullableIntFieldUpdateOperationsInput | number | null
    ComissaoUsuario?: ComissaoUsuarioUncheckedUpdateOneWithoutUsuariosNestedInput
    avalicoes?: AvaliacaoUncheckedUpdateManyWithoutUsuarioNestedInput
    recursos?: RecursoUncheckedUpdateManyWithoutUsuarioNestedInput
    sorteioDanca?: SorteioDancaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateManyWithoutCTGInput = {
    idUsuario?: IntFieldUpdateOperationsInput | number
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    numCarteirinha?: StringFieldUpdateOperationsInput | string
    login?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    funcao?: EnumFuncaoFieldUpdateOperationsInput | $Enums.Funcao
    credenciamento?: EnumCredenciamentoFieldUpdateOperationsInput | $Enums.Credenciamento
    numCredenciamento?: NullableIntFieldUpdateOperationsInput | number | null
    comissaoUsuarioId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CandidatoUpdateWithoutCTGInput = {
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    numCarteirinha?: StringFieldUpdateOperationsInput | string
    CPF?: StringFieldUpdateOperationsInput | string
    RG?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    numEndereco?: IntFieldUpdateOperationsInput | number
    bairro?: StringFieldUpdateOperationsInput | string
    escolaridade?: StringFieldUpdateOperationsInput | string
    filiacao?: StringFieldUpdateOperationsInput | string
    ProvaCampeiraEsportiva?: NullableEnumProvaCampeiraEsportivaFieldUpdateOperationsInput | $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoCarteirinha?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoEscolaridade?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoResidencia?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoAtaConcurso?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    fichaInscricao?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoTermoCandidato?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoRelatorioVivencia?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoResponsavel?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoProvaEsportivaCampeira?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaUpdateManyWithoutCandidatoNestedInput
    Categoria?: CategoriaUpdateOneRequiredWithoutCandidatosNestedInput
    avalicoes?: AvaliacaoUpdateManyWithoutCandidatoNestedInput
    sorteioDanca?: SorteioDancaUpdateManyWithoutCandidatoNestedInput
    Recurso?: RecursoUpdateManyWithoutCandidatoNestedInput
    Concurso?: ConcursoUpdateOneWithoutCandidatosNestedInput
  }

  export type CandidatoUncheckedUpdateWithoutCTGInput = {
    idCandidato?: IntFieldUpdateOperationsInput | number
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    numCarteirinha?: StringFieldUpdateOperationsInput | string
    CPF?: StringFieldUpdateOperationsInput | string
    RG?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    numEndereco?: IntFieldUpdateOperationsInput | number
    bairro?: StringFieldUpdateOperationsInput | string
    escolaridade?: StringFieldUpdateOperationsInput | string
    filiacao?: StringFieldUpdateOperationsInput | string
    ProvaCampeiraEsportiva?: NullableEnumProvaCampeiraEsportivaFieldUpdateOperationsInput | $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoCarteirinha?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoEscolaridade?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoResidencia?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoAtaConcurso?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    fichaInscricao?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoTermoCandidato?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoRelatorioVivencia?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoResponsavel?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoProvaEsportivaCampeira?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    categoriaId?: IntFieldUpdateOperationsInput | number
    concursoIdConcurso?: NullableIntFieldUpdateOperationsInput | number | null
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaUncheckedUpdateManyWithoutCandidatoNestedInput
    avalicoes?: AvaliacaoUncheckedUpdateManyWithoutCandidatoNestedInput
    sorteioDanca?: SorteioDancaUncheckedUpdateManyWithoutCandidatoNestedInput
    Recurso?: RecursoUncheckedUpdateManyWithoutCandidatoNestedInput
  }

  export type CandidatoUncheckedUpdateManyWithoutCTGInput = {
    idCandidato?: IntFieldUpdateOperationsInput | number
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    numCarteirinha?: StringFieldUpdateOperationsInput | string
    CPF?: StringFieldUpdateOperationsInput | string
    RG?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    numEndereco?: IntFieldUpdateOperationsInput | number
    bairro?: StringFieldUpdateOperationsInput | string
    escolaridade?: StringFieldUpdateOperationsInput | string
    filiacao?: StringFieldUpdateOperationsInput | string
    ProvaCampeiraEsportiva?: NullableEnumProvaCampeiraEsportivaFieldUpdateOperationsInput | $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoCarteirinha?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoEscolaridade?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoResidencia?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoAtaConcurso?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    fichaInscricao?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoTermoCandidato?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoRelatorioVivencia?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoResponsavel?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoProvaEsportivaCampeira?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    categoriaId?: IntFieldUpdateOperationsInput | number
    concursoIdConcurso?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CTGCreateManyRTInput = {
    idCTG?: number
    nomeCTG: string
  }

  export type CTGUpdateWithoutRTInput = {
    nomeCTG?: StringFieldUpdateOperationsInput | string
    Usuario?: UsuarioUpdateManyWithoutCTGNestedInput
    Candidato?: CandidatoUpdateManyWithoutCTGNestedInput
  }

  export type CTGUncheckedUpdateWithoutRTInput = {
    idCTG?: IntFieldUpdateOperationsInput | number
    nomeCTG?: StringFieldUpdateOperationsInput | string
    Usuario?: UsuarioUncheckedUpdateManyWithoutCTGNestedInput
    Candidato?: CandidatoUncheckedUpdateManyWithoutCTGNestedInput
  }

  export type CTGUncheckedUpdateManyWithoutRTInput = {
    idCTG?: IntFieldUpdateOperationsInput | number
    nomeCTG?: StringFieldUpdateOperationsInput | string
  }

  export type QuesitosCreateManyPreferenciaSorteioDancaInput = {
    idQuesito?: number
    nomeQuesito: string
    notaMaximaQuesito: number
    danca: boolean
    dancaSalaoTradicional: $Enums.DancaSalaoTradicional
    blocoProvaIdBloco?: number | null
    provaTeoricaIdprovaTeorica?: number | null
    avaliacaoIdAvalicao?: number | null
  }

  export type QuesitosUpdateWithoutPreferenciaSorteioDancaInput = {
    nomeQuesito?: StringFieldUpdateOperationsInput | string
    notaMaximaQuesito?: FloatFieldUpdateOperationsInput | number
    danca?: BoolFieldUpdateOperationsInput | boolean
    dancaSalaoTradicional?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
    BlocoProva?: BlocoProvaUpdateOneWithoutQuesitosNestedInput
    ProvaTeorica?: ProvaTeoricaUpdateOneWithoutQuesitosNestedInput
    subeQuesitos?: SubQuesitosUpdateManyWithoutQuesitoNestedInput
    recursos?: RecursoUpdateManyWithoutQuesitoNestedInput
    Avaliacao?: AvaliacaoUpdateOneWithoutQuesitosNestedInput
  }

  export type QuesitosUncheckedUpdateWithoutPreferenciaSorteioDancaInput = {
    idQuesito?: IntFieldUpdateOperationsInput | number
    nomeQuesito?: StringFieldUpdateOperationsInput | string
    notaMaximaQuesito?: FloatFieldUpdateOperationsInput | number
    danca?: BoolFieldUpdateOperationsInput | boolean
    dancaSalaoTradicional?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
    blocoProvaIdBloco?: NullableIntFieldUpdateOperationsInput | number | null
    provaTeoricaIdprovaTeorica?: NullableIntFieldUpdateOperationsInput | number | null
    avaliacaoIdAvalicao?: NullableIntFieldUpdateOperationsInput | number | null
    subeQuesitos?: SubQuesitosUncheckedUpdateManyWithoutQuesitoNestedInput
    recursos?: RecursoUncheckedUpdateManyWithoutQuesitoNestedInput
  }

  export type QuesitosUncheckedUpdateManyWithoutPreferenciaSorteioDancaInput = {
    idQuesito?: IntFieldUpdateOperationsInput | number
    nomeQuesito?: StringFieldUpdateOperationsInput | string
    notaMaximaQuesito?: FloatFieldUpdateOperationsInput | number
    danca?: BoolFieldUpdateOperationsInput | boolean
    dancaSalaoTradicional?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
    blocoProvaIdBloco?: NullableIntFieldUpdateOperationsInput | number | null
    provaTeoricaIdprovaTeorica?: NullableIntFieldUpdateOperationsInput | number | null
    avaliacaoIdAvalicao?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CandidatoCreateManyConcursoInput = {
    idCandidato?: number
    nomeCompleto: string
    cidade: string
    estado: string
    CTGId: number
    numCarteirinha: string
    CPF: string
    RG: string
    endereco: string
    numEndereco: number
    bairro: string
    escolaridade: string
    filiacao: string
    ProvaCampeiraEsportiva?: $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: Bytes | null
    anexoCarteirinha?: Bytes | null
    anexoEscolaridade?: Bytes | null
    anexoResidencia?: Bytes | null
    anexoAtaConcurso?: Bytes | null
    fichaInscricao?: Bytes | null
    anexoTermoCandidato?: Bytes | null
    anexoRelatorioVivencia?: Bytes | null
    anexoResponsavel?: Bytes | null
    anexoProvaEsportivaCampeira?: Bytes | null
    categoriaId: number
  }

  export type ComissaoCreateManyConcursoInput = {
    idComissao?: number
    nomeComissao: string
  }

  export type CandidatoUpdateWithoutConcursoInput = {
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    numCarteirinha?: StringFieldUpdateOperationsInput | string
    CPF?: StringFieldUpdateOperationsInput | string
    RG?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    numEndereco?: IntFieldUpdateOperationsInput | number
    bairro?: StringFieldUpdateOperationsInput | string
    escolaridade?: StringFieldUpdateOperationsInput | string
    filiacao?: StringFieldUpdateOperationsInput | string
    ProvaCampeiraEsportiva?: NullableEnumProvaCampeiraEsportivaFieldUpdateOperationsInput | $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoCarteirinha?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoEscolaridade?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoResidencia?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoAtaConcurso?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    fichaInscricao?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoTermoCandidato?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoRelatorioVivencia?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoResponsavel?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoProvaEsportivaCampeira?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    CTG?: CTGUpdateOneRequiredWithoutCandidatoNestedInput
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaUpdateManyWithoutCandidatoNestedInput
    Categoria?: CategoriaUpdateOneRequiredWithoutCandidatosNestedInput
    avalicoes?: AvaliacaoUpdateManyWithoutCandidatoNestedInput
    sorteioDanca?: SorteioDancaUpdateManyWithoutCandidatoNestedInput
    Recurso?: RecursoUpdateManyWithoutCandidatoNestedInput
  }

  export type CandidatoUncheckedUpdateWithoutConcursoInput = {
    idCandidato?: IntFieldUpdateOperationsInput | number
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    CTGId?: IntFieldUpdateOperationsInput | number
    numCarteirinha?: StringFieldUpdateOperationsInput | string
    CPF?: StringFieldUpdateOperationsInput | string
    RG?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    numEndereco?: IntFieldUpdateOperationsInput | number
    bairro?: StringFieldUpdateOperationsInput | string
    escolaridade?: StringFieldUpdateOperationsInput | string
    filiacao?: StringFieldUpdateOperationsInput | string
    ProvaCampeiraEsportiva?: NullableEnumProvaCampeiraEsportivaFieldUpdateOperationsInput | $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoCarteirinha?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoEscolaridade?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoResidencia?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoAtaConcurso?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    fichaInscricao?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoTermoCandidato?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoRelatorioVivencia?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoResponsavel?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoProvaEsportivaCampeira?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    categoriaId?: IntFieldUpdateOperationsInput | number
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaUncheckedUpdateManyWithoutCandidatoNestedInput
    avalicoes?: AvaliacaoUncheckedUpdateManyWithoutCandidatoNestedInput
    sorteioDanca?: SorteioDancaUncheckedUpdateManyWithoutCandidatoNestedInput
    Recurso?: RecursoUncheckedUpdateManyWithoutCandidatoNestedInput
  }

  export type CandidatoUncheckedUpdateManyWithoutConcursoInput = {
    idCandidato?: IntFieldUpdateOperationsInput | number
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    CTGId?: IntFieldUpdateOperationsInput | number
    numCarteirinha?: StringFieldUpdateOperationsInput | string
    CPF?: StringFieldUpdateOperationsInput | string
    RG?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    numEndereco?: IntFieldUpdateOperationsInput | number
    bairro?: StringFieldUpdateOperationsInput | string
    escolaridade?: StringFieldUpdateOperationsInput | string
    filiacao?: StringFieldUpdateOperationsInput | string
    ProvaCampeiraEsportiva?: NullableEnumProvaCampeiraEsportivaFieldUpdateOperationsInput | $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoCarteirinha?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoEscolaridade?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoResidencia?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoAtaConcurso?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    fichaInscricao?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoTermoCandidato?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoRelatorioVivencia?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoResponsavel?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoProvaEsportivaCampeira?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    categoriaId?: IntFieldUpdateOperationsInput | number
  }

  export type ComissaoUpdateWithoutConcursoInput = {
    nomeComissao?: StringFieldUpdateOperationsInput | string
    avalicao?: AvaliacaoUpdateManyWithoutComissaoNestedInput
    usuarios?: ComissaoUsuarioUpdateManyWithoutComissaoNestedInput
  }

  export type ComissaoUncheckedUpdateWithoutConcursoInput = {
    idComissao?: IntFieldUpdateOperationsInput | number
    nomeComissao?: StringFieldUpdateOperationsInput | string
    avalicao?: AvaliacaoUncheckedUpdateManyWithoutComissaoNestedInput
    usuarios?: ComissaoUsuarioUncheckedUpdateManyWithoutComissaoNestedInput
  }

  export type ComissaoUncheckedUpdateManyWithoutConcursoInput = {
    idComissao?: IntFieldUpdateOperationsInput | number
    nomeComissao?: StringFieldUpdateOperationsInput | string
  }

  export type AvaliacaoCreateManyComissaoInput = {
    idAvalicao?: number
    dataAvaliacao?: Date | string
    avaliadorId: number
    provaId: number
    blocoProvaId?: number | null
    nota: number
    candidatoId: number
    fichaCandidatoIdFicha?: number | null
  }

  export type ComissaoUsuarioCreateManyComissaoInput = {
    idComissaoUsuario?: number
    usuarioId: number
  }

  export type AvaliacaoUpdateWithoutComissaoInput = {
    dataAvaliacao?: DateTimeFieldUpdateOperationsInput | Date | string
    nota?: FloatFieldUpdateOperationsInput | number
    Usuario?: UsuarioUpdateOneRequiredWithoutAvalicoesNestedInput
    Prova?: ProvaUpdateOneWithoutAvaliacaoNestedInput
    BlocoProva?: BlocoProvaUpdateOneWithoutAvaliacaoNestedInput
    quesitos?: QuesitosUpdateManyWithoutAvaliacaoNestedInput
    Candidato?: CandidatoUpdateOneRequiredWithoutAvalicoesNestedInput
    FichaCandidato?: FichaCandidatoUpdateOneWithoutAvaliacoesNestedInput
  }

  export type AvaliacaoUncheckedUpdateWithoutComissaoInput = {
    idAvalicao?: IntFieldUpdateOperationsInput | number
    dataAvaliacao?: DateTimeFieldUpdateOperationsInput | Date | string
    avaliadorId?: IntFieldUpdateOperationsInput | number
    provaId?: IntFieldUpdateOperationsInput | number
    blocoProvaId?: NullableIntFieldUpdateOperationsInput | number | null
    nota?: FloatFieldUpdateOperationsInput | number
    candidatoId?: IntFieldUpdateOperationsInput | number
    fichaCandidatoIdFicha?: NullableIntFieldUpdateOperationsInput | number | null
    quesitos?: QuesitosUncheckedUpdateManyWithoutAvaliacaoNestedInput
  }

  export type AvaliacaoUncheckedUpdateManyWithoutComissaoInput = {
    idAvalicao?: IntFieldUpdateOperationsInput | number
    dataAvaliacao?: DateTimeFieldUpdateOperationsInput | Date | string
    avaliadorId?: IntFieldUpdateOperationsInput | number
    provaId?: IntFieldUpdateOperationsInput | number
    blocoProvaId?: NullableIntFieldUpdateOperationsInput | number | null
    nota?: FloatFieldUpdateOperationsInput | number
    candidatoId?: IntFieldUpdateOperationsInput | number
    fichaCandidatoIdFicha?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ComissaoUsuarioUpdateWithoutComissaoInput = {
    Usuarios?: UsuarioUpdateOneRequiredWithoutComissaoUsuarioNestedInput
  }

  export type ComissaoUsuarioUncheckedUpdateWithoutComissaoInput = {
    idComissaoUsuario?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
  }

  export type ComissaoUsuarioUncheckedUpdateManyWithoutComissaoInput = {
    idComissaoUsuario?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
  }

  export type CandidatoCreateManyCategoriaInput = {
    idCandidato?: number
    nomeCompleto: string
    cidade: string
    estado: string
    CTGId: number
    numCarteirinha: string
    CPF: string
    RG: string
    endereco: string
    numEndereco: number
    bairro: string
    escolaridade: string
    filiacao: string
    ProvaCampeiraEsportiva?: $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: Bytes | null
    anexoCarteirinha?: Bytes | null
    anexoEscolaridade?: Bytes | null
    anexoResidencia?: Bytes | null
    anexoAtaConcurso?: Bytes | null
    fichaInscricao?: Bytes | null
    anexoTermoCandidato?: Bytes | null
    anexoRelatorioVivencia?: Bytes | null
    anexoResponsavel?: Bytes | null
    anexoProvaEsportivaCampeira?: Bytes | null
    concursoIdConcurso?: number | null
  }

  export type CandidatoUpdateWithoutCategoriaInput = {
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    numCarteirinha?: StringFieldUpdateOperationsInput | string
    CPF?: StringFieldUpdateOperationsInput | string
    RG?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    numEndereco?: IntFieldUpdateOperationsInput | number
    bairro?: StringFieldUpdateOperationsInput | string
    escolaridade?: StringFieldUpdateOperationsInput | string
    filiacao?: StringFieldUpdateOperationsInput | string
    ProvaCampeiraEsportiva?: NullableEnumProvaCampeiraEsportivaFieldUpdateOperationsInput | $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoCarteirinha?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoEscolaridade?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoResidencia?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoAtaConcurso?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    fichaInscricao?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoTermoCandidato?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoRelatorioVivencia?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoResponsavel?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoProvaEsportivaCampeira?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    CTG?: CTGUpdateOneRequiredWithoutCandidatoNestedInput
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaUpdateManyWithoutCandidatoNestedInput
    avalicoes?: AvaliacaoUpdateManyWithoutCandidatoNestedInput
    sorteioDanca?: SorteioDancaUpdateManyWithoutCandidatoNestedInput
    Recurso?: RecursoUpdateManyWithoutCandidatoNestedInput
    Concurso?: ConcursoUpdateOneWithoutCandidatosNestedInput
  }

  export type CandidatoUncheckedUpdateWithoutCategoriaInput = {
    idCandidato?: IntFieldUpdateOperationsInput | number
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    CTGId?: IntFieldUpdateOperationsInput | number
    numCarteirinha?: StringFieldUpdateOperationsInput | string
    CPF?: StringFieldUpdateOperationsInput | string
    RG?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    numEndereco?: IntFieldUpdateOperationsInput | number
    bairro?: StringFieldUpdateOperationsInput | string
    escolaridade?: StringFieldUpdateOperationsInput | string
    filiacao?: StringFieldUpdateOperationsInput | string
    ProvaCampeiraEsportiva?: NullableEnumProvaCampeiraEsportivaFieldUpdateOperationsInput | $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoCarteirinha?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoEscolaridade?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoResidencia?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoAtaConcurso?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    fichaInscricao?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoTermoCandidato?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoRelatorioVivencia?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoResponsavel?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoProvaEsportivaCampeira?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    concursoIdConcurso?: NullableIntFieldUpdateOperationsInput | number | null
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaUncheckedUpdateManyWithoutCandidatoNestedInput
    avalicoes?: AvaliacaoUncheckedUpdateManyWithoutCandidatoNestedInput
    sorteioDanca?: SorteioDancaUncheckedUpdateManyWithoutCandidatoNestedInput
    Recurso?: RecursoUncheckedUpdateManyWithoutCandidatoNestedInput
  }

  export type CandidatoUncheckedUpdateManyWithoutCategoriaInput = {
    idCandidato?: IntFieldUpdateOperationsInput | number
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    CTGId?: IntFieldUpdateOperationsInput | number
    numCarteirinha?: StringFieldUpdateOperationsInput | string
    CPF?: StringFieldUpdateOperationsInput | string
    RG?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    numEndereco?: IntFieldUpdateOperationsInput | number
    bairro?: StringFieldUpdateOperationsInput | string
    escolaridade?: StringFieldUpdateOperationsInput | string
    filiacao?: StringFieldUpdateOperationsInput | string
    ProvaCampeiraEsportiva?: NullableEnumProvaCampeiraEsportivaFieldUpdateOperationsInput | $Enums.ProvaCampeiraEsportiva | null
    anexoDocumento?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoCarteirinha?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoEscolaridade?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoResidencia?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoAtaConcurso?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    fichaInscricao?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoTermoCandidato?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoRelatorioVivencia?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoResponsavel?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    anexoProvaEsportivaCampeira?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    concursoIdConcurso?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuesitosCreateManyAvaliacaoInput = {
    idQuesito?: number
    nomeQuesito: string
    notaMaximaQuesito: number
    danca: boolean
    dancaSalaoTradicional: $Enums.DancaSalaoTradicional
    blocoProvaIdBloco?: number | null
    provaTeoricaIdprovaTeorica?: number | null
    preferenciaSorteioDancaId?: number | null
  }

  export type QuesitosUpdateWithoutAvaliacaoInput = {
    nomeQuesito?: StringFieldUpdateOperationsInput | string
    notaMaximaQuesito?: FloatFieldUpdateOperationsInput | number
    danca?: BoolFieldUpdateOperationsInput | boolean
    dancaSalaoTradicional?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
    BlocoProva?: BlocoProvaUpdateOneWithoutQuesitosNestedInput
    ProvaTeorica?: ProvaTeoricaUpdateOneWithoutQuesitosNestedInput
    subeQuesitos?: SubQuesitosUpdateManyWithoutQuesitoNestedInput
    recursos?: RecursoUpdateManyWithoutQuesitoNestedInput
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaUpdateOneWithoutQuesitosNestedInput
  }

  export type QuesitosUncheckedUpdateWithoutAvaliacaoInput = {
    idQuesito?: IntFieldUpdateOperationsInput | number
    nomeQuesito?: StringFieldUpdateOperationsInput | string
    notaMaximaQuesito?: FloatFieldUpdateOperationsInput | number
    danca?: BoolFieldUpdateOperationsInput | boolean
    dancaSalaoTradicional?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
    blocoProvaIdBloco?: NullableIntFieldUpdateOperationsInput | number | null
    provaTeoricaIdprovaTeorica?: NullableIntFieldUpdateOperationsInput | number | null
    preferenciaSorteioDancaId?: NullableIntFieldUpdateOperationsInput | number | null
    subeQuesitos?: SubQuesitosUncheckedUpdateManyWithoutQuesitoNestedInput
    recursos?: RecursoUncheckedUpdateManyWithoutQuesitoNestedInput
  }

  export type QuesitosUncheckedUpdateManyWithoutAvaliacaoInput = {
    idQuesito?: IntFieldUpdateOperationsInput | number
    nomeQuesito?: StringFieldUpdateOperationsInput | string
    notaMaximaQuesito?: FloatFieldUpdateOperationsInput | number
    danca?: BoolFieldUpdateOperationsInput | boolean
    dancaSalaoTradicional?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
    blocoProvaIdBloco?: NullableIntFieldUpdateOperationsInput | number | null
    provaTeoricaIdprovaTeorica?: NullableIntFieldUpdateOperationsInput | number | null
    preferenciaSorteioDancaId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CategoriaCreateManyProvaInput = {
    idCategoria?: number
    nomeCategoria: string
    escolaridade: string
    sorteioDanca: number
    idadeInicial: number
    idadeLimite?: number | null
    provaTeoricaId?: number | null
    provaPraticaId?: number | null
  }

  export type ProvaTeoricaCreateManyProvaInput = {
    idprovaTeorica?: number
    gabaritoOficinal: Bytes
    numQuestao: number
  }

  export type ProvaPraticaCreateManyProvaInput = {
    idProvaPratica?: number
  }

  export type RecursoCreateManyProvaInput = {
    idRecurso?: number
    nomeRecurso: string
    justificativa: string
    status: boolean
    dataRecurso?: Date | string
    arquivos: Bytes
    candidato: number
    avaliador: number
    quesitoRecurso: number
    provaTeoricaIdprovaTeorica?: number | null
    provaPraticaIdProvaPratica?: number | null
  }

  export type AvaliacaoCreateManyProvaInput = {
    idAvalicao?: number
    dataAvaliacao?: Date | string
    comissaoId: number
    avaliadorId: number
    blocoProvaId?: number | null
    nota: number
    candidatoId: number
    fichaCandidatoIdFicha?: number | null
  }

  export type CategoriaUpdateWithoutProvaInput = {
    nomeCategoria?: StringFieldUpdateOperationsInput | string
    escolaridade?: StringFieldUpdateOperationsInput | string
    sorteioDanca?: IntFieldUpdateOperationsInput | number
    idadeInicial?: IntFieldUpdateOperationsInput | number
    idadeLimite?: NullableIntFieldUpdateOperationsInput | number | null
    candidatos?: CandidatoUpdateManyWithoutCategoriaNestedInput
    ProvaTeorica?: ProvaTeoricaUpdateOneWithoutCategoriaNestedInput
    ProvaPratica?: ProvaPraticaUpdateOneWithoutCategoriaNestedInput
  }

  export type CategoriaUncheckedUpdateWithoutProvaInput = {
    idCategoria?: IntFieldUpdateOperationsInput | number
    nomeCategoria?: StringFieldUpdateOperationsInput | string
    escolaridade?: StringFieldUpdateOperationsInput | string
    sorteioDanca?: IntFieldUpdateOperationsInput | number
    idadeInicial?: IntFieldUpdateOperationsInput | number
    idadeLimite?: NullableIntFieldUpdateOperationsInput | number | null
    provaTeoricaId?: NullableIntFieldUpdateOperationsInput | number | null
    provaPraticaId?: NullableIntFieldUpdateOperationsInput | number | null
    candidatos?: CandidatoUncheckedUpdateManyWithoutCategoriaNestedInput
  }

  export type CategoriaUncheckedUpdateManyWithoutProvaInput = {
    idCategoria?: IntFieldUpdateOperationsInput | number
    nomeCategoria?: StringFieldUpdateOperationsInput | string
    escolaridade?: StringFieldUpdateOperationsInput | string
    sorteioDanca?: IntFieldUpdateOperationsInput | number
    idadeInicial?: IntFieldUpdateOperationsInput | number
    idadeLimite?: NullableIntFieldUpdateOperationsInput | number | null
    provaTeoricaId?: NullableIntFieldUpdateOperationsInput | number | null
    provaPraticaId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProvaTeoricaUpdateWithoutProvaInput = {
    gabaritoOficinal?: BytesFieldUpdateOperationsInput | Bytes
    numQuestao?: IntFieldUpdateOperationsInput | number
    quesitos?: QuesitosUpdateManyWithoutProvaTeoricaNestedInput
    Categoria?: CategoriaUpdateManyWithoutProvaTeoricaNestedInput
    Recurso?: RecursoUpdateManyWithoutProvaTeoricaNestedInput
  }

  export type ProvaTeoricaUncheckedUpdateWithoutProvaInput = {
    idprovaTeorica?: IntFieldUpdateOperationsInput | number
    gabaritoOficinal?: BytesFieldUpdateOperationsInput | Bytes
    numQuestao?: IntFieldUpdateOperationsInput | number
    quesitos?: QuesitosUncheckedUpdateManyWithoutProvaTeoricaNestedInput
    Categoria?: CategoriaUncheckedUpdateManyWithoutProvaTeoricaNestedInput
    Recurso?: RecursoUncheckedUpdateManyWithoutProvaTeoricaNestedInput
  }

  export type ProvaTeoricaUncheckedUpdateManyWithoutProvaInput = {
    idprovaTeorica?: IntFieldUpdateOperationsInput | number
    gabaritoOficinal?: BytesFieldUpdateOperationsInput | Bytes
    numQuestao?: IntFieldUpdateOperationsInput | number
  }

  export type ProvaPraticaUpdateWithoutProvaInput = {
    blocosProvas?: BlocoProvaUpdateManyWithoutProvaPraticaNestedInput
    Categoria?: CategoriaUpdateManyWithoutProvaPraticaNestedInput
    Recurso?: RecursoUpdateManyWithoutProvaPraticaNestedInput
  }

  export type ProvaPraticaUncheckedUpdateWithoutProvaInput = {
    idProvaPratica?: IntFieldUpdateOperationsInput | number
    blocosProvas?: BlocoProvaUncheckedUpdateManyWithoutProvaPraticaNestedInput
    Categoria?: CategoriaUncheckedUpdateManyWithoutProvaPraticaNestedInput
    Recurso?: RecursoUncheckedUpdateManyWithoutProvaPraticaNestedInput
  }

  export type ProvaPraticaUncheckedUpdateManyWithoutProvaInput = {
    idProvaPratica?: IntFieldUpdateOperationsInput | number
  }

  export type RecursoUpdateWithoutProvaInput = {
    nomeRecurso?: StringFieldUpdateOperationsInput | string
    justificativa?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dataRecurso?: DateTimeFieldUpdateOperationsInput | Date | string
    arquivos?: BytesFieldUpdateOperationsInput | Bytes
    Candidato?: CandidatoUpdateOneRequiredWithoutRecursoNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutRecursosNestedInput
    Quesito?: QuesitosUpdateOneRequiredWithoutRecursosNestedInput
    ProvaTeorica?: ProvaTeoricaUpdateOneWithoutRecursoNestedInput
    ProvaPratica?: ProvaPraticaUpdateOneWithoutRecursoNestedInput
  }

  export type RecursoUncheckedUpdateWithoutProvaInput = {
    idRecurso?: IntFieldUpdateOperationsInput | number
    nomeRecurso?: StringFieldUpdateOperationsInput | string
    justificativa?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dataRecurso?: DateTimeFieldUpdateOperationsInput | Date | string
    arquivos?: BytesFieldUpdateOperationsInput | Bytes
    candidato?: IntFieldUpdateOperationsInput | number
    avaliador?: IntFieldUpdateOperationsInput | number
    quesitoRecurso?: IntFieldUpdateOperationsInput | number
    provaTeoricaIdprovaTeorica?: NullableIntFieldUpdateOperationsInput | number | null
    provaPraticaIdProvaPratica?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RecursoUncheckedUpdateManyWithoutProvaInput = {
    idRecurso?: IntFieldUpdateOperationsInput | number
    nomeRecurso?: StringFieldUpdateOperationsInput | string
    justificativa?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dataRecurso?: DateTimeFieldUpdateOperationsInput | Date | string
    arquivos?: BytesFieldUpdateOperationsInput | Bytes
    candidato?: IntFieldUpdateOperationsInput | number
    avaliador?: IntFieldUpdateOperationsInput | number
    quesitoRecurso?: IntFieldUpdateOperationsInput | number
    provaTeoricaIdprovaTeorica?: NullableIntFieldUpdateOperationsInput | number | null
    provaPraticaIdProvaPratica?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AvaliacaoUpdateWithoutProvaInput = {
    dataAvaliacao?: DateTimeFieldUpdateOperationsInput | Date | string
    nota?: FloatFieldUpdateOperationsInput | number
    Comissao?: ComissaoUpdateOneRequiredWithoutAvalicaoNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutAvalicoesNestedInput
    BlocoProva?: BlocoProvaUpdateOneWithoutAvaliacaoNestedInput
    quesitos?: QuesitosUpdateManyWithoutAvaliacaoNestedInput
    Candidato?: CandidatoUpdateOneRequiredWithoutAvalicoesNestedInput
    FichaCandidato?: FichaCandidatoUpdateOneWithoutAvaliacoesNestedInput
  }

  export type AvaliacaoUncheckedUpdateWithoutProvaInput = {
    idAvalicao?: IntFieldUpdateOperationsInput | number
    dataAvaliacao?: DateTimeFieldUpdateOperationsInput | Date | string
    comissaoId?: IntFieldUpdateOperationsInput | number
    avaliadorId?: IntFieldUpdateOperationsInput | number
    blocoProvaId?: NullableIntFieldUpdateOperationsInput | number | null
    nota?: FloatFieldUpdateOperationsInput | number
    candidatoId?: IntFieldUpdateOperationsInput | number
    fichaCandidatoIdFicha?: NullableIntFieldUpdateOperationsInput | number | null
    quesitos?: QuesitosUncheckedUpdateManyWithoutAvaliacaoNestedInput
  }

  export type AvaliacaoUncheckedUpdateManyWithoutProvaInput = {
    idAvalicao?: IntFieldUpdateOperationsInput | number
    dataAvaliacao?: DateTimeFieldUpdateOperationsInput | Date | string
    comissaoId?: IntFieldUpdateOperationsInput | number
    avaliadorId?: IntFieldUpdateOperationsInput | number
    blocoProvaId?: NullableIntFieldUpdateOperationsInput | number | null
    nota?: FloatFieldUpdateOperationsInput | number
    candidatoId?: IntFieldUpdateOperationsInput | number
    fichaCandidatoIdFicha?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuesitosCreateManyProvaTeoricaInput = {
    idQuesito?: number
    nomeQuesito: string
    notaMaximaQuesito: number
    danca: boolean
    dancaSalaoTradicional: $Enums.DancaSalaoTradicional
    blocoProvaIdBloco?: number | null
    preferenciaSorteioDancaId?: number | null
    avaliacaoIdAvalicao?: number | null
  }

  export type CategoriaCreateManyProvaTeoricaInput = {
    idCategoria?: number
    nomeCategoria: string
    escolaridade: string
    sorteioDanca: number
    idadeInicial: number
    idadeLimite?: number | null
    provaId?: number | null
    provaPraticaId?: number | null
  }

  export type RecursoCreateManyProvaTeoricaInput = {
    idRecurso?: number
    nomeRecurso: string
    justificativa: string
    status: boolean
    dataRecurso?: Date | string
    arquivos: Bytes
    candidato: number
    avaliador: number
    quesitoRecurso: number
    provaPraticaIdProvaPratica?: number | null
    provaIdProva?: number | null
  }

  export type QuesitosUpdateWithoutProvaTeoricaInput = {
    nomeQuesito?: StringFieldUpdateOperationsInput | string
    notaMaximaQuesito?: FloatFieldUpdateOperationsInput | number
    danca?: BoolFieldUpdateOperationsInput | boolean
    dancaSalaoTradicional?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
    BlocoProva?: BlocoProvaUpdateOneWithoutQuesitosNestedInput
    subeQuesitos?: SubQuesitosUpdateManyWithoutQuesitoNestedInput
    recursos?: RecursoUpdateManyWithoutQuesitoNestedInput
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaUpdateOneWithoutQuesitosNestedInput
    Avaliacao?: AvaliacaoUpdateOneWithoutQuesitosNestedInput
  }

  export type QuesitosUncheckedUpdateWithoutProvaTeoricaInput = {
    idQuesito?: IntFieldUpdateOperationsInput | number
    nomeQuesito?: StringFieldUpdateOperationsInput | string
    notaMaximaQuesito?: FloatFieldUpdateOperationsInput | number
    danca?: BoolFieldUpdateOperationsInput | boolean
    dancaSalaoTradicional?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
    blocoProvaIdBloco?: NullableIntFieldUpdateOperationsInput | number | null
    preferenciaSorteioDancaId?: NullableIntFieldUpdateOperationsInput | number | null
    avaliacaoIdAvalicao?: NullableIntFieldUpdateOperationsInput | number | null
    subeQuesitos?: SubQuesitosUncheckedUpdateManyWithoutQuesitoNestedInput
    recursos?: RecursoUncheckedUpdateManyWithoutQuesitoNestedInput
  }

  export type QuesitosUncheckedUpdateManyWithoutProvaTeoricaInput = {
    idQuesito?: IntFieldUpdateOperationsInput | number
    nomeQuesito?: StringFieldUpdateOperationsInput | string
    notaMaximaQuesito?: FloatFieldUpdateOperationsInput | number
    danca?: BoolFieldUpdateOperationsInput | boolean
    dancaSalaoTradicional?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
    blocoProvaIdBloco?: NullableIntFieldUpdateOperationsInput | number | null
    preferenciaSorteioDancaId?: NullableIntFieldUpdateOperationsInput | number | null
    avaliacaoIdAvalicao?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CategoriaUpdateWithoutProvaTeoricaInput = {
    nomeCategoria?: StringFieldUpdateOperationsInput | string
    escolaridade?: StringFieldUpdateOperationsInput | string
    sorteioDanca?: IntFieldUpdateOperationsInput | number
    idadeInicial?: IntFieldUpdateOperationsInput | number
    idadeLimite?: NullableIntFieldUpdateOperationsInput | number | null
    candidatos?: CandidatoUpdateManyWithoutCategoriaNestedInput
    Prova?: ProvaUpdateOneWithoutCategoriasNestedInput
    ProvaPratica?: ProvaPraticaUpdateOneWithoutCategoriaNestedInput
  }

  export type CategoriaUncheckedUpdateWithoutProvaTeoricaInput = {
    idCategoria?: IntFieldUpdateOperationsInput | number
    nomeCategoria?: StringFieldUpdateOperationsInput | string
    escolaridade?: StringFieldUpdateOperationsInput | string
    sorteioDanca?: IntFieldUpdateOperationsInput | number
    idadeInicial?: IntFieldUpdateOperationsInput | number
    idadeLimite?: NullableIntFieldUpdateOperationsInput | number | null
    provaId?: NullableIntFieldUpdateOperationsInput | number | null
    provaPraticaId?: NullableIntFieldUpdateOperationsInput | number | null
    candidatos?: CandidatoUncheckedUpdateManyWithoutCategoriaNestedInput
  }

  export type CategoriaUncheckedUpdateManyWithoutProvaTeoricaInput = {
    idCategoria?: IntFieldUpdateOperationsInput | number
    nomeCategoria?: StringFieldUpdateOperationsInput | string
    escolaridade?: StringFieldUpdateOperationsInput | string
    sorteioDanca?: IntFieldUpdateOperationsInput | number
    idadeInicial?: IntFieldUpdateOperationsInput | number
    idadeLimite?: NullableIntFieldUpdateOperationsInput | number | null
    provaId?: NullableIntFieldUpdateOperationsInput | number | null
    provaPraticaId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RecursoUpdateWithoutProvaTeoricaInput = {
    nomeRecurso?: StringFieldUpdateOperationsInput | string
    justificativa?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dataRecurso?: DateTimeFieldUpdateOperationsInput | Date | string
    arquivos?: BytesFieldUpdateOperationsInput | Bytes
    Candidato?: CandidatoUpdateOneRequiredWithoutRecursoNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutRecursosNestedInput
    Quesito?: QuesitosUpdateOneRequiredWithoutRecursosNestedInput
    ProvaPratica?: ProvaPraticaUpdateOneWithoutRecursoNestedInput
    Prova?: ProvaUpdateOneWithoutRecursosNestedInput
  }

  export type RecursoUncheckedUpdateWithoutProvaTeoricaInput = {
    idRecurso?: IntFieldUpdateOperationsInput | number
    nomeRecurso?: StringFieldUpdateOperationsInput | string
    justificativa?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dataRecurso?: DateTimeFieldUpdateOperationsInput | Date | string
    arquivos?: BytesFieldUpdateOperationsInput | Bytes
    candidato?: IntFieldUpdateOperationsInput | number
    avaliador?: IntFieldUpdateOperationsInput | number
    quesitoRecurso?: IntFieldUpdateOperationsInput | number
    provaPraticaIdProvaPratica?: NullableIntFieldUpdateOperationsInput | number | null
    provaIdProva?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RecursoUncheckedUpdateManyWithoutProvaTeoricaInput = {
    idRecurso?: IntFieldUpdateOperationsInput | number
    nomeRecurso?: StringFieldUpdateOperationsInput | string
    justificativa?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dataRecurso?: DateTimeFieldUpdateOperationsInput | Date | string
    arquivos?: BytesFieldUpdateOperationsInput | Bytes
    candidato?: IntFieldUpdateOperationsInput | number
    avaliador?: IntFieldUpdateOperationsInput | number
    quesitoRecurso?: IntFieldUpdateOperationsInput | number
    provaPraticaIdProvaPratica?: NullableIntFieldUpdateOperationsInput | number | null
    provaIdProva?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BlocoProvaCreateManyProvaPraticaInput = {
    idBloco?: number
    nomeBloco: string
    notaMaximaBloco: number
  }

  export type CategoriaCreateManyProvaPraticaInput = {
    idCategoria?: number
    nomeCategoria: string
    escolaridade: string
    sorteioDanca: number
    idadeInicial: number
    idadeLimite?: number | null
    provaId?: number | null
    provaTeoricaId?: number | null
  }

  export type RecursoCreateManyProvaPraticaInput = {
    idRecurso?: number
    nomeRecurso: string
    justificativa: string
    status: boolean
    dataRecurso?: Date | string
    arquivos: Bytes
    candidato: number
    avaliador: number
    quesitoRecurso: number
    provaTeoricaIdprovaTeorica?: number | null
    provaIdProva?: number | null
  }

  export type BlocoProvaUpdateWithoutProvaPraticaInput = {
    nomeBloco?: StringFieldUpdateOperationsInput | string
    notaMaximaBloco?: FloatFieldUpdateOperationsInput | number
    quesitos?: QuesitosUpdateManyWithoutBlocoProvaNestedInput
    Avaliacao?: AvaliacaoUpdateManyWithoutBlocoProvaNestedInput
  }

  export type BlocoProvaUncheckedUpdateWithoutProvaPraticaInput = {
    idBloco?: IntFieldUpdateOperationsInput | number
    nomeBloco?: StringFieldUpdateOperationsInput | string
    notaMaximaBloco?: FloatFieldUpdateOperationsInput | number
    quesitos?: QuesitosUncheckedUpdateManyWithoutBlocoProvaNestedInput
    Avaliacao?: AvaliacaoUncheckedUpdateManyWithoutBlocoProvaNestedInput
  }

  export type BlocoProvaUncheckedUpdateManyWithoutProvaPraticaInput = {
    idBloco?: IntFieldUpdateOperationsInput | number
    nomeBloco?: StringFieldUpdateOperationsInput | string
    notaMaximaBloco?: FloatFieldUpdateOperationsInput | number
  }

  export type CategoriaUpdateWithoutProvaPraticaInput = {
    nomeCategoria?: StringFieldUpdateOperationsInput | string
    escolaridade?: StringFieldUpdateOperationsInput | string
    sorteioDanca?: IntFieldUpdateOperationsInput | number
    idadeInicial?: IntFieldUpdateOperationsInput | number
    idadeLimite?: NullableIntFieldUpdateOperationsInput | number | null
    candidatos?: CandidatoUpdateManyWithoutCategoriaNestedInput
    Prova?: ProvaUpdateOneWithoutCategoriasNestedInput
    ProvaTeorica?: ProvaTeoricaUpdateOneWithoutCategoriaNestedInput
  }

  export type CategoriaUncheckedUpdateWithoutProvaPraticaInput = {
    idCategoria?: IntFieldUpdateOperationsInput | number
    nomeCategoria?: StringFieldUpdateOperationsInput | string
    escolaridade?: StringFieldUpdateOperationsInput | string
    sorteioDanca?: IntFieldUpdateOperationsInput | number
    idadeInicial?: IntFieldUpdateOperationsInput | number
    idadeLimite?: NullableIntFieldUpdateOperationsInput | number | null
    provaId?: NullableIntFieldUpdateOperationsInput | number | null
    provaTeoricaId?: NullableIntFieldUpdateOperationsInput | number | null
    candidatos?: CandidatoUncheckedUpdateManyWithoutCategoriaNestedInput
  }

  export type CategoriaUncheckedUpdateManyWithoutProvaPraticaInput = {
    idCategoria?: IntFieldUpdateOperationsInput | number
    nomeCategoria?: StringFieldUpdateOperationsInput | string
    escolaridade?: StringFieldUpdateOperationsInput | string
    sorteioDanca?: IntFieldUpdateOperationsInput | number
    idadeInicial?: IntFieldUpdateOperationsInput | number
    idadeLimite?: NullableIntFieldUpdateOperationsInput | number | null
    provaId?: NullableIntFieldUpdateOperationsInput | number | null
    provaTeoricaId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RecursoUpdateWithoutProvaPraticaInput = {
    nomeRecurso?: StringFieldUpdateOperationsInput | string
    justificativa?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dataRecurso?: DateTimeFieldUpdateOperationsInput | Date | string
    arquivos?: BytesFieldUpdateOperationsInput | Bytes
    Candidato?: CandidatoUpdateOneRequiredWithoutRecursoNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutRecursosNestedInput
    Quesito?: QuesitosUpdateOneRequiredWithoutRecursosNestedInput
    ProvaTeorica?: ProvaTeoricaUpdateOneWithoutRecursoNestedInput
    Prova?: ProvaUpdateOneWithoutRecursosNestedInput
  }

  export type RecursoUncheckedUpdateWithoutProvaPraticaInput = {
    idRecurso?: IntFieldUpdateOperationsInput | number
    nomeRecurso?: StringFieldUpdateOperationsInput | string
    justificativa?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dataRecurso?: DateTimeFieldUpdateOperationsInput | Date | string
    arquivos?: BytesFieldUpdateOperationsInput | Bytes
    candidato?: IntFieldUpdateOperationsInput | number
    avaliador?: IntFieldUpdateOperationsInput | number
    quesitoRecurso?: IntFieldUpdateOperationsInput | number
    provaTeoricaIdprovaTeorica?: NullableIntFieldUpdateOperationsInput | number | null
    provaIdProva?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RecursoUncheckedUpdateManyWithoutProvaPraticaInput = {
    idRecurso?: IntFieldUpdateOperationsInput | number
    nomeRecurso?: StringFieldUpdateOperationsInput | string
    justificativa?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dataRecurso?: DateTimeFieldUpdateOperationsInput | Date | string
    arquivos?: BytesFieldUpdateOperationsInput | Bytes
    candidato?: IntFieldUpdateOperationsInput | number
    avaliador?: IntFieldUpdateOperationsInput | number
    quesitoRecurso?: IntFieldUpdateOperationsInput | number
    provaTeoricaIdprovaTeorica?: NullableIntFieldUpdateOperationsInput | number | null
    provaIdProva?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuesitosCreateManyBlocoProvaInput = {
    idQuesito?: number
    nomeQuesito: string
    notaMaximaQuesito: number
    danca: boolean
    dancaSalaoTradicional: $Enums.DancaSalaoTradicional
    provaTeoricaIdprovaTeorica?: number | null
    preferenciaSorteioDancaId?: number | null
    avaliacaoIdAvalicao?: number | null
  }

  export type AvaliacaoCreateManyBlocoProvaInput = {
    idAvalicao?: number
    dataAvaliacao?: Date | string
    comissaoId: number
    avaliadorId: number
    provaId: number
    nota: number
    candidatoId: number
    fichaCandidatoIdFicha?: number | null
  }

  export type QuesitosUpdateWithoutBlocoProvaInput = {
    nomeQuesito?: StringFieldUpdateOperationsInput | string
    notaMaximaQuesito?: FloatFieldUpdateOperationsInput | number
    danca?: BoolFieldUpdateOperationsInput | boolean
    dancaSalaoTradicional?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
    ProvaTeorica?: ProvaTeoricaUpdateOneWithoutQuesitosNestedInput
    subeQuesitos?: SubQuesitosUpdateManyWithoutQuesitoNestedInput
    recursos?: RecursoUpdateManyWithoutQuesitoNestedInput
    PreferenciaSorteioDanca?: PreferenciaSorteioDancaUpdateOneWithoutQuesitosNestedInput
    Avaliacao?: AvaliacaoUpdateOneWithoutQuesitosNestedInput
  }

  export type QuesitosUncheckedUpdateWithoutBlocoProvaInput = {
    idQuesito?: IntFieldUpdateOperationsInput | number
    nomeQuesito?: StringFieldUpdateOperationsInput | string
    notaMaximaQuesito?: FloatFieldUpdateOperationsInput | number
    danca?: BoolFieldUpdateOperationsInput | boolean
    dancaSalaoTradicional?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
    provaTeoricaIdprovaTeorica?: NullableIntFieldUpdateOperationsInput | number | null
    preferenciaSorteioDancaId?: NullableIntFieldUpdateOperationsInput | number | null
    avaliacaoIdAvalicao?: NullableIntFieldUpdateOperationsInput | number | null
    subeQuesitos?: SubQuesitosUncheckedUpdateManyWithoutQuesitoNestedInput
    recursos?: RecursoUncheckedUpdateManyWithoutQuesitoNestedInput
  }

  export type QuesitosUncheckedUpdateManyWithoutBlocoProvaInput = {
    idQuesito?: IntFieldUpdateOperationsInput | number
    nomeQuesito?: StringFieldUpdateOperationsInput | string
    notaMaximaQuesito?: FloatFieldUpdateOperationsInput | number
    danca?: BoolFieldUpdateOperationsInput | boolean
    dancaSalaoTradicional?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
    provaTeoricaIdprovaTeorica?: NullableIntFieldUpdateOperationsInput | number | null
    preferenciaSorteioDancaId?: NullableIntFieldUpdateOperationsInput | number | null
    avaliacaoIdAvalicao?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AvaliacaoUpdateWithoutBlocoProvaInput = {
    dataAvaliacao?: DateTimeFieldUpdateOperationsInput | Date | string
    nota?: FloatFieldUpdateOperationsInput | number
    Comissao?: ComissaoUpdateOneRequiredWithoutAvalicaoNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutAvalicoesNestedInput
    Prova?: ProvaUpdateOneWithoutAvaliacaoNestedInput
    quesitos?: QuesitosUpdateManyWithoutAvaliacaoNestedInput
    Candidato?: CandidatoUpdateOneRequiredWithoutAvalicoesNestedInput
    FichaCandidato?: FichaCandidatoUpdateOneWithoutAvaliacoesNestedInput
  }

  export type AvaliacaoUncheckedUpdateWithoutBlocoProvaInput = {
    idAvalicao?: IntFieldUpdateOperationsInput | number
    dataAvaliacao?: DateTimeFieldUpdateOperationsInput | Date | string
    comissaoId?: IntFieldUpdateOperationsInput | number
    avaliadorId?: IntFieldUpdateOperationsInput | number
    provaId?: IntFieldUpdateOperationsInput | number
    nota?: FloatFieldUpdateOperationsInput | number
    candidatoId?: IntFieldUpdateOperationsInput | number
    fichaCandidatoIdFicha?: NullableIntFieldUpdateOperationsInput | number | null
    quesitos?: QuesitosUncheckedUpdateManyWithoutAvaliacaoNestedInput
  }

  export type AvaliacaoUncheckedUpdateManyWithoutBlocoProvaInput = {
    idAvalicao?: IntFieldUpdateOperationsInput | number
    dataAvaliacao?: DateTimeFieldUpdateOperationsInput | Date | string
    comissaoId?: IntFieldUpdateOperationsInput | number
    avaliadorId?: IntFieldUpdateOperationsInput | number
    provaId?: IntFieldUpdateOperationsInput | number
    nota?: FloatFieldUpdateOperationsInput | number
    candidatoId?: IntFieldUpdateOperationsInput | number
    fichaCandidatoIdFicha?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SubQuesitosCreateManyQuesitoInput = {
    idSubequestios?: number
    nomeSubquesito: string
    notaSubequesito: number
  }

  export type RecursoCreateManyQuesitoInput = {
    idRecurso?: number
    nomeRecurso: string
    justificativa: string
    status: boolean
    dataRecurso?: Date | string
    arquivos: Bytes
    candidato: number
    avaliador: number
    provaTeoricaIdprovaTeorica?: number | null
    provaPraticaIdProvaPratica?: number | null
    provaIdProva?: number | null
  }

  export type SubQuesitosUpdateWithoutQuesitoInput = {
    nomeSubquesito?: StringFieldUpdateOperationsInput | string
    notaSubequesito?: FloatFieldUpdateOperationsInput | number
    subequesitosFilhos?: SubQuesitosUpdateManyWithoutSubequesitosPaiNestedInput
    subequesitosPai?: SubQuesitosUpdateManyWithoutSubequesitosFilhosNestedInput
  }

  export type SubQuesitosUncheckedUpdateWithoutQuesitoInput = {
    idSubequestios?: IntFieldUpdateOperationsInput | number
    nomeSubquesito?: StringFieldUpdateOperationsInput | string
    notaSubequesito?: FloatFieldUpdateOperationsInput | number
    subequesitosFilhos?: SubQuesitosUncheckedUpdateManyWithoutSubequesitosPaiNestedInput
    subequesitosPai?: SubQuesitosUncheckedUpdateManyWithoutSubequesitosFilhosNestedInput
  }

  export type SubQuesitosUncheckedUpdateManyWithoutQuesitoInput = {
    idSubequestios?: IntFieldUpdateOperationsInput | number
    nomeSubquesito?: StringFieldUpdateOperationsInput | string
    notaSubequesito?: FloatFieldUpdateOperationsInput | number
  }

  export type RecursoUpdateWithoutQuesitoInput = {
    nomeRecurso?: StringFieldUpdateOperationsInput | string
    justificativa?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dataRecurso?: DateTimeFieldUpdateOperationsInput | Date | string
    arquivos?: BytesFieldUpdateOperationsInput | Bytes
    Candidato?: CandidatoUpdateOneRequiredWithoutRecursoNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutRecursosNestedInput
    ProvaTeorica?: ProvaTeoricaUpdateOneWithoutRecursoNestedInput
    ProvaPratica?: ProvaPraticaUpdateOneWithoutRecursoNestedInput
    Prova?: ProvaUpdateOneWithoutRecursosNestedInput
  }

  export type RecursoUncheckedUpdateWithoutQuesitoInput = {
    idRecurso?: IntFieldUpdateOperationsInput | number
    nomeRecurso?: StringFieldUpdateOperationsInput | string
    justificativa?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dataRecurso?: DateTimeFieldUpdateOperationsInput | Date | string
    arquivos?: BytesFieldUpdateOperationsInput | Bytes
    candidato?: IntFieldUpdateOperationsInput | number
    avaliador?: IntFieldUpdateOperationsInput | number
    provaTeoricaIdprovaTeorica?: NullableIntFieldUpdateOperationsInput | number | null
    provaPraticaIdProvaPratica?: NullableIntFieldUpdateOperationsInput | number | null
    provaIdProva?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RecursoUncheckedUpdateManyWithoutQuesitoInput = {
    idRecurso?: IntFieldUpdateOperationsInput | number
    nomeRecurso?: StringFieldUpdateOperationsInput | string
    justificativa?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    dataRecurso?: DateTimeFieldUpdateOperationsInput | Date | string
    arquivos?: BytesFieldUpdateOperationsInput | Bytes
    candidato?: IntFieldUpdateOperationsInput | number
    avaliador?: IntFieldUpdateOperationsInput | number
    provaTeoricaIdprovaTeorica?: NullableIntFieldUpdateOperationsInput | number | null
    provaPraticaIdProvaPratica?: NullableIntFieldUpdateOperationsInput | number | null
    provaIdProva?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SubQuesitosUpdateWithoutSubequesitosPaiInput = {
    nomeSubquesito?: StringFieldUpdateOperationsInput | string
    notaSubequesito?: FloatFieldUpdateOperationsInput | number
    Quesito?: QuesitosUpdateOneRequiredWithoutSubeQuesitosNestedInput
    subequesitosFilhos?: SubQuesitosUpdateManyWithoutSubequesitosPaiNestedInput
  }

  export type SubQuesitosUncheckedUpdateWithoutSubequesitosPaiInput = {
    idSubequestios?: IntFieldUpdateOperationsInput | number
    nomeSubquesito?: StringFieldUpdateOperationsInput | string
    notaSubequesito?: FloatFieldUpdateOperationsInput | number
    quesitoId?: IntFieldUpdateOperationsInput | number
    subequesitosFilhos?: SubQuesitosUncheckedUpdateManyWithoutSubequesitosPaiNestedInput
  }

  export type SubQuesitosUncheckedUpdateManyWithoutSubequesitosPaiInput = {
    idSubequestios?: IntFieldUpdateOperationsInput | number
    nomeSubquesito?: StringFieldUpdateOperationsInput | string
    notaSubequesito?: FloatFieldUpdateOperationsInput | number
    quesitoId?: IntFieldUpdateOperationsInput | number
  }

  export type SubQuesitosUpdateWithoutSubequesitosFilhosInput = {
    nomeSubquesito?: StringFieldUpdateOperationsInput | string
    notaSubequesito?: FloatFieldUpdateOperationsInput | number
    Quesito?: QuesitosUpdateOneRequiredWithoutSubeQuesitosNestedInput
    subequesitosPai?: SubQuesitosUpdateManyWithoutSubequesitosFilhosNestedInput
  }

  export type SubQuesitosUncheckedUpdateWithoutSubequesitosFilhosInput = {
    idSubequestios?: IntFieldUpdateOperationsInput | number
    nomeSubquesito?: StringFieldUpdateOperationsInput | string
    notaSubequesito?: FloatFieldUpdateOperationsInput | number
    quesitoId?: IntFieldUpdateOperationsInput | number
    subequesitosPai?: SubQuesitosUncheckedUpdateManyWithoutSubequesitosFilhosNestedInput
  }

  export type SubQuesitosUncheckedUpdateManyWithoutSubequesitosFilhosInput = {
    idSubequestios?: IntFieldUpdateOperationsInput | number
    nomeSubquesito?: StringFieldUpdateOperationsInput | string
    notaSubequesito?: FloatFieldUpdateOperationsInput | number
    quesitoId?: IntFieldUpdateOperationsInput | number
  }

  export type PreferenciaSorteioDancaCreateManySorteioDancaInput = {
    idPreferencia?: number
    nomeSorteioDanca: $Enums.DancaSalaoTradicional
    candidatoId: number
  }

  export type PreferenciaSorteioDancaUpdateWithoutSorteioDancaInput = {
    nomeSorteioDanca?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
    Candidato?: CandidatoUpdateOneRequiredWithoutPreferenciaSorteioDancaNestedInput
    quesitos?: QuesitosUpdateManyWithoutPreferenciaSorteioDancaNestedInput
  }

  export type PreferenciaSorteioDancaUncheckedUpdateWithoutSorteioDancaInput = {
    idPreferencia?: IntFieldUpdateOperationsInput | number
    nomeSorteioDanca?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
    candidatoId?: IntFieldUpdateOperationsInput | number
    quesitos?: QuesitosUncheckedUpdateManyWithoutPreferenciaSorteioDancaNestedInput
  }

  export type PreferenciaSorteioDancaUncheckedUpdateManyWithoutSorteioDancaInput = {
    idPreferencia?: IntFieldUpdateOperationsInput | number
    nomeSorteioDanca?: EnumDancaSalaoTradicionalFieldUpdateOperationsInput | $Enums.DancaSalaoTradicional
    candidatoId?: IntFieldUpdateOperationsInput | number
  }

  export type AvaliacaoCreateManyFichaCandidatoInput = {
    idAvalicao?: number
    dataAvaliacao?: Date | string
    comissaoId: number
    avaliadorId: number
    provaId: number
    blocoProvaId?: number | null
    nota: number
    candidatoId: number
  }

  export type AvaliacaoUpdateWithoutFichaCandidatoInput = {
    dataAvaliacao?: DateTimeFieldUpdateOperationsInput | Date | string
    nota?: FloatFieldUpdateOperationsInput | number
    Comissao?: ComissaoUpdateOneRequiredWithoutAvalicaoNestedInput
    Usuario?: UsuarioUpdateOneRequiredWithoutAvalicoesNestedInput
    Prova?: ProvaUpdateOneWithoutAvaliacaoNestedInput
    BlocoProva?: BlocoProvaUpdateOneWithoutAvaliacaoNestedInput
    quesitos?: QuesitosUpdateManyWithoutAvaliacaoNestedInput
    Candidato?: CandidatoUpdateOneRequiredWithoutAvalicoesNestedInput
  }

  export type AvaliacaoUncheckedUpdateWithoutFichaCandidatoInput = {
    idAvalicao?: IntFieldUpdateOperationsInput | number
    dataAvaliacao?: DateTimeFieldUpdateOperationsInput | Date | string
    comissaoId?: IntFieldUpdateOperationsInput | number
    avaliadorId?: IntFieldUpdateOperationsInput | number
    provaId?: IntFieldUpdateOperationsInput | number
    blocoProvaId?: NullableIntFieldUpdateOperationsInput | number | null
    nota?: FloatFieldUpdateOperationsInput | number
    candidatoId?: IntFieldUpdateOperationsInput | number
    quesitos?: QuesitosUncheckedUpdateManyWithoutAvaliacaoNestedInput
  }

  export type AvaliacaoUncheckedUpdateManyWithoutFichaCandidatoInput = {
    idAvalicao?: IntFieldUpdateOperationsInput | number
    dataAvaliacao?: DateTimeFieldUpdateOperationsInput | Date | string
    comissaoId?: IntFieldUpdateOperationsInput | number
    avaliadorId?: IntFieldUpdateOperationsInput | number
    provaId?: IntFieldUpdateOperationsInput | number
    blocoProvaId?: NullableIntFieldUpdateOperationsInput | number | null
    nota?: FloatFieldUpdateOperationsInput | number
    candidatoId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}